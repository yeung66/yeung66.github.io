<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeungYeah 的乱写地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.top/"/>
  <updated>2020-12-14T03:29:26.481Z</updated>
  <id>http://scottyeung.top/</id>
  
  <author>
    <name>YeungYeah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>非主流下的少数选择</title>
    <link href="http://scottyeung.top/2020/minority-under-mainstream/"/>
    <id>http://scottyeung.top/2020/minority-under-mainstream/</id>
    <published>2020-12-13T11:52:23.000Z</published>
    <updated>2020-12-14T03:29:26.481Z</updated>
    
    <content type="html"><![CDATA[<p>又再因为环境的差异，因为所使用的操作系统与主流，或者说是大多数人用的不一样，导致额外浪费了不少的时间，尽管最终还是解决了，但内心很是不爽，在这期间还无数次诞生出了重装环境，换个发行版系统的念头，不过考虑到近段时间实在太忙，没时间配置新的系统环境而放弃。话虽如此，新的系统的镜像我已经下好几个了，实在忍不住了，或者是有时间之后，估计马上就会换掉。</p><a id="more"></a><p>这大概就是使用一些非主流环境和工具所需要付出的最大成本了。这里的非主流，也并不是说所使用的东西很是冷门，没什么人用，更多指的是，在某种使用场景或情况下面，它不是绝大多数人使用的解决方案，也不是官方推荐的方案。因为不是官方推荐，导致文档里面缺失方法步骤，因为它不是绝大多数人的选择，所以我们在搜索问题时能看到的大家出现的问题，其发生的环境都与我们不一样，自然给出的解决方法也不能应用到我们的环境上面。</p><p>以刚遇到的问题为例，我想要在 docker 里面开启 GPU 支持，但是拉下 cuda 的 docker 镜像后使用 <code>--gpus</code> 的参数却报错了。把错误提示到网上一搜，首页几乎全是一样的错误，然而这些错误发生的环境都是在 ubuntu 当中，给出的解决方法全都需要用到 debian 系的包管理工具 apt，使用 pacman 的 arch 系 Linux 提供自然用不了这些解决方法。即使在搜索框前加上系统的关键词 arch/manjaro，出现的搜索结果仍然还是这些 ubuntu 上的错误。难道说就没有人在 manjaro/arch linux 上面出现过这样的问题吗？这怎么可能？</p><p>参考了一下 ubuntu 上面的解决方法，似乎需要下个 nvidia-container-toolkit 的包。在搜到的官方文档看了一下，给出的安装方式就是没有 arch 系的环境。到 pacman 安装试了一下，没有，发现似乎有用户在 aur 传了相关的包了，yay 试了一次，构建的过程中链接出问题了，构建失败。最终在 yay 试了几个包后才下好，暂时解决了问题。</p><p>明明就是一个很简单的问题，就因为环境的差异，找不到在该环境下面的解决方案，导致额外付出了精力与时间。当然这次算是运气比较好，最终解决了问题，但如果问题解决不了，就真的只能够自己无能狂怒了。在这个过程中，自己也无数次懊悔过为啥要选择 Manjaro，不老老实实选一个最多人选择的 Linux 系统环境。现在选择成为少数，自然要为其付出相应的时间和精力成本。</p><p>即便如此，仍然还是会有很多人选择成为这少数，也包括我。当时为什么会做出这个选择，选择成为少数呢？</p><p>主流很多时候能够成为主流，并不是因为它有多好，更多的只是因为它抓住了某个机会，抢占了绝大多数的用户和市场，而它一旦有了规模效应之后，就能够非常容易地吸收到绝大多数用户的加入这个选择，反向地壮大这个群体。因为绝大多数用户都是 Ubuntu 用户，因此它们所写的教程和资料自然都是在 Ubuntu 环境上的相关内容，作为一个新用户，自然更倾向于加入 Ubuntu 阵营。尤其是在中文互联网社区，百度搜索总是会给你返回在某所谓技术社区上面的大批相似文章。当然这里也不是说 Ubuntu 不好，只是<strong>我们能不能多点选择，对各种选择，各个方向更加友好点，从而让互联网社区更加友好呢？</strong> 为此，某些时候我更加倾向于所谓少数的选择，也算是一种支持，在某些时候，它们也能够给到我一些惊喜。尽管很多时候我自己也坚持不了，就比如 Chrome，先后转到 Edge 和 Firefox，还是忍不住要回来。</p><p>互联网自由开放的特点，一直都是我比较推崇和向往的。但现在的现象却是比较诡异的，不够自由，开放不足。各家互联网公司的画地为牢，把用户死死地圈在自己的一亩三分地里面，生怕用户和流量的流失，越垄断，越强大，越强大，就越有垄断的实力，不到你不屈服。最近就有一个被点名的现象：互联网企业下场到社区里的生鲜零售，通过超低价格和超高的补贴来占领市场，企图重现一次打车和外卖行业的现象。幸好很快就被大家意识到，官方也下场点名了资本了。</p><p>有实力的公司或者软件，逐渐成为主流难以避免，即使进化到垄断，也不足为奇。我们又能够做些什么呢？我们能不能给予更多的机会给不同的选择，尤其是处于弱势的选择呢？给多一点支持，多一次的尝试，可能就会有不一样的情况出现。然而在处于各种因为并非主流选择带来的不方便情况下，我们又可以坚持多久这些选择，不向主流投靠呢？</p><p>不管怎样，起码我也是坚持过了，而你呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又再因为环境的差异，因为所使用的操作系统与主流，或者说是大多数人用的不一样，导致额外浪费了不少的时间，尽管最终还是解决了，但内心很是不爽，在这期间还无数次诞生出了重装环境，换个发行版系统的念头，不过考虑到近段时间实在太忙，没时间配置新的系统环境而放弃。话虽如此，新的系统的镜像我已经下好几个了，实在忍不住了，或者是有时间之后，估计马上就会换掉。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://scottyeung.top/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Manjaro" scheme="http://scottyeung.top/tags/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>近期太极练习的反思</title>
    <link href="http://scottyeung.top/2020/taichi-practice-reflections/"/>
    <id>http://scottyeung.top/2020/taichi-practice-reflections/</id>
    <published>2020-12-04T09:07:43.000Z</published>
    <updated>2020-12-04T12:37:20.413Z</updated>
    
    <content type="html"><![CDATA[<p>从十月份开始练太极拳至今，已经差不多两个月了。在这个期间，基本每周会去练两三次，晚上九点跑去恩玲剧场练习松柔功操，周四跑去武术馆练练拳架套路。虽然感觉上已经练得很多，但实际上投入的时间也不算多。</p><p>兴趣确实是有的，收获也似乎算有，用王真人的话来说，也是有一点功力的，算是有点劲出来了。</p><a id="more"></a><p>然而在这两周的练习中，却感觉到自己好像已经进入到一个瓶颈期，感觉自己练了也有一段时间了，但是没什么长进，尤其是在功操上面。</p><p>当初第一次练松柔功操的时候，因为里面有着比较多的会锻炼到下半身一些不太常用的肌肉群的动作（比如揉膝，蹲坐等集中在下盘的动作），而且强调身体其它地方放松，只靠特定的肌肉群出力，因而特别酸爽。第一次练完，就跟健身练完腿差不多，酸软无力，抬不起来的感觉。</p><p>可惜的是，直到现在的我，也依然会在练习几个揉膝动作后感到大腿酸软，而其余的动作，也依然在练习时有着比较强烈的感觉，让我感觉到自己其实并没有长进，并没有提升。至于其它的套路，站桩，因为太过于强调劲，强调感觉，也太过难以捉摸，这次好像有点感觉，下次同样的动作，同样的打法，却找不回来了。套路动作是学到了，而是否打对了，是否打得更好了，自己也不知道。</p><p>虽说只是为了兴趣在练习太极拳，但是如果一直这样练都还是这个水平，一直都没什么长进的话，其实自己内心也不太舒服，练习也练得没什么干劲。当然练习时间确实不长，每周最多也就三四小时，加起来可能就一两次机会练习，较大的提升自然不容易出现。但我也确实时间不多，虽说晚上去练拳可能也就练个一个小时多点，但是练拳前准备，练拳的洗浴休息，前前后后需要花费自己可能三个小时的学习时间，作为一个懒散的人来说，代价其实挺大，因为本来的学习时间就不多。</p><p>这也似乎陷入了一个不好的循环，时间不多导致选择去练拳的时间不多，练拳的时间不多自然效果不好进展缓慢，效果不好导致自己练拳的时候找不到感觉，兴趣消减，逐渐就更加不想去练拳，通过自己时间不同的事实作为借口来逃避练拳。这导致我已经一个星期没去练松柔功操了🤣。接下来一个月估计更加忙，可能练习次数更少（逃</p><p>要逼着自己先去练了再说吗？这样就似乎感觉违背自己所谓兴趣的性质了。其实更希望能够将太极，将练拳融入生活当中，时不时就站起来打打拳，站站桩，甚至在平时的生活活动里面，融入一些动作，进行锻炼。然而这样的行为在他人眼中实在有点奇怪，尤其是对于我这种性格的人，总是害怕在他人面前表现自己，羞于被他人看到我在干什么，即使是无意的。</p><p>离这个学期结束还剩一个月，希望自己能够剩下的拳架套路学完吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从十月份开始练太极拳至今，已经差不多两个月了。在这个期间，基本每周会去练两三次，晚上九点跑去恩玲剧场练习松柔功操，周四跑去武术馆练练拳架套路。虽然感觉上已经练得很多，但实际上投入的时间也不算多。&lt;/p&gt;
&lt;p&gt;兴趣确实是有的，收获也似乎算有，用王真人的话来说，也是有一点功力的，算是有点劲出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="太极" scheme="http://scottyeung.top/tags/%E5%A4%AA%E6%9E%81/"/>
    
  </entry>
  
  <entry>
    <title>记第一次把系统搞挂掉</title>
    <link href="http://scottyeung.top/2020/broke-up-the-os/"/>
    <id>http://scottyeung.top/2020/broke-up-the-os/</id>
    <published>2020-11-08T14:46:18.000Z</published>
    <updated>2020-11-08T15:32:55.712Z</updated>
    
    <content type="html"><![CDATA[<p><strong>高度的自由有时就意味着高度的脆弱性。</strong></p><p>今天就因为更换显卡驱动的原因把我实验室的机器给搞挂了，导致无法进入系统。</p><a id="more"></a><p>在实验室的机器到位之后，基本上我就逐步把工作环境迁移到实验室的机器上面，装了一个 Manjaro 系统，来感受一下滚动升级的爽快（<del>遇坑</del>）体验。系统采用的是 KDE 桌面，相关的工具环境都已经搞得七七八八了（到时写个文章来讲讲我是咋样在多终端同步工作<del>挣扎</del>的），在日常的工作和娱乐使用上面，基本已经没什么问题。</p><p>不过最近发现一个问题（bug），就是设备总是会在停止使用一段时间后，界面变色闪烁并且卡死。在忍受几次因卡死不得不重启之后，终于打算上网搜搜解决方法（感谢 vscode 与 typora 等软件的自动保存功能以及坚果云的自动同步让我即使卡死重启也没有丢失数据资料）。网上大多数人说是显卡驱动问题，我就跟着看到的其中一个回答的建议进行操作，把我所装的显卡驱动换成了另一个版本。看上去已经解决了。</p><p>然后出去打个水回来，发现机器又再次卡死了，然而这次重启，却已经启动不了。提示</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to start! Load kernel modules</span><br><span class="line">Failed to start! Load kernel modules</span><br></pre></td></tr></table></div></figure><p>当时的第一反应居然不是感到很慌，而是在想上午计划的任务做不完了，也是好笑。虽然这是第一次遇到这种状况，而且当时的我还没找到原因，但居然觉得这好像是习以为常的小事，可能这就是 <strong>Linux User Group 成员的觉悟</strong>吧。因为当时没带电脑，就用手机上网搜了搜相关问题，发现好像是刚刚更换的显卡驱动出问题了，把它换回来应该就没问题了吧。</p><p>那怎么更换显卡驱动，把新装的删掉，把旧的重新装回来呢？首先需要进入 bash。又怎样进入 bash 呢？网上说的 tty 我也进入不了，只能通过启动 U 盘（Live USB）进入系统然后加载本机环境。所以不得不跑回宿舍重新刻录一个启动盘，顺便睡了个午觉。</p><p>拿到启动 U 盘之后就比较简单了，直接通过 U 盘进入 U 盘的系统，然后在里面开终端通过 chroot 命令改到硬盘中的系统执行环境，然后把驱动换回来。（说起来很简单，但事实上这几个步骤以及当中的细节，我重复组合尝试了好几次才好起来了。主要操作为</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manjaro-chroot -a # 根据硬盘安装的系统进行挂载等操作，来切换到硬盘中系统的 bash 环境</span><br><span class="line"></span><br><span class="line">sudo mhwd -li # 列出安装的驱动，</span><br><span class="line">sudo mhwd -r driver-to-delete # 显卡驱动全删了</span><br><span class="line">sudo mhwd -i pci nonfree 0300 # 自适应安装一个闭源的显卡驱动</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新升级所有的 package，这一步感觉挺莫名其妙的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 大概是需要更加内核和引导文件以适配驱动文件？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里几乎把所有的 package 都重新安装了（因为这样导致我第一次不敢尝试又重启多了几次</span></span><br><span class="line">sudo pacman -Syyu </span><br></pre></td></tr></table></div></figure><p>现在回顾起来感觉修复好像也还挺简单的，然而当时却搞了我两个多小时。在这次问题之后，重新打开了我里面的备份软件 timeshift，还是有在每天备份快照的（意外发现今天的升级把系统也升了一个小版本号），这也让我萌生出了一种<del>豪气</del>错觉：</p><p><strong>只要给我一个 Live USB 让我进去 terminal，啥问题都好像可以解决。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;高度的自由有时就意味着高度的脆弱性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天就因为更换显卡驱动的原因把我实验室的机器给搞挂了，导致无法进入系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="Manjaro" scheme="http://scottyeung.top/tags/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>又一次的漫画爬取</title>
    <link href="http://scottyeung.top/2020/crawl-commic-again/"/>
    <id>http://scottyeung.top/2020/crawl-commic-again/</id>
    <published>2020-10-08T03:54:28.000Z</published>
    <updated>2020-10-14T08:11:04.493Z</updated>
    
    <content type="html"><![CDATA[        <h2 id="背景">          <a href="#背景" class="heading-link"><i class="fas fa-link"></i></a>背景</h2>      <p>最近刚开始追了一部 b 站的<span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/bangumi/play/ss34230">新番</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，觉得挺有意思，就打算看看它的漫画，但这漫画也是某站独家，不太想花钱，就打算上网找点资源白嫖（当然大家还是要支持正版的！我是已经支持太多了想省一省 <span class="github-emoji" data-alias="joy" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>)。然而网上找到的资源太少，且大多已经不可用，唯一找到的一个可以看的网站，图片质量太高，加载太慢，而且它的加载方式也很离谱，每一话在一个页面直接丢给你十几二十张图片，而且也没有 lazy load, 全部图片一起加载，体验极差。</p><p>所以没有办法，只能重操旧业，把它爬下来，免去了阅读过程中的等待时间。（对上一次的爬取可以<a href="http://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/">看此</a>）</p><a id="more"></a>        <h2 id="爬取思路">          <a href="#爬取思路" class="heading-link"><i class="fas fa-link"></i></a>爬取思路</h2>      <p>在漫画页的路径规则非常统一，都是那种 <code>http://host/:type/:commic-name/:chapter.html</code>, 直接根据规则生成 url 就行了。</p><p>打开开发者工具看了看页面的文档具体内容，发现漫画图片就直接硬编码嵌入在 <code>table tr td img</code> 中，而且每个图片还直接给了个形如 <code>img2</code> 这样的唯一的 id，XPath 都不需要思考怎么写了，直接 <code>//*[starts-with(@id,'img')]</code> 就可了。于是马上拿出 C# 写了一个函数，解析出单话的所有图片链接，然后下载。</p><p>然而发现 xpath 居然找不出了目标元素，一开始还以为是我的 XPath 写得有问题，换了几种写法都不行，看了看获取到的 html 文档全文，才发现这个页面是靠导入 Javascript 脚本，动态插入 DOM 节点来生成完整页面的，所以普通的静态爬取文档方法无效。对这种动态的页面，要么用模拟浏览器，等待它加载执行完 js, 再来解析页面元素，要么就直接深入它动态操作页面的 Javascript 脚本，直接从源头来找数据。因为我算是对 JavaScript 有点熟悉，而且爬虫等待页面加载完再解析页面，性能开销也未免太大（而且 C# 我也不太知道有啥可以像 Python 中的 Selenium 可以模拟浏览器操作的），于是就看了看它导入的一些 js 文件，然后就发现了它所使用的一份来自 11 年的历史遗留 js 代码。</p><p><img src="/2020/crawl-commic-again/1.png"></p><p>在现在的角度来看这份代码，简直就是灾难。</p><ul><li>随意地在随处定义全局变量</li><li>使用匿名对象的成员来封装函数</li><li>随心所欲的变量命名：<ul><li>大量的 a, aa, bb, ll 无意义命名</li><li>英语拼音混杂看不出意义的代码</li></ul></li><li>字符串拼接硬编码组成的待插入 html 标签</li></ul><p>还好有 IDE, 能够有变量搜索和函数跳转，大概的功能还是看出来了：加载文档时调用一个初始化方法，初始化方法根据一个图片的路径变量，生成一系列的 img 标签，插入到 html 文档里面。</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">imgload:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a,b;</span><br><span class="line">  b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">  a=qTcms_S_m_murl.split(<span class="string">&quot;$qingtiandy$&quot;</span>);</span><br><span class="line">  qTcms_page.Pic._arr=a;</span><br><span class="line">  qTcms_page.total=a.length;</span><br><span class="line">  <span class="keyword">var</span> ll1=a.length;</span><br><span class="line">  <span class="keyword">var</span> ll=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(ll&gt;ll1)ll=ll1;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ll;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> srcid=<span class="string">&#x27;img&#x27;</span>+(i+<span class="number">1</span>);</span><br><span class="line">    qTcms_page.curpage=(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bb=a[i];</span><br><span class="line">    <span class="keyword">var</span> cc=f_qTcms_Pic_curUrl_realpic(bb);</span><br><span class="line">    <span class="keyword">var</span> limg1=<span class="string">&quot;/statics/images/pic_loading.gif&quot;</span>;</span><br><span class="line">    $(<span class="string">&quot;#qTcms_Pic_middle tr td&quot;</span>).append(<span class="string">&#x27;&lt;div&gt;&lt;img class=&quot;comic_img&quot; src=&quot;&#x27;</span>+cc+<span class="string">&#x27;&quot; data-original=&quot;&#x27;</span>+cc+<span class="string">&#x27;&quot; id=&quot;&#x27;</span>+srcid+<span class="string">&#x27;&quot; style=&quot;display: inline;cursor: zoom-in;&quot; onclick=&quot;qTcms_page.relpic(\&#x27;&#x27;</span>+cc+<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>+srcid+<span class="string">&#x27;\&#x27;)&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但是这个变量 <code>qTcms_S_m_murl</code> 我怎么找都没找到它在哪里定义的，用倒是到处都在用，找了几个其它的 js 文件也没有找到，后来发现这居然是在原始的 html 文档直接给出的，原始 html 文档给了一个经过 base64 编码的所有图片链接地址作为一个全局变量，然后导入的 js 文件将该变量中的地址解码再分别取出每个图片的地址，生成 img 标签并插入到源文档中。</p><p>发现了它的这个方式之后，工作就很简单了，直接从原 html 文档中找出这个编码后的图片地址合集，解码后分别下载这些图片保存。</p>        <h2 id="实现">          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a>实现</h2>      <p>这次我选择了用 C# on dotnet core 来实现爬虫任务。按照上面的思路，具体的实现方式也很简单：</p><ol start="0" type="1"><li>根据要下载的漫画章节号，生成它的 url</li><li>发个 Get 请求获取这一话漫画的 html 文档，通过正则获取其中编码后的图片链接合集</li><li>对于图片链接中的每个图片链接，使用自带的 WebClient.DownloadFileAsync 方法直接下载图片文件到本地</li><li>然后就是统筹整个下载任务，逐话下载，每话分别获取图片链接，创建文件夹，下载所有漫画图片</li></ol><p>这里必须赞一句 dotnet core 对于异步编程的支持，着实做得太好了，自带的 async 和 await 关键字，以及其中用的几乎所有网络请求或者本地 IO 的方法，都给出了异步版本的实现，可以很容易地就实现异步编程，而这种基本是完全交由编译器去处理多线程的调度处理方式，所实现的效果我觉得是比我自己简单地开几个线程分别跑任务的部分是高效得多的。</p>        <h2 id="结果">          <a href="#结果" class="heading-link"><i class="fas fa-link"></i></a>结果</h2>      <p>这个 C# 的实现效率确实太强了，我尝试性下载了一话，二十来张图片，加起来四十多兆，十来秒就下载完了。下载前 80 话漫画，共 1.8G 的图片，总共也就用了 17 分钟，太快了！尤其是对比上一次的下载，下一话居然需要一两分钟，下载了不到一百话就用了两三个小时。当然这里面还有很多因素影响，而且上次的代码的异步编程实现也实现得很糟糕。</p><p>不过还是不妨碍我吹一句：<strong>我们 dotnet 真是太强啦！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;
          &lt;a href=&quot;#背景&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;背景&lt;/h2&gt;
      
&lt;p&gt;最近刚开始追了一部 b 站的&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://www.bilibili.com/bangumi/play/ss34230&quot;&gt;新番&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;，觉得挺有意思，就打算看看它的漫画，但这漫画也是某站独家，不太想花钱，就打算上网找点资源白嫖（当然大家还是要支持正版的！我是已经支持太多了想省一省 &lt;span class=&quot;github-emoji&quot; data-alias=&quot;joy&quot; style data-fallback-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8&quot;&gt;😂&lt;/span&gt;)。然而网上找到的资源太少，且大多已经不可用，唯一找到的一个可以看的网站，图片质量太高，加载太慢，而且它的加载方式也很离谱，每一话在一个页面直接丢给你十几二十张图片，而且也没有 lazy load, 全部图片一起加载，体验极差。&lt;/p&gt;
&lt;p&gt;所以没有办法，只能重操旧业，把它爬下来，免去了阅读过程中的等待时间。（对上一次的爬取可以&lt;a href=&quot;http://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/&quot;&gt;看此&lt;/a&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C#" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="异步编程" scheme="http://scottyeung.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="dotnet" scheme="http://scottyeung.top/tags/dotnet/"/>
    
  </entry>
  
  <entry>
    <title>对知行合一的一些想法</title>
    <link href="http://scottyeung.top/2020/knowledge-as-action/"/>
    <id>http://scottyeung.top/2020/knowledge-as-action/</id>
    <published>2020-10-03T05:49:25.000Z</published>
    <updated>2020-10-03T11:53:46.057Z</updated>
    
    <content type="html"><![CDATA[<p>昨天无意中看到了一个关于王阳明心学的回答，谈到了其中心学的精髓是什么，觉得挺有意思，就在晚上的时候重新认真地翻了翻这个问题，并且将其中的高赞回答摘录到了印象笔记中细细品味： <span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/28052564/answer/1282463260">王阳明的心学精髓是什么? - 知乎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，也算是有点收获，对于一直以来都觉得非常神奇，也非常向往的陆王心学有了更深的了解。</p><a id="more"></a><p>心学到底是什么？我对其的最主要印象，莫过于当中最为有名的一个信条——知行合一。什么是知行合一，按照字面理解，就是自己的认知，应该与自己的行为相符合一致，怎么想的，就应该要怎么做。这也是我个人对其比较浅显的理解。我对其的了解其实也不算深，大部分好像还是来源于以前初中的历史？ Anyway, 我还是很向往，很佩服这种状态的。知行合一，让自己的行为能够跟上自己的认知，而我现在，或者一直以来的一个很大的问题，就是行为跟不上认知，想得太多，做得太少。</p><p>在初三准备中考的时候，曾经某次跟金鱼闲聊就聊到过，我们很多时候并不是不知道怎样才能学好，怎样才能取得一个好的成绩，学习又有什么难的，每节课认真听课，每晚晚修认真完成作业并按时复习预习，周末回家也保持着完成作业和练习等各种学习任务，学得好自然是顺理成章的。但真的这么简单吗？不是，原因在于我们很多时候都并不能做到这些事情。想起来，计划起来确实简单，但做起来，并坚持做，太难了。</p><p>到了现在，缺少了一些外部环境的约束，以及一些比较紧迫近期的目标推动，自己的行为就更加缺少动力了。想法确实是充满雄心壮志，但是想法最终也只是想法，远远未达到实现的程度。好比最近的我，作业很多，任务很多，也想了一下计划来完成，每天列的 todo 也充满干劲，然而最后每天也并没有完成多少的任务，内心反而充满愧疚与负罪感。</p><p>所以我向往这种知行合一的状态，我也想能够找到方法进入这样的境界，能够让我的行动跟上我的想法。当然，因为弱鸡的行动力，加上其它各种杂事缠身，最终也还是不了了之。不过昨晚看到的这一篇回答，或许就是一个转机？</p><p>所以知行合一到底是什么？文章虽然很长，举了一大堆的例子和背景铺垫，但是核心还是那几样：</p><ul><li>知：当我们遇到某一个特定的状况，情景，问题时会自然而然地出现的感觉，潜意识，认知。</li><li>行：就是我们对于这个特定的状况，情景，问题所做出的（应对）行为</li><li>知行合一：我们遇到特定状况时，会自动根据出现的感觉，做出相应的行为</li></ul><p>所以，实质上，知行合一就是一个<strong>一一对应</strong>的的思维模型，也就是行为规律，遇到什么样的问题，在怎样的情况下，会怎么做。那知怎么来呢？</p><blockquote><p><strong>知不来自于你的意识，而是来自于你上一次对这个媒介做出的行。</strong></p><p>一个人出现在你面前，你一眼看到，一瞬间给你的感觉来自之前，每个人都是，每个人都不一样，都是独一无二的媒介。那这个之前，是哪一次呢？刚认识？还是哪次出去玩的时候？可是生物本能来说，一瞬间的事儿，哪可能给你选啊，这不是你用意识能选的东西。只能来自上一次。可能是上次他的行为给你留下的印象，也可能是上次他出现在你脑海里你对他的想法，总之是来自上次，不是上上次，也不是上上上次，只能是上一次。这一瞬间的感觉，决定了你对他的态度。 这次用这种方式做一件事，下次你还是首先想起来用这种方式。做过的事情再做觉得很简单，没做过的就觉得很复杂不想去做。因为做过的，在你的脑子里有对应的知了，每一步下意识就能完成。</p><p>因此，我们可以通过对问题做出不同的行为，来修正我们此前的知，来不断替换已有的知。 通过不断的替代，一个人给你的印象，也会随之变来变去。假如你通过靠谱渠道听说了一个之前和蔼的亲戚原来是个凶险的逃犯，你下次面对他，还觉得他是那个和蔼的人吗？不要说你因为害怕会装作不知道，我说的是你心里对他的感觉。</p></blockquote><p>总结下来，所谓的知行合一，关键点还是在知，<strong>这里的知，是所谓的感觉，是一种出离于意识，与思维无关的感觉，这样的感觉，会决定个人的想法和行为。</strong>而感觉又会被不同的行所积累，修正，甚至是替换。 我们能够做些什么来好好贯彻知行合一，或者说利用好知行合一呢？翻了翻文章本身的评论，并结合我所理解的文章本身，大概可以有几个方向：</p><ul><li>多尝试不同的行。尽可能多地尝试不同方向，不同领域的事情，通过一些活动或行为，积累自己在各个方面的感觉/经验，让自己能够在不经意间积累到将来可能会用到的知。</li><li>只有行，才能改变个人的知，才能取代以往的可能有瑕疵的知。所以我在培养习惯，或者指定计划的时候，最重要的还是首先让自己开始起来，让自己进入状态，进入计划。就像早起，即使在脑海中再怎样强调自己早起的各种好处，强迫自己一定要早起，但该起不来还是起不来，该不想起还是会不想起。还不如直接就通过一些别的手段，让自己强制起来，在意识到好像早起其实也没有那么难/早起好像还挺爽的。</li><li><p>良知很重要。正确的感觉很重要，所以我们应该尽可能地在最开始的时候就选择正确的行为，培养正确的感觉</p><blockquote><p>一些错误的“行”，会导致自身不合适的“知”，近而导致自身出现不合适的潜意识，所以我们在平时的时候，也要注意慎独，如果一件事情是不合适的，那么我们从一开始就不要做，可能我们会觉得一次两次没什么大不了的，但是会影响一个人的以后对此事物的看法，从而千里之堤溃于蚁穴，最终出现严重的后果。</p></blockquote></li></ul><p>在写本文的时候多次回看他人的回答和评论，越看越觉得自己的认识实在浅薄。确实需要多花点时间再好好探索一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天无意中看到了一个关于王阳明心学的回答，谈到了其中心学的精髓是什么，觉得挺有意思，就在晚上的时候重新认真地翻了翻这个问题，并且将其中的高赞回答摘录到了印象笔记中细细品味： &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://www.zhihu.com/question/28052564/answer/1282463260&quot;&gt;王阳明的心学精髓是什么? - 知乎&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;，也算是有点收获，对于一直以来都觉得非常神奇，也非常向往的陆王心学有了更深的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="心学" scheme="http://scottyeung.top/tags/%E5%BF%83%E5%AD%A6/"/>
    
      <category term="知行合一" scheme="http://scottyeung.top/tags/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>总是感觉自己很忙</title>
    <link href="http://scottyeung.top/2020/looks-so-busy/"/>
    <id>http://scottyeung.top/2020/looks-so-busy/</id>
    <published>2020-09-26T13:00:00.000Z</published>
    <updated>2020-10-10T10:57:51.168Z</updated>
    
    <content type="html"><![CDATA[<p>自从上了大学之后，总是感觉自己莫名地很忙，但你要说真的有很多事情做吗？也不是，起码就不是那种忙到说基本没有空闲时间的那种程度。然而还是感觉很忙，感觉会没有空闲时间，去做一些其它的事情，因此选择了避开很多的活动与交际，即使是这样，也仅仅是维持在时间勉强够用的程度。</p><a id="more"></a><p>最近的一次报告任务就是这样的情况：上两周布置的任务，看五篇论文，然后做个 ppt 来讲一讲论文的内容。时间给的很充足，老师也没有 push. 按理说我应该能够早早地完成阅读任务，从容地准备好论文报告的 ppt 和内容。但最终我却需要奋战到最后一刻：直到今天下午作报告，我中午吃饭前都还在改 ppt。虽说最终报告也还算顺利，但是自我感觉还是挺恐怖的，恐怖的点不在报告本身，而是在完成任务的过程。原本时间很宽裕的任务，随着 ddl 的逼近反而越来越赶，情绪上也是日益焦虑，时不时就会担心好像事情太多要完成不了。</p><p>为什么会出现这种情况？在前几天因某个午睡后的赖床产生的愧疚情绪下，分析了一下原因，尝试解答一下为什么自己越做事越感到时间不够用，会感到越来越忙。然后就发现自己当前状态的一个现象：</p><p>如果我有 10 分的时间，完成工作需要 6 分的时间，所以我会觉得在接到任务时觉得时间很宽裕，剩下的 4 分时间可以随意安排在其它地方，比如运动，比如社交，比如娱乐，还可以将多余的时间作为后备，以防突发情况的出现。但实际上，当我在完成这个工作的时候，虽然我只需要 6 分的时间就能够完成，但是我在开始工作之前，或者工作之间的休息时间，总会拖延，或者是干一些不太相关的杂事，总是会花费一些额外的时间。因为完成工作所需要的 6 分时间，一般来说都是比较大块的时间，会选择分开成在一周的几天来完成，那这些拖延，便随之分布在各个小的工作时间之前或之后，聚少成多。完成工作只需要 6 分，但是全部拖延的时间，浪费的时间，加起来就可能有 2 分了。也就是说，完成这个任务实质上用了 8 分的时间。</p><p>因为工作用到了 8 分的时间，变相就挤压了原本存在的空闲时间，所以随着工作的推进，原本存在的空闲时间越来越少，自然就感觉越来越忙了。然后因为剩下的时间少了，对于完成不了的焦虑就更加多了。对于这些空闲时间，也不敢随便使用了，有什么活动不敢参加，有什么事情也不敢尝试，甚至某些人际交往，我也会可免则免，尽量避免。所以会给到别人一种很忙的感觉，自己也会这样觉得，我真的很忙，我没时间干别的事情了。</p><p>这样的状态对于我还是影响很大的，日常焦虑，日常担心，害怕事情不能按照预期正常完成。因为害怕，所以总会有意无意地拒绝了很多可能的发生，因此也错过了不少的机会，在竞赛上，科研上，交往上。对于我的本科生活，常常会感到遗憾，遗憾没有取得更多的成果，遗憾日子过得过于平淡，尽管我也是甘于平淡的人，也并不会对这样的生活觉得枯燥厌倦，但是如果我不那么的“忙”，是不是就会有着更多的可能呢？</p><p>尽管因为拖延这种习惯，让我一直都有一种很是忙碌的感觉，但在大四保研之后，可用的时间一下子大增，尽管还是拖延，需要 6 分时间的任务还是会拖到要用 8 分来完成，总是整体可用的时间却从 10 分变成了 20 分，于是好好地体验了一把时间充足的空闲状态是怎样的。在保研后的一年中，因为所谓变“闲”的状态，我也做出了不少的改变和尝试：</p><ul><li>加入了一些群并大量的水群（顺带练习出了朋友圈和动态等各种评论技能</li><li>通过群参加了一些线下的活动并认识到了新的朋友</li><li>大量的约饭并维系感情（尽管约来约去都还是固定那些人</li><li>与一些以前很要好的朋友重新建立并保持着联系</li><li>。。。</li></ul><p>现在研究生开学，又重新变回到忙的状态，可用时间又回到了 10 分的状态，而任务时间则可能已经不止 6 分了。开学第三个星期，已经出现了 3 proposal 作业以及一个 reading and report 的作业了。能怎么办呢？一方面拖拉的问题需要改改，提高自己做事的效率，更快地完成任务，另一方面也需要开源一下时间了，怎样从原本利用不了的地方，发掘出更多的可用时间，也是一门学问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从上了大学之后，总是感觉自己莫名地很忙，但你要说真的有很多事情做吗？也不是，起码就不是那种忙到说基本没有空闲时间的那种程度。然而还是感觉很忙，感觉会没有空闲时间，去做一些其它的事情，因此选择了避开很多的活动与交际，即使是这样，也仅仅是维持在时间勉强够用的程度。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="时间管理" scheme="http://scottyeung.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>notes on How to Read a Paper</title>
    <link href="http://scottyeung.top/2020/how-to-read-a-paper/"/>
    <id>http://scottyeung.top/2020/how-to-read-a-paper/</id>
    <published>2020-09-19T10:48:53.000Z</published>
    <updated>2020-09-19T12:18:03.351Z</updated>
    
    <content type="html"><![CDATA[<p>在本周的某门研究导引课上，被推荐了一篇讲述如何读 paper 的 <span class="exturl"><a class="exturl__link" href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf">paper</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>. 一直以来，其实我都觉得科研（research）明明是一个 skill, 但是一直都没有过方法或者课程的教授，也没有一个好的学习过程和机会。基本都是老师布置任务方向，交代看些什么 papers, 完成什么任务，就这样靠着所谓的做中学，靠着所谓的骚扰师兄师姐，大家就能突然领悟，就能够上手很好地完成科研工作，掌握科研的方法和技能。<del>而领悟不到的，就只能够解释为自己不适合科研而遗憾退场，或者当一颗科研的螺丝钉来苟活着。</del> 当然其实基本所有的事情，都有着其自身的方法论，都能够找到相关的系统的训练（maybe</p><p>回到正题，这篇 paper 主要讲了怎样读一篇 paper，以及如何判断读到什么程度和该不该读。</p><a id="more"></a>        <h2 id="why-reading-papers">          <a href="#why-reading-papers" class="heading-link"><i class="fas fa-link"></i></a>Why reading papers?</h2>      <ul><li>reviewing papers for a conference or a class</li><li>keep current in our fields</li><li>doing survey for exploring a new field</li></ul>        <h2 id="three-pass-approach">          <a href="#three-pass-approach" class="heading-link"><i class="fas fa-link"></i></a>Three-Pass Approach</h2>      <p>本文最主要还是提出了一个分成三个阶段阅读的方法。第一阶段的阅读获取文章的大体 idea, 第二阶段的阅读获取文章的主要内容，第三个阶段则深入了解文章，获取各种 details。</p>        <h3 id="the-first-pass">          <a href="#the-first-pass" class="heading-link"><i class="fas fa-link"></i></a>The First Pass</h3>      <blockquote><p>a quick scan to get a bird’s-eye view of the paper</p></blockquote><p>第一阶段的阅读快速浏览 paper, 大概以五到十分钟的时间，了解它的大体想讲什么，从而决定后续要不要继续阅读。主要通过以下部分获取信息：</p><ol type="1"><li>仔细阅读文章的 title, sub-title, abstract 和 introduction</li><li>阅读各个章节的标题（仅标题</li><li>跳到最后仔细阅读 conclusion 部分</li><li>扫一下 references, 看看有无熟悉/看过的</li></ol><p>通过第一阶段的略读，应该能够回答以下的问题：</p><ul><li>文章的类别：本文是什么类型的文章？measurement paper, analysis of systems, description of prototype</li><li>Context: 文章属于什么领域？与什么方向相关？</li><li>正确性</li><li>contribution</li><li>写得怎么样（从行文的角度来看</li></ul><p>如果出现以下情况，就可以选择 stop 不看了:（如果不是被安排了必须完成的任务</p><ol type="1"><li>不感兴趣</li><li>没有相关的前提知识无法理解</li><li>文章存在问题</li></ol>        <h3 id="the-second-pass">          <a href="#the-second-pass" class="heading-link"><i class="fas fa-link"></i></a>The Second Pass</h3>      <p>第二阶段的阅读可以花上一个小时，对文字的主要内容作一个更加详细的了解，找到 paper 中的关键点。可以通过仔细浏览文章给出的图表入手，通过浏览图表的内容，找出它所表现的数据特征，它 support 的内容或结论，来发掘文章的关键点。</p><p>完成第二阶段的阅读后，应该能够把握到文章的内容，并且能够向他人进行本篇文章的 summarize. 如果所阅读的文章不是当前所研究方向的内容，仅是感兴趣的话，到这一阶段则可以结束阅读了。</p><p>如果结束第二阶段后还没理解一篇文章，则可能是：</p><ul><li>对该领域不熟悉，不了解这方向的名词概念</li><li>证明或实验技巧不理解</li><li>写得不行影响阅读理解</li></ul><p>对于这些情况，我们可以：不看了；读点背景材料再来看；直接跳到第三阶段</p>        <h3 id="the-third-pass">          <a href="#the-third-pass" class="heading-link"><i class="fas fa-link"></i></a>The Third Pass</h3>      <p>第三阶段则是通过解构重构的方法来读文章，通过由读者来在脑海中重新实现 paper 的方法来进行：基于作者提出的一些 assumptions，我们会怎样来写这篇文章，怎样来展示里面的工作。通过这样的方法，我们自然会对文章中的 assumptions 有着更深的了解，也自然地会去 challenge 它们。当我们自行 virtual re-implementing 之后，再与文章进行比对，查看一致与不一致的地方</p><blockquote><p>At the end of this pass, you should be able to reconstruct the entire structure of the paper from memory, as well as be able to identify its strong and weak points</p></blockquote>        <h2 id="如何综述-survey">          <a href="#如何综述-survey" class="heading-link"><i class="fas fa-link"></i></a>如何综述 / survey</h2>      <p>当我们想要了解某个领域某个小的方向时，如果能够搜到 survey 自然是最好的，但有时找不到，可以通过从相关文章中的 related works 里面去找。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本周的某门研究导引课上，被推荐了一篇讲述如何读 paper 的 &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;http://ccr.sigcomm.org/online/files/p83-keshavA.pdf&quot;&gt;paper&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;. 一直以来，其实我都觉得科研（research）明明是一个 skill, 但是一直都没有过方法或者课程的教授，也没有一个好的学习过程和机会。基本都是老师布置任务方向，交代看些什么 papers, 完成什么任务，就这样靠着所谓的做中学，靠着所谓的骚扰师兄师姐，大家就能突然领悟，就能够上手很好地完成科研工作，掌握科研的方法和技能。&lt;del&gt;而领悟不到的，就只能够解释为自己不适合科研而遗憾退场，或者当一颗科研的螺丝钉来苟活着。&lt;/del&gt; 当然其实基本所有的事情，都有着其自身的方法论，都能够找到相关的系统的训练（maybe&lt;/p&gt;
&lt;p&gt;回到正题，这篇 paper 主要讲了怎样读一篇 paper，以及如何判断读到什么程度和该不该读。&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://scottyeung.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="科研" scheme="http://scottyeung.top/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="reading" scheme="http://scottyeung.top/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>生活记录杂谈</title>
    <link href="http://scottyeung.top/2020/record-of-life/"/>
    <id>http://scottyeung.top/2020/record-of-life/</id>
    <published>2020-08-30T15:31:25.000Z</published>
    <updated>2020-08-30T15:33:02.238Z</updated>
    
    <content type="html"><![CDATA[<p>到达南京之后，基本上每个晚上都是比较早地就回到酒店，洗澡之后就瘫坐在床上看手机，看视频，很颓废，也很无趣，有一种在消磨时间，等待下一天到来的感觉，像是在浪费自己的人生。</p><a id="more"></a><p>大概是在上了大学之后，我开始变得可以接受无意义地度过某段时间，等待这一段过程的结束。以前的我明明是一个很害怕无聊的人，让我去亲戚家一个下午，即使有电脑可看，有游戏可玩，也有亲友的陪伴，我还是接受不能，感觉在浪费时间，浪费一个美好的假期。现在的我，即使是在乘坐高铁时提早了两个多小时，我也能够安然等待，在完成每周的组会报告之后，也能够心安理得地颓废一两天，美其名曰给自己放一个假。这些都是以前的自己不敢想象的。</p><p>刚刚手机刷到一个同学的同学的个人公众号推送，记录她的每周日常生活，很有意思，并不是说她的日常生活有多么精彩，多么的有意思，主要感觉是她很会抓住这种生活中的一个个有意思/有趣味的瞬间，配上简单的配图与文字，就已经让人有一种身临其境的重现。真的让人有一种是在生活的感觉。</p><p>反观我自己，如果问我近来过得怎么样，都在干些什么，我多半说不出些什么，只能简单地回一个还好，没啥，让我觉得自己真的仿佛在浑浑噩噩地过日子。我不禁反思，到底是我日子没有过好，还是我没有记录好生活中的各种美好，值得记录回忆的事情。大概率两者都有，而这两个方向都需要我继续努力，尝试找寻更多的生活乐趣。</p><p>原本只是因为看到了别人的推送，想简单地记录下这几天的状况，但刚开了个头，思绪就被拉到对于过去无趣生活的愧疚，于是又写了点看似很有道理的反思文字。</p><p>希望能够改进现状。</p><p>希望希望能够实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到达南京之后，基本上每个晚上都是比较早地就回到酒店，洗澡之后就瘫坐在床上看手机，看视频，很颓废，也很无趣，有一种在消磨时间，等待下一天到来的感觉，像是在浪费自己的人生。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="生活" scheme="http://scottyeung.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>C# 爽点记录-1</title>
    <link href="http://scottyeung.top/2020/csharp-merit-1/"/>
    <id>http://scottyeung.top/2020/csharp-merit-1/</id>
    <published>2020-07-30T03:11:06.000Z</published>
    <updated>2020-07-30T03:41:17.833Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。</p><a id="more"></a><p>使用的场景为，需要对数组里面的不同元素分别进行计数，如：</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;bat&quot;</span>,<span class="string">&quot;rat&quot;</span>,<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;rat&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> count = CountEle(arr);</span><br><span class="line"><span class="comment">// should return</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;cat&quot;: 3,</span></span><br><span class="line"><span class="comment">//   &quot;bat&quot;: 1,</span></span><br><span class="line"><span class="comment">//   &quot;rat&quot;: 2,</span></span><br><span class="line"><span class="comment">//   &quot;dog&quot;: 1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></div></figure><p>最为常规的方法当然就是遍历计数了 <figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> word <span class="keyword">in</span> arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(result.ContainsKey(word)) result[word]++;</span><br><span class="line">      <span class="keyword">else</span> result.Add(word,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p><p>这样的方法简单直接，但是我对于在遍历时里面还要对于是否包含元素进行一次判断，要多写一个判断，多写一个语句感到不爽，就想着搜搜有没改进的办法，像是在 Python 里面，就可以通过 setdefault 或者 get 方法来避免键值还不存在的情况。</p><p>然后发现了 Linq 的方法，起飞。Linq 的方法思路大概就是将可遍历的元素用 Sql 的方法来处理，还是挺爽挺直观的。</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groups = arr.GroupBy(s =&gt; s)</span><br><span class="line">      .Select(s =&gt; <span class="keyword">new</span> &#123;</span><br><span class="line">        Word =&gt; s.Key,</span><br><span class="line">        Count =&gt; s.Count()</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups.ToDictionary(s=&gt;s.Word,s=&gt;s.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>最后送上一个 Python 版本更加 tricky 的方法。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountEle = <span class="keyword">lambda</span> arr: &#123;i:arr.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(arr)&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C#" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="Linq" scheme="http://scottyeung.top/tags/Linq/"/>
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>稳定性与新特性</title>
    <link href="http://scottyeung.top/2020/stability-and-features/"/>
    <id>http://scottyeung.top/2020/stability-and-features/</id>
    <published>2020-07-19T02:39:31.000Z</published>
    <updated>2020-07-19T08:04:26.029Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。</p><a id="more"></a><p>以前的我，一直都不喜欢更新软件，无论是手机还是电脑。新手机拿到，第一时间就是关闭应用商店里面的自动更新，即使更新提示里面的数字到达了 99+，也完全不为所动，除非是当前版本的软件不能用了，或者是新出的版本出了一些大家都在用的现象级的新特性，我才会跟上。当时的我对于更新的印象，还是非常刻板的，觉得：</p><ul><li>更新会占硬盘 / 存储空间</li><li>更新后更吃性能导致卡顿</li><li>更新带来的新特性新功能没有多大的用途</li><li>更新带来的新交互方式设计让自己不习惯</li></ul><p>当然现在回想起来，其实这些印象还是挺可笑的，前两条现象确实存在，不过最主要还是局限于当时的手机硬件配置以及软件设计实现上面，而后两者其实还是为前面所找的理由，没有多大用途 != 没有用途，而新的交互方式设计，不深入体验过也难以获得最为真实的体验，习惯之后，可能会觉得更好。现在手机的配置上来了，我会隔一段时间就自觉地打开应用商店，批量选取软件进行更新，以往觉得会不习惯，没什么用的新特性，现在往往是我所寻找的新体验。包括电脑也是，准时更新系统以及各种软件，想要获取最好最新的体验。甚至我还想着加入 Windows Insider，想着提前试用新特性，获取新体验。</p><img src="/2020/stability-and-features/200719.png"><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">尽管加入了 Windows Insider，但是设备不支持也升级不了（好像有特定设备的 bug</center><p>新特性新体验很美好，但随之而来的，还有各种各样的小问题。新的版本没有经过足够多的使用和测试，很可能就有一些莫名其妙的小问题，稳定性不够好。这也是预料之中，早早体验新版本新功能，本身也是当作一个 beta 版来测试，但是某些时候，我们真的能够接受这些稳定性不足带来的问题吗？或者说，能够接受用多少的稳定性来换取新特性呢？</p><p>新的 Windows 2004，带来了新的开始界面 UI，WSL2 以及其它的新特性，对我来说虽说不是刚需，但还是挺想体验一下的，官方通知在 5 月底的时候正式推送，但是因为设备兼容的原因，直到 7 月中还没有收到升级通知。于是就萌生出加 Windows Insider 的想法，想着加入预览版本应该能够收到升级通知，能够自动升级，当然结果就如上图，最终没有成功，我也干脆就关了 Windows Insider。</p><p>没能成功更新的原因似乎是<span class="exturl"><a class="exturl__link" href="https://support.microsoft.com/zh-cn/help/4568129/issue-with-some-storage-spaces-configurations-after-updating-to-window">磁盘管理相关问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，某些设备上面分区可能会被错误识别，可能会导致数据丢失，暂时还没好的解决方法。这个 issue 是 7 月份才提出来的，之后才禁止相关的设备更新。换而言之，如果早点加入了预览版本，在该 issue 提出之前升级到了对应版本，可能我的设备就遇上了这个问题，我的数据也可能会丢失。作为当前的主力机，出问题丢数据几乎是不能接受的事情，即使有 OneDrive 做了一些最基础的备份。</p><p>想到此内心其实是有一些后怕，也是因为这个问题，我才开始对于稳定性与新特性的权衡有了一点不一样的理解。新特性固然是好，但也仅仅是好，不是必须要的，而为了追求这些可以没有的新特性而把稳定性破坏了，搞出问题影响到基本的使用，就非常难受了，尤其是当前基本所有的工作都在我的唯一主力机上进行，它出了问题就等于我出问题了 <span class="github-emoji" data-alias="cry" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></p><p>所以还是稳一点好，电脑关掉了预览版重新等待漫长的更新推送，手机上 MIUI 的开发版也回刷回去稳定版了，而软件上面的更新还是会及时去更新升级，毕竟软件挂了出问题可以删了重来，系统出问题可能就直接把数据都搞挂了（尤其是之前我还为了囤空间把分区只剩下一个 C 盘了）。</p><p>仅以此文来对自己做一个提醒，以后要时刻考虑稳定性的问题。<del>本文开始时间太久了很多想法都不清楚了<span class="github-emoji" data-alias="joy" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="软件" scheme="http://scottyeung.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>不同系统环境下的换行符</title>
    <link href="http://scottyeung.top/2020/%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
    <id>http://scottyeung.top/2020/不同系统环境下的换行符/</id>
    <published>2020-06-18T08:11:46.000Z</published>
    <updated>2020-07-16T16:28:17.518Z</updated>
    
    <content type="html"><![CDATA[<p>这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。</p><a id="more"></a>        <h2 id="换行符">          <a href="#换行符" class="heading-link"><i class="fas fa-link"></i></a>换行符</h2>      <p>一般会使用转义字符作为换行字符，包括 <code>\n \r \r\n</code>。</p><p>在不同的操作系统的文件系统中，会使用不同的字符作为换行符：</p><ul><li>Linux：<code>\n</code> LF(Line Feed)</li><li>Mac OS：<code>\r</code> CR(carriage return)</li><li>Windows: <code>\r\n</code> CR/LF</li></ul><p>当然这些对于换行符识别的差异主要还是出现文件系统对于文件的识别当中，实际的 coding 过程中一般都还是全部使用 <code>\n</code> 作为字符串当中的换行符。</p>        <h2 id="踩坑">          <a href="#踩坑" class="heading-link"><i class="fas fa-link"></i></a>踩坑</h2>      <p>记录一下因为换行符不同所踩的坑。</p>        <h3 id="javascript-油猴脚本解析">          <a href="#javascript-油猴脚本解析" class="heading-link"><i class="fas fa-link"></i></a>JavaScript 油猴脚本解析</h3>      <p>因为比较经常使用 Google Translate 翻译所看的文档，有挺多的复制待翻译内容到网页端上进行翻译的使用场景，但是 PDF 文档复制时会被换行符也一并复制，所以粘贴的时候原本成句的内容会被分成几段，当作几句话来处理，内容很可能不正确，需要手动删除。一两次还好，次数多了就很麻烦，于是写了一个油猴脚本，捕获 Google Translate 中的粘贴内容，把想要粘贴的内容去除换行符。</p><p>想法很简单，就在输入框元素中监听 paste 事件，当出现 paste 事件时，获取粘贴的内容，阻断粘贴的操作，并把输入框的值改为去除换行符后的粘贴内容。</p><p>第一次尝试没有效果，就在代码里面添加一些 log，来进行 debug，从控制台的输出看到脚本是可以捕获到要粘贴的内容，然后去除换行符后的输出内容也是正常的，但是这个去除换行符后的内容重新复制并粘贴到控制台输入时，却仍然会有换行现象。如果是在控制台中获取元素，用同样的语句移除换行符的话，功能也是正常的。</p><p>最终发现问题就在换行符上面，我从 pdf 中复制的文字中，换行符为 <code>\r\n</code>，而我去除换行符的操作为 <code>replace('\n',' ')</code>。当我去除了 <code>\n</code> 之后，网页端的解析还是当有换行符，在控制台的输入上面也还是有换行的作用，最终把去除换行符的语句改为 <code>replace(/(\r\n|\r|\n)/g, ' ')</code>，套了个正则匹配所有类型的换行符，问题解决。</p>        <h3 id="cmakelist">          <a href="#cmakelist" class="heading-link"><i class="fas fa-link"></i></a>CMakeList</h3>      <p>打算使用 LLVM 在 GitHub 中的代码仓库拉下来的源代码进行构建，在使用 CMake 的时候出现问题，提示问题在 <code>cmake/config.guess</code> 文件中，但是又完全没有说是什么问题，而且它提示的行号基本全是空行。搜了一下，发现这个问题出现得还挺多，不过别人的提示信息更多，提示是字符 <code>\r</code> 出问题，说的大概就是换行符不一致，给的方法是将文件的换行符转成 unix 的换行符即可。</p><p>下了一个工具 <code>dos2unix</code> 可以直接将文本文件的换行符转成 unix下的换行符，转换之后，cmake 就可正常运行，生成构建文件了。（尽管直到现在过了我都还没有成功 build 好 llvm 及其配套工具。）</p>        <h3 id="git">          <a href="#git" class="heading-link"><i class="fas fa-link"></i></a>Git</h3>      <p>这个是之前遇到的问题了，在 Windows 系统下通过 Git 提交的文件，在使用 WSL 打开时，会提示每一个文件都有修改。在本地中同样的 repo，同样的历史记录，当前状态显示不一样。</p><p>这个可以通过设置 <code>core.autocrlf</code> 来解决，打开了这个选项之后，在提交时会把所有的 CR/LF 换行符转成 LF 换行符，在 checkout 代码时又会把文件中的 LF 换行符转成 CR/LF。本质就是统一在提交记录里使用 LF 作为换行符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
  </entry>
  
  <entry>
    <title>用于外链的资源库构建</title>
    <link href="http://scottyeung.top/2020/%E7%94%A8%E4%BA%8E%E5%A4%96%E9%93%BE%E7%9A%84%E8%B5%84%E6%BA%90%E5%BA%93%E6%9E%84%E5%BB%BA/"/>
    <id>http://scottyeung.top/2020/用于外链的资源库构建/</id>
    <published>2020-05-30T14:37:11.000Z</published>
    <updated>2020-12-04T12:46:42.552Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>考虑到可访问性和访问速度，最终还是选择部署在 Gitee Pages 上面。</p></blockquote>        <h2 id="background">          <a href="#background" class="heading-link"><i class="fas fa-link"></i></a>Background</h2>      <p>在升级本博客的 hexo 和主题之前，是曾经搞过一个用 Aplayer 实现的外链播放器的，但因为当时播放过程会被在博客中的页面跳转而刷新页面，导致播放被打断而暂停，体验较差，所以在升级主题版本之后一直没有添加回来。在之后的某次逛 Github 的时候，偶然发现 PJAX 可以实现博客内页面跳转使用 AJAX 不刷新页面。于是又再次把 Aplayer 添加回来。</p><p>有了播放器，最重要的还是要有音乐，有歌曲。原本想着简单地从网上那些外链播放搜索网站，搜索抓取从各大音乐平台的外链，确实能找到，当时也能用，不过好像一般都会有有效期，过了一天就不能用了。为此，参考别人在 GitHub 开启 Repo 作为图床的想法，我也打算在 GitHub 开个 Repo 来存放图片或音频资源，提供外链。</p><a id="more"></a>        <h2 id="methods">          <a href="#methods" class="heading-link"><i class="fas fa-link"></i></a>Methods</h2>              <h3 id="gtihub-repo">          <a href="#gtihub-repo" class="heading-link"><i class="fas fa-link"></i></a>GtiHub Repo</h3>      <p>想法比较简单，在 GitHub 上面开一个公共的 Repo，通过其单个文件下载的链接作为外链使用。</p><p>以创建的 <span class="exturl"><a class="exturl__link" href="https://github.com/yeung66/resources">yeung66/resources</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 仓库为例，我在 music 文件下面的音乐文件，其下载链接为 <code>https://raw.githubusercontent.com/yeung66/resources/master/music/恋爱为何物.mp3</code>，其映射关系还是很直接很简单的。当场生成放到博客测试一下，也能够正常使用，没有什么问题。</p><p>然而过了一会儿我在手机上访问时，就发现播放器出现异常，歌曲无法正常播放，在手机上直接访问了一下音乐的外链，无法访问。上网一看才发现，<strong>域名 <code>raw.githubusercontent.com</code> 被 DNS 污染了</strong>，没有梯子的话不能正常访问，而我在电脑上一直挂着梯子，而且这个网址也在我的 PAC 上面（好像还是我手动添加的），而手机非需要使用时都不会开代理工具。考虑到我的多数访客并不会挂着梯子进来，只能放弃这个方法。</p>        <h3 id="gitee-repo">          <a href="#gitee-repo" class="heading-link"><i class="fas fa-link"></i></a>Gitee Repo</h3>      <p>既然 GitHub 的资源域名被墙了，那就考虑使用国内的替代品 Gitee 码云。思路也还是一样的，来一个公共 Repo，通过文件的下载链接作为外链使用，大概映射关系为 music 文件夹下的 a.mp3 的下载链接为 <code>https://gitee.com/yeungyeah/resources/raw/master/music/a.mp3</code>。放到博客的播放器中可用，似乎没有问题。</p><p>然而今天手机打开测试又再次播放失败了，在电脑上换了电脑测试访问，发现原因居然是<strong>访问的资源大小超过 1M 时需要登录</strong>，所以使用外链播放时，如果没有登录过的话，会不断重定向到登录链接，然后就一直失败，真的小气。（我专门到 GitHub 上面试了一下，不需要登录也可）。之前我在上去创建仓库的时候，登陆过，所以测试时一起正常。</p>        <h3 id="github-coding-pages">          <a href="#github-coding-pages" class="heading-link"><i class="fas fa-link"></i></a>GitHub / Coding Pages</h3>      <p>突发奇想，虽然 GitHub 中 Repo 的文件直接下载链接被 DNS 污染了，但是它提供的 GitHub Pages 是可以正常访问的，而其中的静态文件也是能够直接访问的，那干脆就直接将他们当成 Pages 发布，这样就可以直接使用了，音乐文件甚至能够直接链接打开播放（直接通过 Github Repo 的文件下载链接是可以下载但是不能在线播放的）。在 GitHub 开启了 Pages 测试一下，能访问，但速度实在感人，播一秒卡两秒。</p><p>然后想到了现在博客正在托管的 Coding.net 平台（自换域名之后我将所有的解析到解到这里了，国内访问速度满分，但好像 Google AdSense 访问不到了），打开速度非常满意。 <del>于是，我将我的资源 Repo 传到了 Coding.net 平台，开启 Pages 服务，提供资源外链使用。这两者还可以绑定域名，我就顺手绑了个二级域名，爽得直接起飞。</del> Coding 这个垃圾平台总是反复纵跳，相关的规则变来变去，现在又重新搭上了腾讯云，直接把之前所有部署的 Pages 给停了，而且没给任何的提醒。现在在 Coding 里面使用 Pages，需要使用腾讯云的 Severless 服务实现，而且还是给代金券的方式吸引你过去，之后估计还要收费，有点被恶心到了，果断弃用。</p>        <h3 id="gitee-pages">          <a href="#gitee-pages" class="heading-link"><i class="fas fa-link"></i></a>Gitee Pages</h3>      <p>在 Coding Pages 挂了之后，只能重新回到 Gitee Pages 的怀抱，虽然 Gitee Pages 免费版不能自行绑定域名，但是它的访问速度和上传速度还是很香的。唯一的麻烦点是，免费版的 Gitee Pages 居然不能够自动更新 Pages 页面，每次 push 之后都需要上网页去手动点更新按钮，比较蠢。</p><p>然后找了一些自动化的方法，主要原理还是通过模拟登录 Gitee 来发送更新请求。一开始找了个用 puppeteer 的 js 脚本，直接是搞了个模拟浏览器登录之后发送模拟点击事件，但这个 package 怎么都下不完（需要下一个 chromium 的驱动，走镜像或者走代理都很慢）。然后又找了个使用 Github Actions 的<span class="exturl"><a class="exturl__link" href="https://github.com/yanglbme/gitee-pages-action">方法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，先提交到 Github repo，然后触发 action 在 Gitee 里把原 repo 拉过去，在更新 Pages。昨晚搞了一会儿，把 mirror 的部分用在本地 push 两个 remote 替代了，算是能够实现功能了。但是每次 push 到两个 remote 端，感觉有点浪费，尤其是上传到 Github 的速度属实不给力，走代理也不过百来 kb 每秒。</p><p>然后今天早上起来，突然醒悟过来，为啥要用 Github Actions 呢？我直接把他执行的脚本拿到本地，然后在部署的时候在 powershell 脚本里面调用一下不是更方便吗？这样就避免了向 Github 进行无谓的 push，而且账号密码还能存在本地，不需要传到 Github 的secrets 里面。最终的<span class="exturl"><a class="exturl__link" href="https://gitee.com/yeungyeah/resources/blob/master/scripts/gitee-pages.py">脚本</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>读一个本地的 json 来获取数据，进行自动的更新 Gitee Pages。这样还避免了 Github Actions 登陆地为美国的异地登录的问题（当然我在本地跑的脚本也提示异地登录）。</p><p>暂时体验完美。（2020.10.18）</p>        <h2 id="thinking">          <a href="#thinking" class="heading-link"><i class="fas fa-link"></i></a>Thinking</h2>      <p>自说自话一下。</p><p>其实感觉原本是个很简单的问题，但断断续续搞了差不多三四个晚上应该有，最主要的原因还是考虑得不够细致，测试得不够细致，导致总有些问题没有考虑到，疏忽了。过个一天才发现问题，才重新找原因，想解决方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;考虑到可访问性和访问速度，最终还是选择部署在 Gitee Pages 上面。&lt;/p&gt;
&lt;/blockquote&gt;

        &lt;h2 id=&quot;background&quot;&gt;
          &lt;a href=&quot;#background&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;Background&lt;/h2&gt;
      
&lt;p&gt;在升级本博客的 hexo 和主题之前，是曾经搞过一个用 Aplayer 实现的外链播放器的，但因为当时播放过程会被在博客中的页面跳转而刷新页面，导致播放被打断而暂停，体验较差，所以在升级主题版本之后一直没有添加回来。在之后的某次逛 Github 的时候，偶然发现 PJAX 可以实现博客内页面跳转使用 AJAX 不刷新页面。于是又再次把 Aplayer 添加回来。&lt;/p&gt;
&lt;p&gt;有了播放器，最重要的还是要有音乐，有歌曲。原本想着简单地从网上那些外链播放搜索网站，搜索抓取从各大音乐平台的外链，确实能找到，当时也能用，不过好像一般都会有有效期，过了一天就不能用了。为此，参考别人在 GitHub 开启 Repo 作为图床的想法，我也打算在 GitHub 开个 Repo 来存放图片或音频资源，提供外链。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.top/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="博客" scheme="http://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>vim 常用命令记录</title>
    <link href="http://scottyeung.top/2020/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>http://scottyeung.top/2020/vim-常用命令记录/</id>
    <published>2020-05-06T15:26:53.000Z</published>
    <updated>2020-09-28T08:37:12.224Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习想学很久（或者说是说了很久要学的）的 vim 文本编辑器。虽然说接触了很久，好像从大一开始接触 Linux 系统就不得不与其打交道，但是对于其了解程度一直都处在 &quot;存活期&quot;。所以终于想要进一步学习，进入感觉良好期，甚至是更快更好更强的阶段。于是记录一下一些有用的命令，顺便练一下手，没错本篇博客就是用 vim 写的（完全就是瞎折腾，还发现了不少我觉得是 bug 的问题）。</p><a id="more"></a>        <h2 id="学习阶段">          <a href="#学习阶段" class="heading-link"><i class="fas fa-link"></i></a>学习阶段</h2>              <h3 id="能用">          <a href="#能用" class="heading-link"><i class="fas fa-link"></i></a>能用</h3>      <p>所谓的存活期，就是能用，知道怎么编辑，怎么保存。（<del>好像这种地步就已经领先一大批人了，当然我也停滞在这里很久了</del>) 基本上我们只要知道，怎样编辑，怎样保存，就可以用它来作为能用的文本编辑器了。包括下面的内容</p><ul><li>模式<ul><li>Normal 模式：用于执行命令或者跳转。文件需要在该模式进行保存。</li><li>Insert 模式：进行文本输入。按 i 进入，按 Esc 退出到 Normal 模式。</li></ul></li><li>命令<ul><li><code>i</code>: 在 Normal 模式下进行 Insert 模式</li><li><code>x</code>：在 Normal 模式删除光标所在字符</li><li><code>:wq</code>: 保存退出</li><li><code>dd</code>: 删除当前行，并将内容保存到剪贴板</li><li><code>p</code>：将剪贴板内容粘贴出来</li><li><code>hjkl</code>：在 Normal 模式下左下上右d移动光标（也可以使用方向键）</li></ul></li></ul>        <h3 id="好用">          <a href="#好用" class="heading-link"><i class="fas fa-link"></i></a>好用</h3>      <p>能用之后就可以通过学习一下好用且常用的快捷键来提高使用快感和效率。</p><ul><li>插入模式<ul><li><code>a</code> : 光标后插入字符</li><li><code>o</code> ：光标下一行插入空行</li><li><code>O</code> ：光标上一行插入空行</li><li><code>cw</code> ：光标后至行末的字符被替换成空白</li></ul></li><li>光标跳转<ul><li><code>0</code> ：行首</li><li><code>^</code> ：行首第一个非空字符</li><li><code>$</code> ：行末</li><li><code>g_</code>：行末第一个非空字符</li><li><code>/pattern</code> ：搜索 pattern，支持正则表达式，n 可以到下一个</li><li><code>nG</code> ：跳转到第 n 行</li><li><code>G</code> ：跳转到最后一行</li></ul></li><li><code>yy</code> ：复制当前行内容</li><li><code>u</code> ：撤回操作</li><li><code>ctrl + b / ctrl + f</code>: 上一页/下一页</li><li>复制粘贴多行<ul><li>将光标移动到要复制的文本开始的地方，按 v 进入可视模式</li><li>将光标移动到要复制的文本的结束的地方，按y复制。 此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。</li><li>移动光标到文本结束的地方，按 p 粘贴。</li></ul></li></ul><p>暂时先稳固在这一个阶段，基本都够熟悉很久了。</p>        <h2 id="配置">          <a href="#配置" class="heading-link"><i class="fas fa-link"></i></a>配置</h2>      <p>在 Windows 上面的配置文件位于 $HOME_vimrc</p><ul><li>设置行号： <code>set number</code></li><li>vim-plug：vim 的插件管理系统</li></ul><p>enable and append configs</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">syntax on</span><br><span class="line">set background&#x3D;dark</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">set showmatch          &quot; Show matching brackets.</span><br><span class="line">set ignorecase         &quot; Do case insensitive matching</span><br><span class="line">set smartcase          &quot; Do smart case matching</span><br><span class="line">set incsearch          &quot; Incremental search</span><br><span class="line">set hidden             &quot; Hide buffers when they are abandoned</span><br><span class="line"></span><br><span class="line">set number &quot; 显示行号</span><br><span class="line">set cursorline &quot; 突出显示当前行</span><br><span class="line">set tabstop&#x3D;4</span><br><span class="line"></span><br><span class="line">set smartindent &quot; 开启新行时使用智能自动缩进</span><br><span class="line">set backspace&#x3D;indent,eol,start &quot; 不设定在插入状态无法用退格键和 Delete 键删除回车符</span><br><span class="line">set cmdheight&#x3D;1 &quot; 设定命令行的行数为 1</span><br></pre></td></tr></table></div></figure>        <h2 id="issues-on-powershell">          <a href="#issues-on-powershell" class="heading-link"><i class="fas fa-link"></i></a>Issues on Powershell</h2>      <p>在 Powershell 里面使用 vim 总是会有一些奇奇怪怪的问题。</p>        <h3 id="编辑">          <a href="#编辑" class="heading-link"><i class="fas fa-link"></i></a>编辑</h3>      <ul><li>退格键（Backspace）和删除键（Delete）偶尔失灵。常见于删除换行符的时候，尤其是删除空行。空行还可以使用命令 <code>dd</code> 来删除当前行。但是如果是删除之间两行的换行符使两行合并成一行时，就很尴尬。找到的解决方法是在配置文件中添加下面的退格设置，暂时问题不再出现。 <figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">set backspace&#x3D;2</span><br></pre></td></tr></table></div></figure></li><li>在中文输入的时候，键盘上的某些字符输入无效，需要切成英文输出才能输入。如符号`，中文的引号和双引号。暂时还不知道怎么解决，使用英文符号凑合一下 <span class="github-emoji" data-alias="joy" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></li><li>中文输入的时候莫名会多打一些字母出来。</li></ul>        <h3 id="git-的提交问题">          <a href="#git-的提交问题" class="heading-link"><i class="fas fa-link"></i></a>Git 的提交问题</h3>      <p>因为是 Windows 系统，我使用的是 Git on Bash, 它是内置了一个 MINGW 的类 Unix 终端，里面也自带了 vim。当我们设置 Git 的提交编辑器为 vim 时，它会默认打开内部自带的 vim，而不是在 Windows 系统安装的 vim。本来这也没什么，但是它似乎是还扫描到了我在 Windows 系统上面的 vim 的配置文件，这就出问题了。我在 Windows 上面的 vim 安装了 vim-plug 插件管理，安装方式是直接下载配置脚本到目录下的 autoload 目录中，而 Git Bash 自带的 vim 没有这个文件，自然无法识别配置文件中的插件配置项，导致每次调用都会出错。大概的提示就是说载入配置文件的时候在插件配置那里出错了。</p><p>问题其实可以转化为：如何将 Git Bash 里面使用的 vim 换成本地 Windows 系统上面的 vim。搜索看了很多网页，看到的方法基本都不可行，包括：</p><ul><li>设置 alias 让 vim 指向 Windows 系统的 vim <code>alias vim &quot;/c/Program\ Files \(x86\)/vim/vim82/vim.exe&quot;</code> （这里路径的空格和括号都需要转义）。这样在 Git Bash 命令行调用 vim 确实调用到了 Win 上面的 vim，但 git commit 还是调用回自身的 vim</li><li>设置 git config 里面的编辑器选项。默认使用 vim 的话编辑器设置是直接设成了 vim，但有人说可以设成一个路径，指向想要指向的 vim 程序。尝试后连 vim 都打不开了，添加一些选项也无果。</li><li>环境变量中设置 EDITOR 变量。</li></ul><p>最终我选择的方法是移除了 Git Bash 里面的 vim 程序（其所在路径为 <code>/usr/bin/vim.exe</code>），然后添加一个软连接 <code>ln -s '/path/to/your/vim' /usr/bin/vim</code>。因为在 Git Bash 里面调用的 vim 实际上是在调用 <code>/usr/bin/vim</code> ，而这个路径时间上映射到了 Git 安装路径中的 <code>/usr/bin/vim.exe</code> 。我通过移除原有的 vim 程序，建立新的软链接调用目标的 vim 程序，问题解决。在 Git Bash 中调用 vim 和在 git commit 开启编辑器都能成功开启 Windows 的 vim 程序而没有出错。但是有一个小问题，就是原生提供的 Git Bash 开启不了 vim，提示不是 Cygwin 能运行的版本，不过我现在都是在 Windows Terminal 上面使用，而 Windows Terminal 上面使用没有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习想学很久（或者说是说了很久要学的）的 vim 文本编辑器。虽然说接触了很久，好像从大一开始接触 Linux 系统就不得不与其打交道，但是对于其了解程度一直都处在 &amp;quot;存活期&amp;quot;。所以终于想要进一步学习，进入感觉良好期，甚至是更快更好更强的阶段。于是记录一下一些有用的命令，顺便练一下手，没错本篇博客就是用 vim 写的（完全就是瞎折腾，还发现了不少我觉得是 bug 的问题）。&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
      <category term="vim" scheme="http://scottyeung.top/tags/vim/"/>
    
      <category term="工具" scheme="http://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>WSL环境安装配置</title>
    <link href="http://scottyeung.top/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://scottyeung.top/2020/WSL环境安装配置/</id>
    <published>2020-05-04T02:56:45.000Z</published>
    <updated>2020-12-04T12:45:45.093Z</updated>
    
    <content type="html"><![CDATA[<p>早在大三上系统级程序设计课程的时候，就通过老师的演示了解到 Windows 的新产品—— Windows Subsystem for Linux(WSL), 可以在 Windows 系统下运行 Linux 系统的程序或命令。不过当时我的旧电脑上装了 Ubuntu 的双系统，所以一直没有尝试。现在换了新电脑之后，一直没有装回 Linux 系统，一是怕麻烦不太想折腾，二是不太想划分硬盘空间。于是干脆就装一个 WSL 吧，尽管现在还没实际使用 Linux 系统的需要，不过就暂时当一个玩具吧。</p><a id="more"></a>        <h2 id="优点">          <a href="#优点" class="heading-link"><i class="fas fa-link"></i></a>优点</h2>      <p>WSL 还是挺爽的，还没用就感觉优点满满：</p><ol type="1"><li>安装简单。简直是傻瓜式的操作，就在系统设置中开启一下，在商店中搜索下载即可，跟在应用商店下个 app 差别不大，而且 Windows Store 的下载速度惊人，非常快就能装好。另外，也不需要考虑任何的驱动兼容问题，少了很多奇奇怪怪的问题。</li><li>空间友好。我下的 Ubuntu 系统才 200+MB, 相比于普通的带 GUI 的 Linux 操作系统，可谓是不占空间一样。另外最关键的一点是，WSL 系统的所有文件都是放在系统盘中，不需要自己另行划分磁盘空间来放置系统。这个点我觉得太赞了，之前装 Linux 双系统最为麻烦的一点就是要专门划分空间，从原有的磁盘中分出空闲空间来专门服务于 Linux 系统，怎么分，分多少，都需要一番思考和设置。分得多吧又感觉浪费，分得少又会不够，到时加空间比较麻烦。</li><li>协同方便。因为 WSL 系统在 Windows 当中，两系统当中的文件都能够轻易地传输使用。之前的话，Linux确实可以通过挂载的方式访问 Windows 的文件，但反过来却不行，而且操作还有<a href="http://scottyeung.top/2018/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1/">风险</a>。当时有访问跨系统文件的需要时，还需要专门重启一下切换系统，又或者通过网页微信传输文件到手机作为中转。</li></ol>        <h2 id="安装">          <a href="#安装" class="heading-link"><i class="fas fa-link"></i></a>安装</h2>      <p>安装还是挺简单的，只要本机的 Windows 版本支持 WSL功能即可。</p><ol type="1"><li><p>打开“启用或关闭 Windows 功能”，开启适用于 Linux 的 WIndows 子系统。这个可以通过在开始菜单搜索启用（qiyong）的拼音就出现了。<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504120230327.png" alt="image-20200504120230327"></p></li><li><p>打开 Microsoft Store，搜索 WSL 则可以看到支持的所有 Linux 版本。选择其中一个，获取安装即可。安装后可以在开始菜单找到并打开，会自动开启该系统下的 bash 命令行界面。</p></li></ol>        <h2 id="配置">          <a href="#配置" class="heading-link"><i class="fas fa-link"></i></a>配置</h2>      <p>一个完美的开发运行系统，最关键的还是各种的软件或系统的配置，参考了网上的各种各样的文章，主要有下面的方面需要配置。我使用的是 Ubuntu 系统，不同的系统可能配置的具体方式会有出入。</p>        <h3 id="软件源更新">          <a href="#软件源更新" class="heading-link"><i class="fas fa-link"></i></a>软件源更新</h3>      <p>Ubuntu 软件安装/更新源均在国外，下载速度感人，所以可以将所有软件源更换为国内的镜像。这里选择的是阿里云的源。首先将原来的源文件备份，然后更改源文件，将内容换成阿里云的源链接。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list  /etc/apt/sources.list.bak</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></div></figure><p>通过 vim 修改源文件，将文件内容更改为下面内容</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></div></figure><p>保存后更新</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></div></figure>        <h3 id="nodejs">          <a href="#nodejs" class="heading-link"><i class="fas fa-link"></i></a>Nodejs</h3>      <p>安装方法可以参考<span class="exturl"><a class="exturl__link" href="https://www.runoob.com/nodejs/nodejs-install-setup.html">这里</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。Linux 上面有三个方法，一是直接下载编译后的包来使用，下载后建立链接；二是通过下载源代码来编译构建；三则是使用 apt-get 命令直接安装。我当然是选择了最简单的 apt-get 命令安装大法。两行命令搞定。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></div></figure><p>安装后可以通过查看版本号测试是否成功</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v0.10.25</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></div></figure><p>我的 node 的确成功安装并测试，但是 npm 却没有，输入命令时提示如下，似乎是命令调用错误，通过 which 命令查看时发现调用的是在 Windows 系统的 npm，着实奇怪。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">: not foundjs//npm: 3: /mnt/d/nodejs//npm:</span><br><span class="line">: not foundjs//npm: 5: /mnt/d/nodejs//npm:</span><br><span class="line">/mnt/d/nodejs//npm: 6: /mnt/d/nodejs//npm: Syntax error: word unexpected (expecting <span class="string">&quot;in&quot;</span>)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> npm</span><br><span class="line">/mnt/d/nodejs//npm</span><br></pre></td></tr></table></div></figure><p>网上搜索了一下也很多人有类似的问题，GitHub 上面也很多人提了 issue，尝试无果，最终选择换了个方式重新安装，随后解决。</p><ul><li><p><span class="exturl"><a class="exturl__link" href="https://github.com/microsoft/WSL/issues/1512#issuecomment-303517504">GitHub issue</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ：这里提到的方法主要是修改环境变量的顺序，确保先查找 WSL 安装的 npm 先被搜索到，尝试了一下没有用，which 命令测试也没有变化。</p></li><li><p>StackOverflow 上的<span class="exturl"><a class="exturl__link" href="https://stackoverflow.com/questions/45853530/npm-install-error-not-foundram-files-nodejs-npm-3-mnt-c-program-files-nodejs">重装大法</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> ：将旧的移除后，用新建源的方法重新使用 apt-get 来安装。重新安装后测试成功</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove nodejs</span><br><span class="line"></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">sudo apt-get install -y build-essential</span><br></pre></td></tr></table></div></figure></li></ul>        <h3 id="zsh-and-oh-my-zsh">          <a href="#zsh-and-oh-my-zsh" class="heading-link"><i class="fas fa-link"></i></a>zsh and oh-my-zsh</h3>      <p>之前各种的 Linux 系统，无论是服务器还是桌面系统，都是使用自带的 bash，但是大家都说别的 shell 终端更好，于是就干脆试试大家都在推荐的 zsh。</p><ol type="1"><li>可以通过命令<code>cat /etc/shells</code>查看本机是否有 zsh，有的话可以直接跳到 3</li><li>如果没有的话，使用 apt-get 安装即可 <code>sudo apt-get install zsh</code></li><li><code>chsh -s /usr/bin/zsh</code> 通过命令切换到 zsh，重启终端即可</li><li>初次进入 zsh 会提示你需要进行配置文件的创建与配置，我们这里使用 oh-my-zsh 来提供配置</li></ol><p>获取 oh-my-zsh 的方法则比较简单，通过 curl 或者 wget 的方式获取 shell 脚本后执行即可。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure><p>但这里我怎么也搞不下来，两种方式都不能建立链接，获取不到这个脚本，自然无法进行后续的安装处理。原因似乎是国内的网络环境因为你懂的原因无法访问这个网址 ，估计走代理的话应该可以解决。所以我采用的方法是在 WIndows 系统下好这个 shell 脚本，然后在 WSL 里面运行，问题解决。之后就可以通过在配置文件 <code>~/.zshrc</code>里面设置主题里，可选的主题及效果可以<span class="exturl"><a class="exturl__link" href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes">点此选择</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。</p><p>我选的是 ys，这里要吐槽一句，不知道为什么网上看到的预览图片，跟我实际使用的效果相差太大了，有些甚至对使用造成了影响，例如主题 agnoster ，显示的实际颜色与下面的样例图出入太大了，在 WSL 里面打开就是目录显示的是深蓝色，深到看不清楚里面的字那种，尽管我挺喜欢这种风格的，但因为影响到实际使用了，只能放弃。</p><p>官方网站以及大多数经验分享文章中的 agnoster 主题效果 <img src="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png"></p><p>这是我用主题 agnoster 的效果图。<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504173113601.png" alt="image-20200504173113601"></p><p>这是我最终选择的主题 ys 的效果<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504173241135.png" alt="image-20200504173241135"></p><hr><p>发现了为啥我的颜色跟网上看到的不一致，原来是需要设置额外的配色，将某些颜色映射为其它色号。我用的是 Windows Terminal，设置配色比较简单，只要在配置文件的 <code>schemes</code> 属性中添加配色主题，再在想要设置配色的终端设置 <code>color-scheme</code> 即可。配色主题可以到这个 <span class="exturl"><a class="exturl__link" href="https://github.com/mbadolato/iTerm2-Color-Schemes#windows-terminal-color-schemes">GitHub repo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 上面挑选。</p><figure class="highlight json"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// powershell 的设置项</span></span><br><span class="line">   <span class="attr">&quot;guid&quot;</span>: <span class="string">&quot;&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Windows PowerShell&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;commandline&quot;</span>: <span class="string">&quot;powershell.exe&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;fontFace&quot;</span>:  <span class="string">&quot;Cascadia Code PL&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;colorScheme&quot;</span>: <span class="string">&quot;OneHalfDark&quot;</span>, <span class="comment">//选择的配色名称</span></span><br><span class="line">   <span class="attr">&quot;hidden&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;  <span class="comment">//使用的配色主题, 有些颜色觉得不太行就注释掉，也可以自行修改</span></span><br><span class="line">   <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;OneHalfDark&quot;</span>,</span><br><span class="line">   <span class="comment">// &quot;black&quot;: &quot;#282c34&quot;,</span></span><br><span class="line">   <span class="attr">&quot;red&quot;</span>: <span class="string">&quot;#e06c75&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;green&quot;</span>: <span class="string">&quot;#98c379&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;yellow&quot;</span>: <span class="string">&quot;#e5c07b&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;blue&quot;</span>: <span class="string">&quot;#61afef&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;purple&quot;</span>: <span class="string">&quot;#c678dd&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;cyan&quot;</span>: <span class="string">&quot;#56b6c2&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;white&quot;</span>: <span class="string">&quot;#dcdfe4&quot;</span>,</span><br><span class="line">   <span class="comment">// &quot;brightBlack&quot;: &quot;#282c34&quot;,</span></span><br><span class="line">   <span class="attr">&quot;brightRed&quot;</span>: <span class="string">&quot;#e06c75&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightGreen&quot;</span>: <span class="string">&quot;#98c379&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightYellow&quot;</span>: <span class="string">&quot;#e5c07b&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightBlue&quot;</span>: <span class="string">&quot;#61afef&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightPurple&quot;</span>: <span class="string">&quot;#c678dd&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightCyan&quot;</span>: <span class="string">&quot;#56b6c2&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;brightWhite&quot;</span>: <span class="string">&quot;#dcdfe4&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;background&quot;</span>: <span class="string">&quot;#282c34&quot;</span>,</span><br><span class="line">   <span class="attr">&quot;foreground&quot;</span>: <span class="string">&quot;#dcdfe4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="oh-my-zsh插件">          <a href="#oh-my-zsh插件" class="heading-link"><i class="fas fa-link"></i></a>oh-my-zsh插件</h4>      <p>自带的插件只需要在配置文件中添加即可，我这里添加了：</p><ul><li>z：路径自动推测跳转 <code>z dir</code></li><li>extract：解压所有类型文件 <code>x file</code></li><li>git：简化了 git 的常用命令</li><li>npm：npm 命令的自动补全</li></ul><p>额外下载的插件则需要下载源代码到 <code>$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins</code>目录下面</p><ul><li>zsh-syntax-highlighting：自动语法高亮</li><li>zsh-autosuggestions：自动补全建议</li><li>git-open：打开 git remote</li></ul>        <h3 id="代理">          <a href="#代理" class="heading-link"><i class="fas fa-link"></i></a>代理</h3>              <h4 id="simple">          <a href="#simple" class="heading-link"><i class="fas fa-link"></i></a>Simple</h4>      <p>因为我国的独特网络环境，在访问某些网站的时候速度比较感人，有些时候甚至还不能访问，因而需要一些比较科学的方法来访问互联网，这里设置的代理，本质还是让网络请求通过本机（Windows 系统）的工具进行网络请求。在 zsh 的配置脚本<code>~/.zshrc</code>中添加下面别名即可，里面的端口和协议根据自己的工具具体设置。设置后添加别名 proxy 开启，通过 unproxy 关闭。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">&#x27;export http_proxy=socks5://127.0.0.1:1080; export https_proxy=socks5://127.0.0.1:1080&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">&#x27;unset http_proxy; unset https_proxy&#x27;</span></span><br></pre></td></tr></table></div></figure><p>添加后通过<code>source  ~/.zshrc</code>激活，输入 proxy 后即可打开某些不可访问的网站测试一下。</p>        <h4 id="zsh-proxy">          <a href="#zsh-proxy" class="heading-link"><i class="fas fa-link"></i></a>zsh-proxy</h4>      <p>在实际使用中发现，上面这样的简单的方式在某些地方虽然可行，但是有些地方在实际使用上面却会有问题，例如我在使用 wget 获取网络资源时会提示 socks5 识别不了，说是 wget 并不支持 socks 协议。另外，一些需要频繁访问网络的命令，如 git，npm 等似乎有着自己独特的代理设置方式。没办法，一个 wget 就逼着不得不改变。搜了几个方法之后，最终选择了一个 zsh 插件<span class="exturl"><a class="exturl__link" href="https://github.com/SukkaW/zsh-proxy">zsh-proxy</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>来实现代理功能。</p><p>使用方法很简单</p><ol type="1"><li><p>将插件脚本 clone 到本地</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/sukkaw/zsh-proxy.git ~/.oh-my-zsh/custom/plugins/zsh-proxy</span><br></pre></td></tr></table></div></figure></li><li><p>在配置文件<code>~/.zshrc</code>的插件项中添加插件 zsh-proxy</p></li><li><p>激活配置文件</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></div></figure></li><li>通过命令<code>init_proxy</code>进行初始化配置，按照提示输入自己的 http 代理和 socks5 代理即可</li><li>配置完成后通过命令操作即可<ul><li>proxy: 开启</li><li>noproxy: 关闭</li><li>myip: 查看代理的 ip</li></ul></li></ol><hr><p>走代理的速度还是挺爽的，我用 wget 下载 Miniconda，虽然才 80 多兆，但不走代理才 30-40Kb 每秒，开启代理每秒 3M 多，半分钟不到就下完。</p>        <h3 id="python">          <a href="#python" class="heading-link"><i class="fas fa-link"></i></a>Python</h3>      <p>以前的人都说，Python 在 Linux 环境不需要折腾这么多官方，而我在 Windows 下面进行 Python 项目的开发也确实或多或少地遇到一些小问题，尤其是 package 的安装和管理，使用 pip 的时候莫名其妙地就失败。不过这些问题在开始的时候折腾过后一般就不再发生，尤其是我使用 conda 进行包管理之后，基本很少发生。</p><p>除了可能有奇奇怪怪的的错误之外，使用 Linux 系统开发的好处就是能够接近实际的部署生产环境。因为现在使用的服务器大多都是使用 Linux系统，在相似的环境下开发，部署起来更加方便。</p><p>我也试过跑到 Linux 下面进行 Python 的软件开发，有着 Pycharm 的支持，开发效率也还不错。不过主要的问题是，非开发工具的效率和便利性确实不行。<del>就像是简单地从别人那接收一个 QQ 发过来的文件，我需要从手机 QQ 中接收保存下来，再通过微信发送给在 Linux 系统中登录的网页微信。一两次都还好，经常这样的话简直灾难，尤其是某些应用的网页端 app 简直是残废。</del>有些沟通交互实在麻烦，而且开发过程中的休息与娱乐也比较困难，使我难以坚持下来。</p><p>WSL 似乎就能完美解决这个问题（当然确实云服务器也可以，但就我能负担的云服务器的硬件配置加网络，可能性能还不如虚拟机），双系统完美交互。确实可以考虑把一些 Python 项目的开发和运行丢到这里。</p><p>说了一堆废话，下面看看安装。机器本身就自带 Python2 和 Python3，不过我现在比较偏向于使用 conda 作包管理和虚拟环境管理，就打算重新下一个 Anoconda。不过完整的 Anoconda 体积庞大，包含了很多不必要的科学计算库，这里选的是 Miniconda。安装也是傻瓜式。</p><ol type="1"><li><p>获取安装脚本。建议开启代理，不然速度感人，又或者你在 WIndows 系统下好再在 WSL 里面执行也可以</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></div></figure></li><li><p>赋予执行权限。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 Miniconda3-latest-Linux-x86_64.sh <span class="comment"># 直接全给权限了</span></span><br></pre></td></tr></table></div></figure></li><li><p>执行安装脚本。安装过程中会出现若干的配置提示信息，包括安装路径等。</p><figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></div></figure></li><li><p>添加环境变量。将<code>export PATH=/home/YOURNAME/miniconda3/bin/conda:$PATH</code> 放到你的 bash 配置文件中。我放到了 zsh 的配置文件 <code>~/.zshrc</code>中。添加后重新启动，或者激活配置文件即可</p></li></ol>        <h3 id="待填坑">          <a href="#待填坑" class="heading-link"><i class="fas fa-link"></i></a>待填坑</h3>      <ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Python。<del>Ubuntu18 自带了 Python2 和 Python3。我已经不再使用 Python2 了，而 Python2 把 Python和 pip 的命令默认调用都占用了，考虑移除 Python2，或者搞一个 Anoconda 来做环境管理。</del></li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> C/C++ 环境​。<del>想好好学习一下 C++，之前因为 Windows 环境的原因，不得不装了个巨占空间的 Visual Studio，然后到现在还没写过一行 C++ 代码。有点想把它删了，在这里搞个 LLVM/clang 编译器。</del></li></ul>        <h2 id="命令与快捷键">          <a href="#命令与快捷键" class="heading-link"><i class="fas fa-link"></i></a>命令与快捷键</h2>      <p>记录一下一些较为常用和实用的命令和快捷键这里</p>        <h3 id="命令">          <a href="#命令" class="heading-link"><i class="fas fa-link"></i></a>命令</h3>      <ul><li><code>x file</code>：解压任意类型文件（需要添加 extract 插件</li><li><code>z dir</code>：根据给出的目录进行跳转<ul><li>不一定是完整的，可能只是最后一级</li><li>效果感觉一般，感觉需要吃历史记录的，很多新目录访问都完成不了</li><li>看了一些分析，说是要经过过往的 cd 跳转来获取经验的</li></ul></li></ul>        <h3 id="快捷键">          <a href="#快捷键" class="heading-link"><i class="fas fa-link"></i></a>快捷键</h3>      <p>好像是仅适用于 zsh</p><ul><li>ctrl + u：清空当前行命令</li><li>ctrl + a：跳到行首</li><li>ctrl + e：跳到行尾</li><li>ctrl + k：删除光标到行尾内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在大三上系统级程序设计课程的时候，就通过老师的演示了解到 Windows 的新产品—— Windows Subsystem for Linux(WSL), 可以在 Windows 系统下运行 Linux 系统的程序或命令。不过当时我的旧电脑上装了 Ubuntu 的双系统，所以一直没有尝试。现在换了新电脑之后，一直没有装回 Linux 系统，一是怕麻烦不太想折腾，二是不太想划分硬盘空间。于是干脆就装一个 WSL 吧，尽管现在还没实际使用 Linux 系统的需要，不过就暂时当一个玩具吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Ubuntu" scheme="http://scottyeung.top/tags/Ubuntu/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="WSL" scheme="http://scottyeung.top/tags/WSL/"/>
    
  </entry>
  
  <entry>
    <title>突然不想再记录时间的使用</title>
    <link href="http://scottyeung.top/2020/%E7%AA%81%E7%84%B6%E4%B8%8D%E6%83%B3%E5%86%8D%E8%AE%B0%E5%BD%95%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://scottyeung.top/2020/突然不想再记录时间的使用/</id>
    <published>2020-05-03T03:55:30.000Z</published>
    <updated>2020-07-16T16:28:17.818Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，都有着记录自己日常时间的使用情况，可能是因为很喜欢回顾这些历史数据，回望过去的事情。通过简单的记录，已经留下了不少珍贵的记录数据。</p><a id="more"></a><p>最早在高三的时候，我就会用一个小本子，在每天晚自习开始之前写上今晚想要完成的任务，开始时写上开始的时间，结束时打上一个勾并写上完成时间，通过这种简单的方式，来记录自己的学习时间分布和任务完成情况。</p><p>上了大学之后，时间变得充足了许多，人也有时会悠闲起来，对于时间的使用就没那么敏感了，所以一度没有记录时间的使用情况，只是通过手机中的便签，来记录需要完成的任务以及它们的完成状况。在大一大二时，尚有着较多课程和活动的约束，很多需要完成的任务和事情，自然而然地就会被它们的 ddl 推动着，只要记下了某个任务，而该任务确实是需要完成的，自然会去完成。</p><p>到了大三下学期，课变少了，空闲的时间更多了，人也懒散了下来，对于时间的把控似乎有点糟糕。主要原因是，当时没有一个具体而迫近的任务来推动自己。当时的打算是提早做好保研夏令营的准备，提前准备材料和复习专业课知识。然而这些任务普遍不够明确和具体，准备什么材料，复习什么内容，复习到什么程度，都很难把握。尤其是复习，有些专业课的内容比较多，时间跨度自然容易长，时间一长效率就低。为了更好地推动自己，我使用了 Forest 来进行时间记录。一方面是为了让自己学习或工作能够持续一定的时间不被中断，另一方面，则是为了记录自己在学习上的时间使用，通过每日学习时间的数据反馈来推动自己。</p><p>在使用了 Forest 进行时间记录之后，就会发现，其实自己并没有多么的努力，看似学习了一天，非常充实，实际的学习时间却只有三四个小时。虽然说上午下午甚至晚上都有在学习，但实际情况却可能是，睡到九点多才起床，吃完早餐后要差不多十点多才能开始学习，学一个多小时就要结束，去吃午饭并午休。下午睡到两点多才醒，三点多才在图书馆找到位置开始学习，学个一个多小时就五点多，要去吃晚饭了。吃完晚饭回宿舍休息，状态好的话或许能够再战一小时，状态不好的话，就直接开始娱乐了。要注意到，这里说的学习一小时，并不是说你去学习，从坐下开始到结束起来离开的时间有一小时，而是真真切切的学习一个小时，中途的任何休息，包括打水去厕所看手机，都会中断而不计时。所以数据很真实：去了一个上午，两个多小时，实际学了可能 100 分钟不到。这样的时间管理确确实实地使我明白到自己其实并没有做多少事情，对于自身的能力有一个更加真实的判断，这样的反馈或多或少地推动了我更加努力地前进。</p><p>除了让时间记录的数据推动自己以外，这样的记录还有的珍贵价值，就是可以让自己回顾过去的努力和付出。尽管有些时候工作的时间并不如自己的预期，但是还是有一些值得回味的记录的。例如在准备保研和实训的六月份，每天基本保持长达 300 分钟以上的高强度工作，还有在准备软工期末考试前夕的学习了 600 分钟的一天，都是珍贵的回忆。</p><p>在 Forest 上面种了差不多一年的树，记录了 50000+ 的专注时间，真实的树苗也在上面种了一棵。说实话，这样的数据是很能给到人触动的，尤其是回过头来重温当时的某段努力的时光，看着图上树木繁多的森林，总能够给人一种自身努力过的痕迹。</p><p>然而，在三月中的时候，可能是因为疫情原因导致时间上更加空闲的缘故，我似乎有更多的时间和精力来记录时间，收集更好看的数据，原有的 Forest 只有一个简单的类别标签，没有办法记录该段时间做了什么具体内容。另外，Forest 无法记录回过去忘记记录的时间，也是让我有点不满。刚好在某个推送上面看到了有时间管理工具的介绍，就转而使用 Toggl 进行时间记录。</p><p>Toggl 的时间记录方式比较自由，也比较专业，毕竟 Forest 始终都是一个帮助人专注的工具，在单纯的时间记录上面，Toggl 远胜于 Forest。Toggl 可以使用计时模式，也可以手动输入时间数据，对于过往的数据，也能够很容易地就修改。另一方面，每一条时间记录，可以添加 Project 和若干个 tag，便于进行聚类统计分析。</p><p>虽然工具很好，但是在用了一个来月之后，我却不想再用了。就在这两天，有一种不再想记录时间使用情况的想法。时间记录得太细，太过频繁，太过复杂，越令我萌生出一种很不耐烦，很功利的感觉。尤其是这几天在做的数据分类的工作，尽管我感觉只是在做无聊而重复的无意义的工作，但是，为了记录下时间的使用，让时间的使用显得更有价值，我还是记录了下来，美其名曰科研数据处理，甚至连几分钟的空闲间隙时间也不放过，一天能够记上差不多十条的记录。我觉得很没意思。</p><p>另外，还有一件很可怕的事情是，这样子记录时间，有点助长自己对于时间利用的功利性，事事都想记录下来，证明自己是有做事情的，是没有浪费时间的。但我们的人生真的可能时时刻刻都被妥善利用在所谓的有意义的事情上面吗？可能有这样的人，但个性闲散的我并不是这样的人。因为发现记录下来的时间并不满足自己的预期，心里受到了落差与打击，时常都会出现自己不过如此的感觉。为了抵消这种错觉，我便变得将日常所做的所有事情的一一记录，甚至夸大了从事某些事情的时间，以营造出我很努力的感觉，来抵消自己的愧疚。事实上，这样只会让自己错误地判断自己的工作和学习状况，对所能完成的任务和事情的预期产生错误的判断，当某些目标完成得不如预期时，又或者某天的记录回归正常时，就会产生出自身能力在现实和设想的落差，进而导致不自信和愧疚。</p><p>尽管如此，我还是忍受不了这种诱人的历史数据的引诱，在写这篇文章的时候，我都还是用回了 Forest 进行时间记录。不过为了进一步减少这样功利感，还是使用回这样的比较简单的工具好一点，起码这样我就不能够修改我的时间记录，而产生虚伪的结果。另外，对于一些小的碎片时间，也不应该太过执着于记录，毕竟<strong>时间的本质是为了我们的使用而服务，而不是为了被我们记录</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，都有着记录自己日常时间的使用情况，可能是因为很喜欢回顾这些历史数据，回望过去的事情。通过简单的记录，已经留下了不少珍贵的记录数据。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="每日千字" scheme="http://scottyeung.top/tags/%E6%AF%8F%E6%97%A5%E5%8D%83%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>shell 脚本入门</title>
    <link href="http://scottyeung.top/2020/shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <id>http://scottyeung.top/2020/shell-脚本入门/</id>
    <published>2020-04-21T13:17:55.000Z</published>
    <updated>2020-12-04T12:44:16.835Z</updated>
    
    <content type="html"><![CDATA[<p>shell 是一个用 C 编写的程序，既是一种命令语言，又是一种程序设计语言，常用于运行自动化执行 Unix/Linux 系统命令的脚本。在最近的数据收集等任务当中，发现其实对于脚本的使用其实有着较大的需求，之前我都是直接用 Python 写脚本来完成，效果也不错，但总感觉总有点杀鸡用牛刀的感觉，而且对于系统命令的执行也比较不方便。写过几个自动化提交代码的 shell 脚本，但还是不太熟悉，于是打算找个教程过一遍 shell 脚本编程，算是入门了。</p><a id="more"></a>        <h1 id="shell">          <a href="#shell" class="heading-link"><i class="fas fa-link"></i></a>shell</h1>              <h2 id="执行">          <a href="#执行" class="heading-link"><i class="fas fa-link"></i></a>执行</h2>      <p>创建 shell 脚本文件，以后缀 .sh 结尾，就可以</p><ul><li>直接通过执行文件的方式执行脚本 <code>./script.sh</code></li><li>通过 sh 命令的方式 <code>sh script.sh</code> 执行</li></ul>        <h2 id="变量">          <a href="#变量" class="heading-link"><i class="fas fa-link"></i></a>变量</h2>      <ul><li>shell 中的变量只有两种，分别为数字和字符串，数组。<br></li><li>shell 变量命名由字母，数字，下划线组成</li><li>通过反引号 ` 可以执行命令，将结果作为返回值赋予变量</li></ul>        <h3 id="操作">          <a href="#操作" class="heading-link"><i class="fas fa-link"></i></a>操作</h3>      <ul><li>赋值<ul><li>变量直接通过 = 号进行 <code>var=125</code></li><li>通过语句赋值，如 for 循环语句 <code>for file in $(ls /etc)</code></li></ul></li><li>只读：通过设置 <code>readonly var</code></li><li>删除：<code>unset var</code></li><li>使用：通过在变量前使用 $ 则可</li><li>字符串拼接：可以通过 字符串变量字符串 的方式进行拼接</li></ul>        <h3 id="字符串">          <a href="#字符串" class="heading-link"><i class="fas fa-link"></i></a>字符串</h3>      <ul><li>单引号：不转义原样输出，变量也无效，可以通过成对出现来拼接</li><li>双引号：可以有变量，可以有转义字符</li><li>可以通过 <code>$#</code> 获取长度</li><li>可以通过 <code>$&#123;var:1:3&#125;</code> 的方式进行切片</li></ul>        <h3 id="数组">          <a href="#数组" class="heading-link"><i class="fas fa-link"></i></a>数组</h3>      <ul><li>由括号括住，元素通过空格分隔 <code>arr=(var1 var2 var3)</code></li><li>通过下标 [] 获取元素</li><li>使用 @ 可以获取所有元素</li><li>通过 # 可以获取数组的长度 <code>&#123;&#123;"$&#123;#arr[@]&#125;"&#125;&#125;</code></li></ul>        <h3 id="通用变量">          <a href="#通用变量" class="heading-link"><i class="fas fa-link"></i></a>通用变量</h3>      <ul><li>命令行参数<ul><li><code>$n</code> 表示第n个参数</li><li><code>$#</code> 参数个数</li><li><code>$*</code> 所有参数以单个字符串的方式返回</li><li><code>$$</code> 当前进程ID</li><li><code>$@</code> 所有参数以字符串的方式逐个返回</li></ul></li></ul>        <h2 id="运算符">          <a href="#运算符" class="heading-link"><i class="fas fa-link"></i></a>运算符</h2>      <p>bash 原生并不支持数学运算，需要通过其它命令来实现，如 expr</p><ul><li>算术运算符<ul><li>加减乘除取余赋值。乘法需要转义 *</li><li>相等与不相等：比较数字</li></ul></li><li>关系运算符<ul><li><code>-eq -ne -gt -lt -ge -le</code> 等于 不等于 大于 小于 大于等于 小于等于</li></ul></li><li>布尔运算符<ul><li><code>! -o -a</code> 取反 或 与</li></ul></li><li>逻辑运算符<ul><li><code>&amp;&amp; ||</code> 与 或</li></ul></li><li>字符串运算符<ul><li><code>= != -z -n $</code> 等于 不等于 长度为0 长度不为0 是否空字符串</li></ul></li><li>文件测试运算符<ul><li><code>-b -c -d -f -p</code> 是否块设备 字符设备 目录 普通文件 管道</li><li><code>-r -w -x -s -e</code> 文件是否可读 可写 可执行 为空 是否存在</li></ul></li></ul>        <h2 id="命令">          <a href="#命令" class="heading-link"><i class="fas fa-link"></i></a>命令</h2>      <ul><li>echo：字符串输出</li><li>read：从标准输入读取一行</li><li>printf：与C的类似，进行格式化输出<ul><li>转义序列：<code>\b \c \n \t</code> 后退 不换行 换行 制表符</li></ul></li><li>test：检查条件是否成立<ul><li><code>test bool-expr</code> = <code>[bool-expr]</code></li></ul></li><li>$[a+b]：执行基本的算数运算，符合两边不能有空格</li></ul>        <h2 id="控制逻辑">          <a href="#控制逻辑" class="heading-link"><i class="fas fa-link"></i></a>控制逻辑</h2>              <h3 id="if">          <a href="#if" class="heading-link"><i class="fas fa-link"></i></a>if</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">elif</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></div></figure>        <h3 id="for">          <a href="#for" class="heading-link"><i class="fas fa-link"></i></a>for</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 item3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></div></figure><p>in后除了可以跟元素序列，还可以接一个返回多个元素的命令</p>        <h3 id="while">          <a href="#while" class="heading-link"><i class="fas fa-link"></i></a>while</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># infinite loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> / <span class="keyword">while</span> :</span><br></pre></td></tr></table></div></figure>        <h3 id="case">          <a href="#case" class="heading-link"><i class="fas fa-link"></i></a>case</h3>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> var <span class="keyword">in</span></span><br><span class="line">    1)</span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line">    2)</span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line">    *) <span class="comment">#其余情况</span></span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></div></figure>        <h3 id="breakcontine">          <a href="#breakcontine" class="heading-link"><i class="fas fa-link"></i></a>break/contine</h3>      <p>跳出循环与跳到下次循环</p>        <h2 id="函数">          <a href="#函数" class="heading-link"><i class="fas fa-link"></i></a>函数</h2>      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    commands</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;使用参数时通过 <span class="variable">$1</span> 调用&quot;</span></span><br><span class="line">    <span class="built_in">return</span> <span class="string">&#x27;也可以没有返回&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用（不需要括号</span></span><br><span class="line">func</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h2 id="重定向">          <a href="#重定向" class="heading-link"><i class="fas fa-link"></i></a>重定向</h2>      <ul><li>command &gt; file 输出重定向</li><li>command &gt;&gt; file 追加方式输出重定向</li></ul>        <h2 id="导入-shell-脚本">          <a href="#导入-shell-脚本" class="heading-link"><i class="fas fa-link"></i></a>导入 shell 脚本</h2>      <p>通过 <code>. filename</code> 或 <code>source filename</code> 的方式导入脚本中的变量或函数</p>        <h1 id="unixlinux-命令">          <a href="#unixlinux-命令" class="heading-link"><i class="fas fa-link"></i></a>Unix/Linux 命令</h1>      <p>shell 脚本最强大的功能，还是在于能在脚本中自动化地使用对于系统命令的调用，而其中主要是 Linux 的命令使用，这些就需要额外的学习了，不在此处展开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell 是一个用 C 编写的程序，既是一种命令语言，又是一种程序设计语言，常用于运行自动化执行 Unix/Linux 系统命令的脚本。在最近的数据收集等任务当中，发现其实对于脚本的使用其实有着较大的需求，之前我都是直接用 Python 写脚本来完成，效果也不错，但总感觉总有点杀鸡用牛刀的感觉，而且对于系统命令的执行也比较不方便。写过几个自动化提交代码的 shell 脚本，但还是不太熟悉，于是打算找个教程过一遍 shell 脚本编程，算是入门了。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>知不可而为 与 为而不有</title>
    <link href="http://scottyeung.top/2020/%E7%9F%A5%E4%B8%8D%E5%8F%AF%E8%80%8C%E4%B8%BA-%E4%B8%8E-%E4%B8%BA%E8%80%8C%E4%B8%8D%E6%9C%89/"/>
    <id>http://scottyeung.top/2020/知不可而为-与-为而不有/</id>
    <published>2020-04-18T03:47:07.000Z</published>
    <updated>2020-07-16T16:28:17.800Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚因为看了实习职位，沉浸于幻想当中太久，导致千字任务最终未能完成。不但如此，上床了之后脑海中仍然不断地想着去实习的事，面试能不能过，能不能被录取，有没有机会去，导师会不会不批准，众多问题萦绕于脑海，挥之不去，睡也睡不着。想得最多的，还是组里会不会不给，或者实习之后老师仍然不时安排科研任务。想了很多，也只能是空想，没有实质的结果。Anyway，有机会还是要试一试，简历也是要投一投的。过去的我错失了很多的机会，就是因为所谓的“自知不可为”，而根本不去尝试一下，所谓的未免浪费时间精力，很多时候也只是害怕面对失败结果的借口而已。</p><a id="more"></a><p>之前看梁启超的散文，其中有一篇说到其处世观，知不可而为，与为而不有。知不可而为，就是即使知道所做的事情可能很难，会没有结果，没有收获，仍然去做，不考虑成败。为而不有，就是做事情不带有目的，并不是为了某些回报才去做某些事情。以上两种做事观念，我都非常欣赏，且非常向往。做事情，就应该不用也不必考虑这么多，难易，成败，得失，只要是我想做的事情，我就去做，不论结果。</p><p>这样的观念境界很是理想，很是美好，同时也很难实现，很难保持。为而不有，前几天就谈到过，如此功利主义的我，对于任何时间的规划，事情的安排，总是按照所谓的重要程度来进行排序。就如学习的优先级，对我来说，就比运动锻炼要高，所以在一早起床后大块的可利用时间内，我会选择坐在桌子前学习工作，而从来不会先运动一下。为有而为，因有而为，就导致了很经常会因不有而不为，从而损失了很多的机会与乐趣。正是这样，让我在大学期间基本没怎么参加一些课外的活动，因为其“无用”，实在可惜。</p><p>而知不可而为，就更加难了。每个人都有畏难的情绪，害怕挫折，害怕失败，所以会选择止步于舒适区当中，选择放弃不可为之事。明知不可为而行动，怕不是浪费时间，所以我们选择了不为，选择了其它事情了来做。现在的我也是这样想的，尤其是功利的我，凡事追求最高效率，最大收益，不可为，完成不了，就等于没有收益，零效率，根本不能接受。</p><p>不能知不可而为，更为可怕的，是这样会经常地自认为自己不可为，不能为，从而束缚了自己。我在大一下学期时，无意中进入了学校的ACM集训群，并激发了我对于搞ACM算法竞赛的兴趣，然而这份热情很快就被自己的“理智分析”打散了：别人都有基础，比不过人家；需要投入大量的时间，可能会影响正常的学习与活动；比赛还要组队，而我一个人都不认识。我找了众多的理由，来告诉自己这是不可行的，我是做不来的。现在回想起来，如果当时没考虑这么多，选择了参与其中，尝试一下，那我如今的生活状态可能就大不一样了，也不是说我参与了可能就可以得到多好的成绩，而是在做这件事的过程中，我会受到许多的影响，从而被推动或改变。</p><p>但这也只是个人的选择，又能怎样呢，毕竟当时选择了知不可而不为的时候，也享受到了闲散带来的悠闲与轻松。不过仍然希望将来能够更好地践行这两个观念，作出改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚因为看了实习职位，沉浸于幻想当中太久，导致千字任务最终未能完成。不但如此，上床了之后脑海中仍然不断地想着去实习的事，面试能不能过，能不能被录取，有没有机会去，导师会不会不批准，众多问题萦绕于脑海，挥之不去，睡也睡不着。想得最多的，还是组里会不会不给，或者实习之后老师仍然不时安排科研任务。想了很多，也只能是空想，没有实质的结果。Anyway，有机会还是要试一试，简历也是要投一投的。过去的我错失了很多的机会，就是因为所谓的“自知不可为”，而根本不去尝试一下，所谓的未免浪费时间精力，很多时候也只是害怕面对失败结果的借口而已。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="每日千字" scheme="http://scottyeung.top/tags/%E6%AF%8F%E6%97%A5%E5%8D%83%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>博客域名迁移</title>
    <link href="http://scottyeung.top/2020/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%BF%81%E7%A7%BB/"/>
    <id>http://scottyeung.top/2020/博客域名迁移/</id>
    <published>2020-03-25T03:56:16.000Z</published>
    <updated>2020-12-11T03:25:42.665Z</updated>
    
    <content type="html"><![CDATA[<p>一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年 72 元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些 cn 后缀的都贵，有点离谱。于是果断选择转换回去最早使用的 top 域名，续费也才25一年，加上首年优惠三年才花了 60 不到。</p><p>另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的 SEO 和 RSS 订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。</p><p>本站现已迁移到域名 <strong><a href="http://scottyeung.top/" class="uri">http://scottyeung.top/</a></strong></p><a id="more"></a>        <h2 id="相关工作">          <a href="#相关工作" class="heading-link"><i class="fas fa-link"></i></a>相关工作</h2>      <p>以下是迁移域名做的一些工作：</p><ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Github Pages 切换解析到新域名<ul><li>域名添加DNS解析，两个 A 记录指向 GitHhub 的 ip 地址，一个 cname 绑在二级域名 www 上指向博客的源地址</li><li>Github Repo 修改 Github Pages 的 Custom domain</li><li>修改 public 文件夹当中的 CNAME 文件的内容为新域名（我已经忘了这个的作用了2333</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Coding.net 添加解析（现在已经基本完全归属到腾讯了）。原本是当作国内百度搜索引擎的专用解析，但因为下面的 Google Search 需要旧网址跳转，遂暂时使用它来提供 Pages 服务。</li><li><p><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> LeanCloud 修改安全域名，添加对新域名的支持。发现可以直接使用过往的阅读量数据和评论数据</p></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Google Analytics： 修改监测网址即可。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> Google Adsense： 添加新网址即可，需要重新进行审核，等待通过中。<ul><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 因为疫情的原因，拒了我两次，原因居然是因为疫情而无法审核</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 两次都说我的网站已经下线或无法访问，上网搜了一下，发现一些人也有这个问题，可能是DNS对于域名国外访问的解析出了问题，建议添加额外的国外线路解析。当时我是使用 coding.net 提供的 pages 服务，好像这个是国内的服务（存疑），全部的解析到转到了那里。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> 第五次审核中。添加了额外的海外线路解析到 Github Pages。海外线路走 Github，国内访问走 coding.net.</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 因为多次审核不通过而被禁止申请一段时间，卒</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 过了禁止时间几天之后，一申请第二天就申上了，然后感觉广告量少了很多，点击就更加了</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Google Search<ul><li>添加新域名并进行所有权验证</li><li>新域名添加站点地图抓取</li><li>尝试将旧网站的索引的 SEO 资源继承到新域名中，Google Search Console 中的确有网站转移的功能，要求旧网址发 301 响应重定向到新网站。可选的方法有：旧域名 DNS 解析中添加显式 URL 跳转，跳转到新域名，但是目标跳转域名需要备案。选择支持绑定多个域名的Pages服务提供商，如coding.net，可以绑定多个域名，然后选择一个首选域名，其它域名跳转到该域名，浏览器调试验证确实可行，但 Google Search Console 不知道为啥通不过，暂时放弃。过了一个多小时又可以了，不过需要一段时间来处理，不知道要多久，然而提示最好保留重定向 180 天，旧域名只剩下一个月，如果不能在一个月之内迁移成功旧白干了。</li><li>最终基本成功迁移，但是搜索的展示量和点击量都有一点下降，不过好像现在已经回归到跟之前差不多水平了</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 百度站长工具：类似于 Google Search，添加新的网址进行所有权认证即可。依然采用主动推送和 sitemap 的方式来提交链接。</li><li><p><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 360站长工具：同上，操作简单，不过连同上周其实没有期望多大的效果。</p></li></ul>        <h2 id="数据损失">          <a href="#数据损失" class="heading-link"><i class="fas fa-link"></i></a>数据损失</h2>      <p>因为转换域名而无法继承的数据造成的损失：</p><ul><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 卜算子站点统计。因为它的统计似乎是以站点网址作为键值来进行统计的，更换后直接重新进行统计。（服务开启得太过简单的后果就是维护性/扩展性的牺牲</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 部分 rss 订阅的损失（虽然本来也没有多少</li></ul>        <h2 id="信息修改">          <a href="#信息修改" class="heading-link"><i class="fas fa-link"></i></a>信息修改</h2>      <p>此处是一些记录下我网址的需要改过来的地方</p><ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> GitHub 上博客的 repo 简介和个人简介</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 中文独立博客 repo 中的博客列表需要修改网址，发PR来改</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> twitter 上面写的个人网址</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年 72 元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些 cn 后缀的都贵，有点离谱。于是果断选择转换回去最早使用的 top 域名，续费也才25一年，加上首年优惠三年才花了 60 不到。&lt;/p&gt;
&lt;p&gt;另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的 SEO 和 RSS 订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。&lt;/p&gt;
&lt;p&gt;本站现已迁移到域名 &lt;strong&gt;&lt;a href=&quot;http://scottyeung.top/&quot; class=&quot;uri&quot;&gt;http://scottyeung.top/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="博客" scheme="http://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python中的并发编程</title>
    <link href="http://scottyeung.top/2020/Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://scottyeung.top/2020/Python中的并发编程/</id>
    <published>2020-03-09T12:51:07.000Z</published>
    <updated>2020-07-16T16:28:17.352Z</updated>
    
    <content type="html"><![CDATA[<p>尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。</p><a id="more"></a><p>以下只考虑Python3的状况。</p>        <h2 id="threading-multiprocessing">          <a href="#threading-multiprocessing" class="heading-link"><i class="fas fa-link"></i></a>Threading / Multiprocessing</h2>      <p>最简单的并发编程形式，莫过于直接开启新的线程或者进程来执行代码。</p><ul><li><code>threading.Thread(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None)</code> 通过调用该方法可以直接创建线程对象，其中target为需要执行的目标函数，args和kwargs为该目标函数的参数，创建后，通过<ul><li>调用start方法以开启线程，进行调度执行target函数</li><li>线程开启调度后，调用<code>join(timeout=None)</code>方法可以阻塞调用线程，等待线程结束或者超时</li><li>使用threading进行多线程编程实现并发的话，仍然受到GIL的限制，但仍可以避免因等待IO完成的阻塞</li></ul></li><li><code>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs=&#123;&#125;, *, daemon=None)</code> 类似于线程的创建，创建进程实现多线程可以避免GIL的限制从而利用到CPU的多个核心，在CPU密集的代码中非常有用。<ul><li>类似于线程的使用，通过start方法开启进程任务调度，调用join方法等待完成</li><li>除此以外，可以调用进程池Pool进行多个任务的调度处理，通过map或者apply方法，开启多个进程处理多个任务</li></ul></li></ul><p>直接创建线程/进程这种方式简单、直接、粗暴，不过大多时候需要自己进行任务的调度，需要自己安排怎样创建进程，怎样完成任务。在之前尝试<span class="exturl"><a class="exturl__link" href="http://scottyeung.club/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/">批量下载漫画</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>的过程中，使用的就是threading方法，就需要自己进行任务的安排，进而安排线程的创建和执行。当时还不知道怎么合理地分配调度任务，就只能将任务分为若干子集，每个子集开启独立的线程来完成下载任务，但是仍然无法避免下载过程中网络访问和文件保存的IO阻塞。另外，线程创建之后就是独立运行的线程，除了等待结束返回之后，无法传输数据进行额外的控制。</p>        <h2 id="concurrent.futures">          <a href="#concurrent.futures" class="heading-link"><i class="fas fa-link"></i></a>concurrent.futures</h2>      <p>它在Python3.2中被引入，提供了高层次的异步可调用对象执行的接口。我们可以通过ThreadPoolExecutor在线程级别上进行异步执行，或者通过ProcessPoolExecutor在不同的进程中实现。两者实现相同的抽象接口类Excutor，因而具有一样的调用方法，便于进行转换。</p>        <h3 id="executor">          <a href="#executor" class="heading-link"><i class="fas fa-link"></i></a>Executor</h3>      <ul><li><code>submit(fn, *args, **kwargs)</code> 提交任务进行调度，返回Future对象</li><li><code>map(func, *iterables, timeout=None, chunksize=1)</code> 类似于map方法，对于iter里面的每一个对象都会异步地调用func，当任务结束时返回各个函数返回结果的迭代器</li></ul>        <h3 id="future">          <a href="#future" class="heading-link"><i class="fas fa-link"></i></a>Future</h3>      <p>在futures里面具体的任务类，由submit方法创建。</p><ul><li>result 获取任务的返回结果，若未结束则阻塞至结束或超时</li><li>cancel 关闭任务</li><li>canceled 是否关闭</li><li>done 是否结束</li></ul>        <h3 id="使用方式">          <a href="#使用方式" class="heading-link"><i class="fas fa-link"></i></a>使用方式</h3>      <ol type="1"><li><p>通过submit提交任务创建获取任务的future对象，再通过as_completed等待future对象结束，获取结果。as_completed接收future对象的迭代器。 <figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(<span class="string">&#x27;%r generated an exception: %s&#x27;</span> % (url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&#x27;%r page is %d bytes&#x27;</span> % (url, <span class="built_in">len</span>(data)))</span><br></pre></td></tr></table></div></figure></p></li><li><p>通过map方法批量执行任务，再获取结果。但是map方法返回结果的顺序与调用顺序即传入的迭代对象的顺序一样，若前面的任务耗时过长会阻塞后面执行快的任务返回。</p></li></ol><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> <span class="built_in">zip</span>(PRIMES, executor.<span class="built_in">map</span>(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">&#x27;%d is prime: %s&#x27;</span> % (number, prime))</span><br></pre></td></tr></table></div></figure>        <h2 id="asyncio">          <a href="#asyncio" class="heading-link"><i class="fas fa-link"></i></a>asyncio</h2>      <p>asyncio采用event loop的事件驱动型的异步调度执行。</p>        <h3 id="coroutine">          <a href="#coroutine" class="heading-link"><i class="fas fa-link"></i></a>coroutine</h3>      <p>coroutine（协程）从定义上来说，指的是包含yield/yield from语句的函数（在Python3.5引入async和await之前）。在此之前，我们可以通过生成器的形式来实现，样例如下。首先可以调用函数获得生成器对象，然后调用next方法或send(None)的方法开启coroutine，开启后，函数执行到yield位置，返回yield右侧的表达式后则挂起自己，将控制流交回给主线程。当再次调用send方法时，可以传输数据并激活协程，继续执行至结束或者下一个yield语句处。该样例则是一个计算累计输入的平均值协程。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># BEGIN CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg = averager()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(coro_avg)  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(10)  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    10.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(30)</span></span><br><span class="line"><span class="string">    20.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(5)</span></span><br><span class="line"><span class="string">    15.0</span></span><br><span class="line"><span class="string"># END CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span>():</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        term = <span class="keyword">yield</span> average  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br></pre></td></tr></table></div></figure><p>当coroutine运行结束时，会抛出一个StopIteration的异常，告知协程结束。若协程函数有返回值，也会被存在StopIteration.value中随着异常返回。如果我们要获得返回值，必须要捕获异常。另外，在使用coroutine的过程中，我们还需要手动调用next方法来开启coroutine。这些不方便之处，使我们通常会使用一个delegating generator来进行中间的调用操作。在delegation generator当中，通过yield from来调用subgenerator，并可以直接获取返回值，且delegating generator可以处理subgenerator抛出的异常。</p>        <h3 id="使用方式-1">          <a href="#使用方式-1" class="heading-link"><i class="fas fa-link"></i></a>使用方式</h3>      <p>asyncio库则是通过协程的方式，引入事件循环（event loop）的方式，通过事件轮询与回调的方式进行异步编程。具体的使用方式通过书中一个具体的例子来说明。这个例子是批量从网上下载不同国家国旗的图片，通过将每一个国家国旗的下载任务封装为一个协程，进行并发编程。在协程中，对于每一个可能会发生阻塞，需要等待的操作，均使用yield from进行调用。当运行到此处时，程序会交出当前的控制权，异步调用并执行coroutine，当运行完返回之后才会将控制权交回给之前的线程。</p><p>当编写完协程函数之后，通过list comprehension批量生成协程对象，通过wait方法开启新的协程，来调用开启所有的任务协程对象。在通过loop.run_until_complete等待所有协程完成。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine  </span><span class="comment"># &lt;3&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span>(<span class="params">cc</span>):</span></span><br><span class="line">    url = <span class="string">&#x27;&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif&#x27;</span>.<span class="built_in">format</span>(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">&#x27;GET&#x27;</span>, url)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span>(<span class="params">cc</span>):</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(cc)  <span class="comment"># &lt;7&gt;</span></span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">&#x27;.gif&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span>(<span class="params">cc_list</span>):</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> <span class="built_in">sorted</span>(cc_list)]  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">    loop.close() <span class="comment"># &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(res)</span><br></pre></td></tr></table></div></figure><p>PS： 1. 可能会出现的阻塞应该全部使用异步调用。因为这里采用的是event loop，其实还是在同一个线程，如果使用了线程阻塞的操作，依然会阻塞其余所有的操作。因而应该使用异步调用的方式，如aiohttp进行http请求，或者asyncio.sleep进行休眠操作，当会发生阻塞的时候，抛出控制权给回event loop 2. 此处调用wait后再调用run_until_complete，需要等到全部协程完成时才会一并返回结果，不利于判断完成情况。可以利用asyncio.as_completed进行代替，可以马上返回以及完成的任务 3. 只有通过loop或async中相关的run方法，任务才会被执行</p>        <h3 id="update">          <a href="#update" class="heading-link"><i class="fas fa-link"></i></a>update</h3>      <p>在Python3.5中，引入了关键字async和await，以及coroutine类型。可以更加清晰地使用asyncio进行并发编程。其中async等价于装饰器<code>@asyncio.coroutine</code>，可以将函数声明为coroutine对象。await关键字则可以取代yield from关键字，进行异步函数的调用。看了看变化还挺大的，尽管核心的思想没变，还是需要重新看看。具体的文档<span class="exturl"><a class="exturl__link" href="https://docs.python.org/3/library/asyncio.html">见此</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>        <h2 id="后记">          <a href="#后记" class="heading-link"><i class="fas fa-link"></i></a>后记</h2>      <p>在学习了Fluent Python中的并发编程之后，突发兴趣打算使用asyncio和concurreny.futures来重写之前的漫画下载任务，来看看实际的效果提升。尽管在看书的过程中，感觉自己掌握得好像还行，对于样例代码也能一看就可以理解，而且目标任务也比较简单，应该可以比较快就实现目标任务。然而实际操作编写代码就发现并不是这么简单。首先，书中的代码有些已经落后（如async和await关键字没有引入），越看文档就越能发现新的features，有些还与书中的样例代码有所出入。其次，现实中代码的实际运行状况远比书中的理想状况复杂。就错误处理而言，一开始并没有做错误处理，导致出错后就静静地挂起，没有提示，也不会结束。后面做了简单的错误处理后发现，异常类型真可谓各式各样。最后，就是书中不能对全部状况状况作出全面的介绍，存在着许多未知的状况。发现很多错误也还好，最怕的是发现不了错误，或者知道有问题但是找不出来，还没有信息。</p><p>coding还是需要多动手实践，从具体的代码编写入手，这样才能真正提高所谓的coding 能力，否则只看书的话，很容易就会陷入一种我都会了的感觉，但这其实只是我都知道的状态，并不代表我都会用，我都能用，我都可以用好。看书更多的是留下一种对某方面知识或技能的印象，当需要的时候能够根据这些印象进行快速的索引和学习，重新获取知识。两者都很重要，缺一不可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次漫画批量的爬取/下载</title>
    <link href="http://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/"/>
    <id>http://scottyeung.top/2020/记一次漫画批量的爬取-下载/</id>
    <published>2020-02-28T14:01:33.000Z</published>
    <updated>2020-10-08T08:32:48.572Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="背景">          <a href="#背景" class="heading-link"><i class="fas fa-link"></i></a>背景</h1>      <p>想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。</p><a id="more"></a>        <h1 id="实现思路">          <a href="#实现思路" class="heading-link"><i class="fas fa-link"></i></a>实现思路</h1>      <p>漫画下载无非就是图片的抓取下载，也算是一种比较简单的爬虫。分析选为抓取来源的网页的URL，发现其URL规律为<code>host/type/漫画的ID+漫画章节号+第几页</code>，可以按照该规律生成所有漫画每一页的URL，则可以根据每一个URL获取里面的漫画图片下载。进一步分析这些页面上漫画图片的URL，发现是跳转到一个ASP页面进行提供，链接为三级ID组成，包括漫画ID，章节号，页码组成。在浏览器直接访问图片的URL，发现会跳转到404页面。根据开发者调试工具的Network栏中拦截的请求，发现图片实则来自另一个URL，并且图片URL的规律十分明显。于是问题就转变成根据规律批量生成图片的URL并下载。</p>        <h1 id="具体实现python">          <a href="#具体实现python" class="heading-link"><i class="fas fa-link"></i></a>具体实现：Python</h1>      <p>为了简单，就没有使用任何的轮子。直接使用 requests 库访问这些 URL 获取图片资源，并写入到本地文件中保存。</p>        <h2 id="v1">          <a href="#v1" class="heading-link"><i class="fas fa-link"></i></a>v1</h2>      <p>具体的实现思路大概如下。对于漫画的每一话，先创建目录，然后根据该话的序号和页面生成目标资源URL，发送GET请求获取资源，通过文件写入保存到本地，直到访问的 URL 不存在漫画图片，跳转到 404 页面，此处我们通过判断响应首部的内容长度是否等于 404 图片的大小来判断该话是否结束爬取。根据漫画的总数，对每一话进行下载。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">&#x27;https://www.xxxxxx.com/1234/1234/&#123;0:0&gt;3d&#125;/&#123;1:0&gt;3d&#125;.jpg&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getChapter</span>(<span class="params">no</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;获取并保存第no话的漫画&#x27;&#x27;&#x27;</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    os.mkdir(saveDir + <span class="built_in">str</span>(no))</span><br><span class="line">    req = requests.get(baseUrl.<span class="built_in">format</span>(no,cnt))</span><br><span class="line">    print(req.status_code, req.headers)</span><br><span class="line">    <span class="keyword">while</span> req.status_code == <span class="number">200</span> <span class="keyword">and</span> req.headers[<span class="string">&#x27;Content-Length&#x27;</span>] != size404:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(saveDir + <span class="built_in">str</span>(no) + <span class="string">&#x27;/&#x27;</span> + <span class="built_in">str</span>(cnt)+<span class="string">&#x27;.jpg&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(req.content)           </span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        req = requests.get(baseUrl.<span class="built_in">format</span>(no,cnt))</span><br><span class="line">    <span class="keyword">return</span> cnt - <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="效果">          <a href="#效果" class="heading-link"><i class="fas fa-link"></i></a>效果</h3>      <p>实在是太慢了！</p><p>尝试着下了一话大概花费半到一分多钟左右，这里总共有一百多话，两个多小时肯定是走不掉了，而且还没考虑网络不稳定的因素。考虑了一下其中效率的制约因素，最主要为：</p><ul><li>网络请求。发请求获取资源需要传输时间。</li><li>IO。图片保存到本地需要写入时间。</li></ul>        <h2 id="v2">          <a href="#v2" class="heading-link"><i class="fas fa-link"></i></a>v2</h2>      <p>考虑使用多线程进行并行下载，进而提高速度。虽说Python提供的多线程只是伪多线程，实际上还是只能有一个线程被核心处理，但应该还是可以减少其中的等待时间。采用 threading.Thread 对象，将下载任务分成若干个 patch 交由不同的线程完成，每个线程完成 20 话的下载任务。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPatch</span>(<span class="params">start,size,max_chapter</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start,<span class="built_in">min</span>(size,max_chapter)+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">&#x27;save chapter &#123;:0&gt;3d&#125; page &#123;:0&gt;3d&#125;&#x27;</span>.<span class="built_in">format</span>(i,getChapter(i)))</span><br><span class="line"></span><br><span class="line">patch = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    t = threading.Thread(target=getPatch,kwargs=&#123;<span class="string">&#x27;start&#x27;</span>:i*patch+<span class="number">1</span>,<span class="string">&#x27;size&#x27;</span>:patch,<span class="string">&#x27;max_chapter&#x27;</span>:<span class="number">136</span>&#125;)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br></pre></td></tr></table></div></figure>        <h3 id="效果-1">          <a href="#效果-1" class="heading-link"><i class="fas fa-link"></i></a>效果</h3>      <p>并没有提升多少速度。感觉这个多线程并没提高多少并行程度，我开了7个线程，但是最开始只创建了4文件夹进行下载，在这4话中进行调度交替下载。也不知道花了多少时间，下完这4话之后，我就强制关掉了，弃掉该方案。</p>        <h1 id="具体实现goland">          <a href="#具体实现goland" class="heading-link"><i class="fas fa-link"></i></a>具体实现：Goland</h1>      <p>说到多线程，最方便的肯定就是Go语言了，直接的关键字支持多线程。于是拾起很久没碰过的 Goland，甚至新电脑上还没安装环境，还需要重新安装 Go语言，配置环境和开发工具，就下 vscode 的插件都花了点功夫。</p><p>实现思路还是同 Python 版本一样，为了简单不使用任何额外的轮子，直接使用 net/http 包进行 http 访问，获取图片，并写入到本地文件。</p>        <h2 id="v3">          <a href="#v3" class="heading-link"><i class="fas fa-link"></i></a>v3</h2>      <p>具体的单话下载代码如下。方法跟 Python 版本的几乎一样，不过 Go 语言做了额外的错误处理，显得有点冗余。</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downChapter</span><span class="params">(no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">page := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ;; page++ &#123;</span><br><span class="line">_, err := os.Stat(fmt.Sprintf(saveDir, no))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(saveDir, no))</span><br><span class="line">os.Mkdir(fmt.Sprintf(saveDir, no), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line">res, err := http.Get(fmt.Sprintf(baseUrl, no, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.Header.Get(<span class="string">&quot;Content-Length&quot;</span>) == size404&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Create(fmt.Sprintf(saveDir, no) + fmt.Sprintf(postfix, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">io.Copy(file, res.Body)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;down chapter %3d with %3d pages\n&quot;</span>,no,page)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>使用 Go 语言最主要就是要用它的多线程特性。在 Go 中只需要在调用函数前加上关键字 Go 就可以开启新的多线程调用函数。将下载任务分成 20 个为一批的多个 patch，开启了 7 个线程进行下载。此处使用 WaitGroup 进行多线程的等待，避免主线程提前结束。</p><figure class="highlight go"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downPatch</span><span class="params">(start, patch, maxChapter <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> no:=start;no&lt;=start+patch &amp;&amp; no&lt;=maxChapter;no++&#123;</span><br><span class="line">downChapter(no)</span><br><span class="line">cnt++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;down patch from %3d to %3d total %d&quot;</span>,start,start+cnt<span class="number">-1</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;maxChapter/patch;i++&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> downPatch(i * patch,patch,maxChapter)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;finish!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="效果-2">          <a href="#效果-2" class="heading-link"><i class="fas fa-link"></i></a>效果</h3>      <p>速度确实提升了，但是感觉没有到很快的程度。。。</p><p>直到写文章的此刻，跑了两个半小时，下了大概 86 话。打开任务管理器看了看情况，CPU 占用率一直很低，磁盘读写占用也很低，感觉瓶颈就在网络传输上面。另外，觉得7个线程也开得有点少了，应该多开一点，榨干电脑的性能，而且开多了也不会有很大的浪费。不过似乎制约速率的瓶颈就这网络传输上面，确实没办法。</p>        <h1 id="思考">          <a href="#思考" class="heading-link"><i class="fas fa-link"></i></a>思考</h1>      <ul><li>对于网络爬虫/下载，最为制约效率的因素始终是网络因素，这个也是我们最不能把握的。可能是服务器端的接入速率因素，可能是服务器端的处理计算速度因素，可能是链路的传输速度因素，还可能是墙的因素，有很多的可能性。</li><li>在程序刚运行的时候，我想到过多的 http 请求会不会把那个站点搞崩。一百多话，每画平均 25 页，接近三千多张图片，需要发三千多个 http 请求，会不会 over 了，不过在当前这个速度下显然是想多了。不过这在以后的爬虫获取数据或者资源的时候确实需要考虑，为他人想想，可以考虑加点间隔时间。</li><li>东西不用了就会忘记，技能确实需要是不是拾起来使使。</li><li>有时候问题并不是在选择的方法或工具上面，可能只是简单的自己做错了/做得不够，或者当时的环境不行。</li></ul>        <h1 id="后记">          <a href="#后记" class="heading-link"><i class="fas fa-link"></i></a>后记</h1>      <p>最终因为电脑在休眠的时候自动更新，强行重启了，最终还是没下完，大概下了120话，花了4个半小时，远远超出我的预期。大概原因为</p><ul><li>线程设置有误。原本想设置7个线程，但没考虑到 Go 里面除法取整，少了一个线程，最后一个 patch 的任务没有执行，实际是六线程运行。</li><li>代码存在一些不合理的地方，造成了操作上的重复。如判断在每一话当中判断文件夹是否存在，我把他放到了循环当中，每下载一页的图片前都会判断；还有设置 patch 的时候没有考虑开闭区间，且下载的时候没有判断文件是否已经下载，导致首尾的漫画重复下载。</li><li>后期漫画的图片质量上去了，由前面的一百几十 kb 提升到后面的四五百 kb，所以负责后面漫画下载的线程速度较慢，速度没有达到预期。</li><li>网络问题。可能昨天晚上的网确实不行，也可能是频繁访问被制约了网速。</li></ul><p>今天早上用 Python 把剩下的十几话下载下来，发现其实昨天的多线程代码有问题，修改了一下，顺利下载，而且速度还不错，我开了 6 个线程，下 18 话用了不到 20 分钟。看来还是网络的问题，难顶。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;
          &lt;a href=&quot;#背景&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;背景&lt;/h1&gt;
      
&lt;p&gt;想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="异步编程" scheme="http://scottyeung.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Golang" scheme="http://scottyeung.top/tags/Golang/"/>
    
  </entry>
  
</feed>
