<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>YeungYeah 的乱写地</title><link>https://scottyeung.top/</link><description>YeungYeah 的乱写地中记录了作者的所思所想及所为。</description><generator>Hugo 0.83.1 https://gohugo.io/</generator><language>zh-CN</language><managingEditor>yeungyeah@qq.com (YeungYeah)</managingEditor><webMaster>yeungyeah@qq.com (YeungYeah)</webMaster><lastBuildDate>Fri, 07 Jul 2023 15:37:39 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://scottyeung.top/atom.xml"/><item><title>表达的力量：写作与情绪宣泄</title><link>https://scottyeung.top/2023/power-of-expression/</link><guid isPermaLink="true">https://scottyeung.top/2023/power-of-expression/</guid><pubDate>Fri, 07 Jul 2023 23:14:39 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>在知乎看看到一个 &lt;a href="https://www.zhihu.com/question/610553893/answer/3105392840">回答&lt;/a>，对此颇为认同。&lt;/p>
&lt;blockquote>
&lt;p>当你意识到自己的表达能力或者自尊水平下降的时候，一定要非常非常小心警惕，这是很危险的征兆。表达真的很重要的，比看起来还要重要。把表达能力一直顶在一个比较高的状态上实际上是一种维持平衡跟自我保护的办法。大家一定要留一个地方来表达，无论表达什么内容都好。&lt;/p>
&lt;p>不要沉默，别怕嘴笨，习惯去表达。表达是另一种意义上的健身。&lt;/p>
&lt;/blockquote>
&lt;p>表达或输出不仅是展示自我的有效工具，更是一种释放情绪的有效方式。一直以来自己都只是集中于表达在前者的作用，着眼于输出的意义和作用。这种情况下，写作大多数是为了知识的积累与沉淀，以及是将这些内容和自己的一些想法和记录分享给大家，好是好，但难免会带点为了外在的功利心。&lt;/p>
&lt;p>同时其实自己也有在 OneNote 上面开启一个带有密码的笔记本来写一点随心的周记记录，虽然因为各种各样的原因搁置过，但是也断断续续地写了几年，也囤了不少的文字。虽然当时写作的心态，是为了记录当时发生过的事情和想法，方便以后重温，但是在通过写作表达内心想法的过程中，其实也无形中释放了许多负面的情绪。尤其当情绪比较郁闷而不想开始工作的时候，甚至可以每天在 OneNote 上面写个几百上千字，哪怕其实没有什么内容，在无病呻吟，但在写的过程和写完之后，心情总是会畅快得很。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202307071741719.png" alt="">&lt;/p>
&lt;p>昨晚在 B 站看到一个 &lt;a href="https://www.bilibili.com/video/BV1dm4y1J7n1">视频&lt;/a>，讲述了一个观点，为什么好人不长命。up 主认为，好人总是为考虑他人，为别人想很多，而这样想太多，就会在内心中积累很多的想法和情绪，但他是好人，他会为他人着想，会顾虑想法表达出来后对他人的影响，于是藏在心中。长久以来，思绪积聚易成气，气郁结则容易演化成结节，影响健康。&lt;/p>
&lt;p>我深表赞同这个 UP 主的观点，也觉得自己有时也会有这样的情况。我也不是说很好人，不过自己会很在意他人的想法，所以很多想法或者情绪都会藏在心中，自己消化，以免影响他人，影响关系，又或是影响自己所谓的“形象”。虽然偶尔也能于好友亲人吐槽，但是总有些时候，是找不到表达倾诉的对象，此时通过写作的方式把想法写下来就很有价值了，哪怕只是写给自己看，甚至自己以后不看，写出来了，就已经足够了。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202307072311304.jpg" alt="">&lt;/p>
&lt;p>然而，就像许多知道有好处的事情一样，写周记和表达自我也常常因为各种原因而难以坚持。尤其是当我习惯于使用电脑键盘敲字后，如果某个时候无法使用电脑，我就会放弃记录，这些积压在心中的想法和感受就会被遗忘，这实在是一种遗憾。如何更方便地使用手机等移动端进行记录和写作，将是后面一个探索的方向。（这篇文章的文字内容就是用手机的 obsidian 写出来的，然后用 vscode 整理具体的博客内容✌️）&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%86%99%E4%BD%9C/">写作</category><category domain="https://scottyeung.top/tags/%E6%9D%82%E8%B0%88/">杂谈</category><category domain="https://scottyeung.top/tags/%E8%BE%93%E5%87%BA/">输出</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/">健康</category><category domain="https://scottyeung.top/tags/%E5%BF%83%E6%80%81/">心态</category></item><item><title>更好的写脚本方式</title><link>https://scottyeung.top/2023/better-script-with-fsharp/</link><guid isPermaLink="true">https://scottyeung.top/2023/better-script-with-fsharp/</guid><pubDate>Fri, 30 Jun 2023 12:00:41 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>毕业季和同学去拍了一些照片，后面共享回来的照片，格式是 HEIC 格式的，在电脑上可以直接打开，但是 iCloud 相册里面上传照片只支持 jpg 格式，哪怕这些照片就是用 iPhone 拍的，也不能直接上传，没有办法，只能够手动转一次照片格式。
网上也有很多 HEIC 转 JPG 格式的工具网站，但是都只能够一张张上传，然后一张张下载，这对于需要处理较大量照片的情况显然并不是一个好的解决方案。于是自然打算写个脚本，进行转换。&lt;/p>
&lt;p>当然现在有了 ChatGPT，写脚本都不用亲历亲为了，直接把问题抛给它，我们只需要做代码的搬运工。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306301213820.png" alt="">&lt;/p>
&lt;p>看起来很不错，复制到本地，替换一下路径一跑，发现脚本并不能正常运行，原因是使用的 Pillow 库其实不支持 HEIC 格式的图片。继续把问题交给它，它又给我推了一个 pyheif 库来处理，然而这个库需要 MSVC 相关工具链来编译安装，在我的电脑安装总是失败，后面尝试了几个它推荐的依赖库，都安装不了，寄！被 Python 的跨平台安装构建的低移植性狠狠教训，而为了写个脚本专门去配个环境或者容器又太夸张了。&lt;/p>
&lt;p>于是最近在学的 F#来代替，继续把问题交给 ChatGPT，来回复制粘贴代码运行尝试几次后，顺利完成任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-FSharp" data-lang="FSharp">&lt;span class="o">#&lt;/span>&lt;span class="n">r&lt;/span> &lt;span class="s">&amp;#34;nuget:Magick.NET-Q16-AnyCPU&amp;#34;&lt;/span>
&lt;span class="k">open&lt;/span> &lt;span class="nn">System.IO&lt;/span>
&lt;span class="k">open&lt;/span> &lt;span class="nn">ImageMagick&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">convertHEICtoJPG&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">inputPath&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">outputPath&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">image&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MagickImage&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">inputPath&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">image&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Format&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nn">MagickFormat&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Jpg&lt;/span>
&lt;span class="n">image&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Write&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">outputPath&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">// 获取当前目录下的所有 HEIC 文件
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nv">heicFiles&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nn">Directory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetFiles&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">@&amp;#34;/path/to/you&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;*.heic&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">// 遍历每个 HEIC 文件，并进行转换
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">heicFiles&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">jpgFile&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nn">Path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ChangeExtension&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">heicFile&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;.jpg&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">convertHEICtoJPG&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="n">jpgFile&lt;/span>
&lt;span class="n">printfn&lt;/span> &lt;span class="s">&amp;#34;转换完成：%s -&amp;gt; %s&amp;#34;&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="n">jpgFile&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对比于 Python，使用 F#来写脚本其实也足够简单和方便，可以单个 fsx 文件来写，也可以直接把写好的代码复制到 fsi 交互命令行里逐段代码执行，方便得很。尤其是对于有外部依赖库的脚本代码，使用 F#或者 C#的脚本，这样一行代码引用依赖库，可比在命令行中全局安装一个依赖好用得多。（起码不会有安装失败的问题）&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/Coding-%E8%AE%B0%E5%BD%95/">Coding 记录</category><category domain="https://scottyeung.top/tags/Python/">Python</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</category><category domain="https://scottyeung.top/tags/dotnet/">dotnet</category><category domain="https://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</category></item><item><title>我的动态时间线聚合</title><link>https://scottyeung.top/2023/my-timeline/</link><guid isPermaLink="true">https://scottyeung.top/2023/my-timeline/</guid><pubDate>Sat, 24 Jun 2023 20:30:00 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>之前一段时间偶然发现了 DIYGod 创建的一个个人 &lt;a href="https://t.me/awesomeDIYgod">Channel&lt;/a>，内容是关于他的一些动态，包括其发布的推特内容，以及豆瓣的书影音动态等内容。这种形式的 Channel 对我来说很有意思，一方面也是一个对外界分享自身情况的平台（虽然我的内容也没什么人关注），另一个方面也是可以有个地方将自己的相关信息数据持久化地保存下来，拿到自己手上。于是我也写了点代码，整出了一个自己的时间线聚合 &lt;a href="https://t.me/yeungyeah_channel">YeungYeah's Timeline&lt;/a>。&lt;/p>
&lt;p>程序大体的工作流程是这样的&lt;/p>
&lt;ol>
&lt;li>Vercel 上面部署一个自己的 RSSHub，通过 rss 的方式来订阅相关的个人信息。
&lt;ul>
&lt;li>&lt;a href="https://github.com/DIYgod/RSSHub">RSSHub&lt;/a> 是一个让所有事情都可以 rss 订阅的服务，支持许多网站源，而且 &lt;a href="https://docs.rsshub.app/">文档详细&lt;/a>，基本都可以查得到。&lt;/li>
&lt;li>一些网站的信息生成订阅需要相关的访问权限或者有一些访问次数的限制，比如 YouTube 保存的视频，和 Spotify 点赞的音乐，因此自己搭建最佳，搭建以后根据 &lt;a href="https://docs.rsshub.app/install/#pei-zhi-bu-fen-rss-mo-kuai-pei-zhi">文档&lt;/a> 在环境变量进行配置即可。&lt;/li>
&lt;li>一般地 Vercel 部署后提供的域名在大陆访问都不太方便，需要的话可以绑一个自己的域名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行一个程序定时访问 RSSHub 相关接口，获取 rss 订阅内容并保存&lt;/li>
&lt;li>缓存获取的数据的链接，如果发现新数据，则以一定的格式发送到 Telegram Channel 当中。
&lt;ul>
&lt;li>要往 Telegram Channel 自动发送消息，虽然首先申请一个自己的 Channel，获取 Channel 的 ID&lt;/li>
&lt;li>然后在 &lt;a href="https://t.me/BotFather">@BotFather&lt;/a> 处创建一个自己的 bot，并获取这个 bot 对应的访问 token。&lt;/li>
&lt;li>将 bot 添加为自己 Channel 的管理员，确保 bot 发送的信息可以传给 Channel&lt;/li>
&lt;li>通过官方提供的 API，附带访问 token，调用相应的接口，发送消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>程序的工作流程很简单，实现起来也不难。一开始我用 typescript 写了一个版本，使用 sqlite 存储数据，sequelize 作为 ORM 库，node-telegram-bot-api 作为 telegram 接口的封装库，两三天就写完上线。写起来没什么难点，只有在开发过程中一些坑点：&lt;/p>
&lt;ol>
&lt;li>Vercel 部署的 RSSHub 提供的访问域名和 Telegram 的接口，在大陆可能会出现不能访问的问题。在本地开发时，可以走代理，但是因为要 24 小时定期几分钟就跑一次，所以还是得放在服务器上面，服务器就不太方便走代理了，于是我放在了 CloudCone 位于美国的 VPS 上面，可以直连。&lt;/li>
&lt;li>往 Channel 发送消息时不好调试，需要真实往 Channel 发送消息才能看到效果。但有时候调试或者出了点啥问题后，一下子给自己的 Channel 发个几十条信息，还得自己手动删除，幸好也没有其他人关注，只影响到了自己。&lt;/li>
&lt;li>Telegram 接口发送文本消息支持 Markdown 格式信息，但是如果 Markdown 内容解析异常，会直接发送失败，而且因为内容是从 rss 订阅里抽出来的，也难判断哪里会有解析的问题，只能够出一次问题，就修复一次，重新上线一次。&lt;/li>
&lt;/ol>
&lt;p>这也好像是我第一次用 typescript 来开发项目，整体而言还是挺爽的，即使没有学过 ts，凭着 js 的基础和 ide 的帮助，也可以爽写 ts（当然原因可能代码只是写给自己的，很多时候都不太需要复杂的类型标注）。不过刚好当时也在学习 Rust，再加上可以打包成单个可执行文件的诱惑，于是我就使用 Rust 重新实现了一个版本，并编译部署到我的服务器上面。运行起来确实好像要快了点，而且最主要的好处是，内存占用从 ts 版本的 100+M，下降到了 10+M，内存占用只有原来的十分之一，而且开发效率也还不错。&lt;/p>
&lt;p>虽然写起来没什么问题，但是在打包发布上面，Rust 还是有很多槽点的。虽然 Rust 支持多个系统平台，但是很多的 crate 在系统的兼容性上都存在一定的问题，尤其是传递依赖，导致打包出来的产物还会动态依赖系统的库，或者 crate 的编译需要系统工具链的支持。我是在 Windows 上面开发调试，完成后编译一个 linux 版本的 release 一样，传到服务器上面运行。听起来很简单，但是实际上跨平台编译会出现各种问题，一些传递引入的 crate 在编译时需要 gnu 的工具链和一些在 Windows 没有的链接库，而其中的一些 crate 明确就是不支持 Windows 系统的，在解决了一个 crate 的编译问题后，又来一个，完全没有办法，只能够在 Windows Subsystem for Linux (WSL) 上面的 Ubuntu 来编译。&lt;/p>
&lt;p>然而使用 WSL 也没有那么简单，代码放在 WSL 能够正常编译得到二进制产物，传到服务器上面就不能运行，提示找不到某个版本 libssl.so 的链接库。一检查发现是因为我 WSL 上的 Ubuntu 是 18.04，而服务器在跑的已经是 22.04 的，两者通过 apt 安装的 ssl 库版本不一致，导致 WSL 编译出来的产物没有办法在服务器运行。也尝试过使用基于容器的方式来进行编译，比如 &lt;a href="https://github.com/cross-rs/cross">cross-rs&lt;/a>，但在编译的过程中还是会出现各种的问题导致编译不成功。&lt;/p>
&lt;p>于是只能够根据依赖进行进一步的具体排查，找到跟这个动态 so 库相关的依赖，发现许多需要和使用到网络连接的依赖库，都可能间接或直接依赖于 &lt;a href="https://github.com/sfackler/rust-native-tls">rust-native-tls&lt;/a>，这个库会根据系统自动选择相应的 TLS 实现 crate，来调用系统的 SSL bindings，比如在 Linux 上就会调用系统的 &lt;a href="https://docs.rs/openssl/latest/openssl/">openssl&lt;/a> 这个依赖库，包括常用的 http 请求库 reqwest，支持连接远程数据库的 orm 库 sea-orm，以及 telegram api 的封装库。这种通过 binding 方式依赖于具体的某个系统环境和依赖库，就使得构建过程和程序运行的可移植性大大降低。于是考虑使用 Rust 版本实现的 tls 依赖库 &lt;a href="https://github.com/rustls/rustls">rustls&lt;/a> 来全部替代掉。比较好的一点是，很多人都在 native-tls 的跨平台编译上面踩过不少坑，于是上面提到的这些库都提供了相关的 feature 配置选项，供用户使用 rustls 替换掉 native-tls，具体的设置方式可以到依赖库自身的文档和提供的 feature 查询。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">reqwest&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.11.16&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">default&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;rustls-tls&amp;#34;&lt;/span>&lt;span class="p">]}&lt;/span>
&lt;span class="nx">teloxide&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.12&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">default&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;macros&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;rustls&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="nx">sea&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">orm&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.11.2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="s2">&amp;#34;sqlx-sqlite&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;runtime-tokio-rustls&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;macros&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后 Rust 版本的程序通过 WSL 成功编译，并能够在服务器上面运行，运行的性能和资源占用也挺不错。但是实际上，我也并不缺这一点性能，跑得快一点意义不大，服务器的内存其实也暂时充足。而程序其实上线后也常常会出现一些意料之外的小问题，或者是需要添加一些新的订阅资源，这些都需要快速迭代，快速修改，因此使用 Rust 每次修改重新编译发布，可能都要比修改代码的时间长了。于是只能又用回 ts 版本。&lt;/p>
&lt;p>PS：另外偶然发现，Rust 开发过程中生成的中间产物，居然这么吃硬盘空间， &lt;del>又劝退多一点了&lt;/del>&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306242025064.png" alt="">&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</category><category domain="https://scottyeung.top/tags/Vercel/">Vercel</category><category domain="https://scottyeung.top/tags/JavaScript/">JavaScript</category><category domain="https://scottyeung.top/tags/Rust/">Rust</category><category domain="https://scottyeung.top/tags/Coding-%E8%AE%B0%E5%BD%95/">Coding 记录</category><category domain="https://scottyeung.top/tags/rss/">rss</category></item><item><title>Umami: 更简单的自托管网站统计服务</title><link>https://scottyeung.top/2023/umami/</link><guid isPermaLink="true">https://scottyeung.top/2023/umami/</guid><pubDate>Wed, 14 Jun 2023 10:41:12 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>此前博客都是用 Google Analytics 来提供网站统计服务，统计博客中各个页面的访问情况。可用是可用，但是 Google Analytics 提供了太多的统计内容，让人眼花缭乱，都不知道要看些什么。另外 Google 的服务，总是会存在访问性的问题。因此在看到介绍其它博主介绍 &lt;a href="https://github.com/umami-software/umami">Umami&lt;/a> 的文章后，我也打算搭建一个自己的网站统计服务，并进行切换。&lt;/p>
&lt;blockquote>
&lt;p>Umami is a simple, fast, privacy-focused alternative to Google Analytics.&lt;/p>
&lt;/blockquote>
&lt;p>Umami 主打的就是注重隐私，毕竟像访问数据这些数据，还是不落在大公司手上好点。Umami 支持多种部署方式，比如 Docker。不过对于我这种云计算爱好者来说，当然是都上云服务了。Umami 服务本身可以部署在 Vercel 上面，绑定一个域名就可以直接访问了。Umami 支持 MySQL 和 Postgresql 两种数据库，这两种数据库都可以找到对应的 serverless 提供商。这里我选择的是 PingCap 家的 &lt;a href="https://www.pingcap.com/tidb-cloud/">TiDB Cloud&lt;/a>，能够提供每个集群最大 5G 容量，每月 5 千万次访问的 MySQL 数据库。&lt;/p>
&lt;p>最终部署的成果如下。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306141051580.png" alt="">&lt;/p>
&lt;h2 id="搭建过程">搭建过程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>TiDB Cloud 登录后，创建一个 Serverless 的数据库 cluster&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在集群的 overview 页面，点击 connect 获取建立数据库链接的相关内容，以 MySQL CLI 的连接方式为例，包括&lt;/p>
&lt;ul>
&lt;li>用户名 -u&lt;/li>
&lt;li>host -h&lt;/li>
&lt;li>端口 -P&lt;/li>
&lt;li>密码 -p&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>根据获取得到的相关信息，拼接出 MySQL 的连接 URL&lt;/p>
&lt;ul>
&lt;li>&lt;code>mysql://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;database_name&amp;gt;?pool_timeout=60&amp;amp;sslaccept=accept_invalid_certs&lt;/code>&lt;/li>
&lt;li>需要预先创建一个数据库并指定数据库&lt;/li>
&lt;li>因为 TiDB Cloud 默认是需要 TLS 的，因此必须添加参数 &lt;code>sslaccept=accept_invalid_certs&lt;/code>，否则会连不上（这是一个隐藏的小坑）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>GitHub Fork Umami 项目，并到 Vercel 部署，部署时填入环境变量 &lt;code>DATABASE_URL&lt;/code>，值是上面的连接 URL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署后在 Vercel 绑定自己的域名，因为 DNS 污染的原因，Vercel 提供的域名大多数时候不能够正常访问，需要自己的域名，才能更顺利地被访问到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署成功后，通过绑定的域名访问网站，默认账号用户名和密码是 admmin 和 umami，进去后可以修改密码，添加网站，添加用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在设置页面处添加网站，填写相关信息，Umami 会为需要统计的网站分配一个 ID 以及影响的 tracking code。只需要把这个 tracking code 放到网页的 head 标签中，即可以开始收集统计数据，并在 dashboard 中看到相应的统计结果。&lt;/p>
&lt;ol>
&lt;li>以我使用的 hugo 为例，在主题的 html 模板当中找到 head 标签相关的生成模板，然后把 tracking code 放进去就行了。为了增加可配置性，也可以把 tracking code 中的 id 抽取出来变成变量，从配置中读取。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-html" data-lang="html"> {{- if and .Site.Params.enableUmami (eq hugo.Environment &amp;#34;production&amp;#34;) }}
{{ $id := .Site.Params.umamiTrackingID }}
{{ $host := .Site.Params.umamiHost }}
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">script&lt;/span> &lt;span class="na">async&lt;/span> &lt;span class="na">src&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;https://{{ $host }}/script.js&amp;#34;&lt;/span> &lt;span class="na">data-website-id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;{{ $id }}&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
{{- end }}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="nx">enableUmami&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="nx">umamiTrackingID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;your_id&amp;#34;&lt;/span>
&lt;span class="nx">umamiHost&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;your_umami_website&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/serverless/">serverless</category><category domain="https://scottyeung.top/tags/Vercel/">Vercel</category><category domain="https://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</category></item><item><title>系统工具替换之 Rust 化推进</title><link>https://scottyeung.top/2023/replace-with-tools-based-rust/</link><guid isPermaLink="true">https://scottyeung.top/2023/replace-with-tools-based-rust/</guid><pubDate>Mon, 24 Apr 2023 10:51:42 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>起因是在知乎看到了这篇 &lt;a href="https://zhuanlan.zhihu.com/p/436024560">文章&lt;/a>，讲到作者使用 Rust 新开发的终端工具生态，以构建一个能在不同设备环境下运行的终端配置。里面提到的 Starship 自己就已经在用，确实不错，而且自己确实对于 Rust 有不少的好感。于是就按照他的思路，将日常使用的一些工具，迁移到使用 Rust 实现的版本当中，体验还是挺不错的。&lt;/p>
&lt;p>具体做了以下的替换。&lt;/p>
&lt;h2 id="starship-cross-shell-prompt">Starship: Cross-Shell Prompt&lt;/h2>
&lt;p>此前在新环境开启一个 shell 之后，总是会第一时间就对 shell 进行配置，以获取更好的终端使用体验。比如在 zsh 当中使用 &lt;a href="https://ohmyz.sh/">oh-my-zsh&lt;/a>。不过这些 prompt 配置往往会因为其对于特定 shell 的移植性，以及实际使用起来的性能响应问题，而让人劝退。&lt;/p>
&lt;p>&lt;a href="https://starship.rs/">Starship&lt;/a> 是一个使用 Rust 实现的适用于任何 shell 的 prompt。实际使用起来，看起来足够美观，性能也不错，而且安装配置也方便，几乎是开箱即用。于是在很早就为我的 powershell 切换到 Starship 了。&lt;/p>
&lt;p>基本各个包管理工具都有 Starship，在 Windows 下可以使用 scoop 安装。安装好后根据相应使用的 shell 进行配置即可。&lt;/p>
&lt;h2 id="nushell">Nushell&lt;/h2>
&lt;p>&lt;a href="https://www.nushell.sh/">Nushell&lt;/a> 是使用 Rust 实现的一种新型的 shell，得益于使用 Rust 实现，Nushell 可以运行于各个 OS 平台，即使是在 Windows 上面也有着很不错的体验。这对于一个在 Windows 上面一直没有良好终端交互体验的人来说（powershell 不能根据历史记录进行补全，补全提示也很弱，不能看到所有的候选项，只能一个个 tab 切换过去尝试，简直窒息），简直是质的的飞跃。这段时间使用下来，主要有以下的爽点。&lt;/p>
&lt;ul>
&lt;li>全平台提供统一的命令和功能，使得使用起来非常统一。而且提供的命令足够丰富，完全可以涵盖日常使用。&lt;/li>
&lt;li>良好的命令补全功能。某种程度这种补全能力才是最吸引我的哈哈哈。&lt;/li>
&lt;li>一切皆数据。所有命令得到的数据，可以通过管道流动，进行数据处理加工，从而得到想要的结果和效果。
&lt;ul>
&lt;li>很多命令的输出结果都是以表格的形式返回，方便进行数据处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>足够美观。命令的输入和结果的输出，都有不错的格式化，看起来体验不错。&lt;/li>
&lt;/ul>
&lt;p>除了提供足够好用的 shell 以外，Nushell 使用语法也不错，可以很简单地进行 shell 变成，写脚本实现自己想要的功能，比如看视频常用的，获取当前目录下最近访问的视频文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">ls -l &lt;span class="p">|&lt;/span> where &lt;span class="nb">type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span> and &lt;span class="nv">name&lt;/span> &lt;span class="o">=&lt;/span>~ &lt;span class="s2">&amp;#34;.(rmvb|mp4|mkv)&lt;/span>$&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sort-by accessed &lt;span class="p">|&lt;/span> reverse &lt;span class="p">|&lt;/span> first &lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> get name
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同时 Nushell 也为来自使用不同 shell 的用户提供了 mapping 指南。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nushell.sh/book/coming_from_bash.html">Coming from Bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nushell.sh/book/coming_from_cmd.html">Coming from CMD&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>真心安利大家试试！&lt;/p>
&lt;h2 id="bat-alternative-to-cat">Bat: alternative to cat&lt;/h2>
&lt;p>Linux cat 的命令用于输出文本文件的内容，几乎是 Linux 上最常用的命令之一了。&lt;a href="https://github.com/sharkdp/bat/">Bat&lt;/a> 则是带有自动格式化和语法高亮的 cat 命令。而且 Windows powershell 当中居然不提供 cat 的命令或者 alias，让人不适应。Bat 还有许多的功能，比如与 git 集成，以及自动分页。&lt;/p>
&lt;p>Bat 已经用很久了，它已经存在于我的每个设备上面，大量使用，已经替换掉我的 cat 了。&lt;/p>
&lt;h2 id="fd-alternative-to-find">fd: alternative to find&lt;/h2>
&lt;p>&lt;a href="https://github.com/sharkdp/fd">fd&lt;/a> 是使用 rust 实现的简单快捷的 find 命令代替版。实际使用的性能表现挺不错的，而且输出就自带颜色格式化，结果看起来也很美观。不过 fd 的出现，最主要是可以让我在 Windows 下面也可以用到 find，快速地找到文件。在终端使用 fd 命令，几乎可以当成一个命令行版本的 everything，来搜索文件。&lt;/p>
&lt;h2 id="zoxide">zoxide&lt;/h2>
&lt;p>&lt;a href="https://github.com/ajeetdsouza/zoxide">zoxide&lt;/a> 是使用 Rust 实现的目录切换工具，是一个更加智能的 cd 命令。类似于 autojump，zoxide 可以记录历史访问切换路径，然后根据历史数据，快速跳转到目标路径。比如通过多次 cd 进入了一个深层级的目录后，后面就可以直接根据目录名一步跳转到目标目录。得益于 Rust 的跨平台能力，zoxide 适用于多种不同的 shell，而且性能表现还不错。&lt;/p>
&lt;p>现在正在逐步使用 z 替换掉习惯中的 cd。&lt;/p>
&lt;h2 id="helix-alternative-to-vim">Helix: alternative to vim&lt;/h2>
&lt;p>&lt;a href="https://github.com/helix-editor/helix">Helix&lt;/a> 是一个使用 vim 键位的终端编辑器，其自带有比较完备的配置设置，基本可以开箱即用，而且一些操作也更加简单，其内置了较多的提示和选项菜单，使用体验比 vim 要好很多，尤其是在大家都没配置的情况下。对于我这种懒折腾的人来说简直完美。&lt;/p>
&lt;p>现在在服务器上也基本用 helix 来代替 vim 了，几乎没有什么学习成本。&lt;/p>
&lt;h2 id="zellij-alternative-to-tmux">zellij: alternative to tmux&lt;/h2>
&lt;p>&lt;a href="https://github.com/zellij-org/zellij">zellij&lt;/a> 是一款类似于 tmux 的终端复用工具。不过相比于 tmux，zellij 使用起来更加简单（因为几乎所有的操作命令都可以在窗口的指示中了解到），不需要再像用 tmux，如果一段时间没用，还得现搜一些快捷键，看怎么退出会话，怎么切换 tabs。使用体验还是不错的。&lt;/p>
&lt;hr>
&lt;p>Rust 语言的发展，带来了大量工具软件的蓬勃发展。虽然有些人会觉得 Rust 开发者是不是闲得没事，总是喜欢造轮子，总是喜欢把已有的东西重新实现一遍。但我觉得这样的发展趋势还是很棒的，这也并不是简单地重复造轮子，除了 Rust 带来的性能提升以外，我觉得最主要的卖点，还是 Rust 跨平台特性，所带来的软件工具的移植性。因为 Rust 跨平台，所以可以为各个 OS 和架构都直接打出一个可用的二进制包，借助各类型的包管理工具，下载安装的体验极佳，即使是 Windows。退一步，即使包管理源还没有相应的工具，还能够通过 cargo 进行源码安装（就是花的的时间多一点，不过可以考虑使用 &lt;a href="https://github.com/cargo-bins/cargo-binstall">cargo binstall&lt;/a> 提速一下）。&lt;/p>
&lt;p>感谢 Rust，让我有机会能够在 Windows 平台下体验到许多原本只能在 Linux 系统才能够体验到的命令行工具，还能够有非常不错的体验，值得向大家推荐。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/Windows/">Windows</category><category domain="https://scottyeung.top/tags/Linux/">Linux</category><category domain="https://scottyeung.top/tags/shell/">shell</category><category domain="https://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</category><category domain="https://scottyeung.top/tags/Rust/">Rust</category></item><item><title>Hugo 如何转义美元符号 $</title><link>https://scottyeung.top/2023/hugo-escape-dollar-sigh/</link><guid isPermaLink="true">https://scottyeung.top/2023/hugo-escape-dollar-sigh/</guid><pubDate>Thu, 13 Apr 2023 10:42:26 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>写上一篇博客的时候出现了一些美元符号 $，因为平时比较少用，所以发布后才发现这是个特殊字符，显示效果会有点问题，需要进行转义。不转义的话，可能就会当成行内公式来处理，显得很奇怪。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202304131045363.png" alt="">&lt;/p>
&lt;p>反应过来后很快就给这些 $ 符号添加上反斜杠 \ 来转义了，即使用&lt;code>1\$&lt;/code>的形式。因为文章还同时发布在 &lt;a href="https://blog.yeungyeah.top/">xLog&lt;/a> 的平台上面，所以修改后就直接在上面看效果，看起来没事，就重新发布了。&lt;/p>
&lt;p>然后今天发现主页上 hugo 的版本还是显示不正常，在本地跑了一下才发现，这样加一个反斜杠转义并没有转义效果。搜了一轮才意识到，应该是我的 Hugo 全局开了 MathJax 的问题。在开启 MathJax 的情况下，文章 markdown 会出现处理一轮，先做一轮转义，比如 &lt;code>\$&lt;/code> 会转义成 &lt;code>$&lt;/code>，然后再用 MathJax 扫描，如果这时还发现 $ 符号，自然就会当成公式再处理一遍，导致不能正常显示出 $。&lt;/p>
&lt;p>所以解决办法是，要么关掉 Hugo 的全局 MathJax，要么给反转义符再加一层转义，像下面一样。这两者都可以解决问题，使得文章正常显示 $。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-markdown" data-lang="markdown">花了 1\\\$ 手续费
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>最终为了方便在两个平台同时发布，还是选择了关掉了全局的 MathJax，然后再为出现了数学公式的文章添加 Front Matter&lt;/p>
&lt;p>mathjax: true&lt;/p>
&lt;/blockquote></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/Hugo/">Hugo</category><category domain="https://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category></item><item><title>使用 Depay 绑定 OpenAI</title><link>https://scottyeung.top/2023/depay-and-openai/</link><guid isPermaLink="true">https://scottyeung.top/2023/depay-and-openai/</guid><pubDate>Tue, 11 Apr 2023 12:02:17 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>之前一直苦于没有外币信用卡，外面的很多服务都没有办法体验。然后刚好 4.1 号后 OpenAI 送的 credit 到期了，继续使用 ChatGPT 的 API 就需要绑定信用卡，才能够继续使用。没有办法，只能寻找办法办一张可以支付的卡。刚好看到土木坛子关于 &lt;a href="https://tumutanzi.com/archives/16984">depay 信用卡的介绍&lt;/a>，看起来还行，有支付的渠道，而且能用于 OpenAI 的付费，就搞了一张。&lt;/p>
&lt;h2 id="depay">Depay&lt;/h2>
&lt;p>Depay 支持申请 Master 卡，是一种预付型的信用卡。可以简单地理解成需要预先充值才能使用的银行卡。Depay 办卡本身还是挺容易的，麻烦在于后面的充值。&lt;/p>
&lt;h3 id="办卡">办卡&lt;/h3>
&lt;ol>
&lt;li>在 &lt;a href="https://depay.depay.one/web-app/register-h5?invitCode=737033&amp;amp;lang=zh-cn">Depay 网站&lt;/a> 或者 APP 上注册账号
&lt;ul>
&lt;li>可以用我的邀请码进行注册 737033
&lt;ul>
&lt;li>&lt;img src="https://scottyeung.top/my-images/202304111229402.jpg" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是 IOS 用户的话，需要切换到美区才能够找到 Depay 的 app，国区的 Depay 测试已满，已经加不进去了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 APP 进行身份认证，然后录制一段小视频完成 KYC/AML 反洗钱程序，等待通过&lt;/li>
&lt;li>通过后就可以申请卡，有不同的卡片等级可以选择，不同等级有着不同的开卡费，月费，充值手续费的区别。个人感觉选个最低级别的其实就够了，后续用得多了还可以再升级。
&lt;ul>
&lt;li>&lt;img src="https://scottyeung.top/my-images/202304111225681.png" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>开了卡之后需要充值 5$ 还是 10$ 以上才能激活，获得卡号&lt;/li>
&lt;/ol>
&lt;h3 id="充值">充值&lt;/h3>
&lt;p>作为一张预付型的卡，Depay 需要先充值才能够再使用。Depay 主要是通过数字货币 USDT 来进行充值，只需要把 USDT 转到他们指定的账号上，然后就能够将其兑换成美元使用。当然 USDT 的获取在这里也不是那么容易，这里选择的是在 &lt;a href="https://www.cnouyi.care/">欧易交易所&lt;/a> 进行交易。&lt;/p>
&lt;ol>
&lt;li>首先在欧易注册个账号，并通过认证。&lt;/li>
&lt;li>然后通过快捷买币的方式获取 USDT，支付方式支持使用支付宝。这里购买的 USDT 并不能马上提现，需要等 24 小时才能提现出去。&lt;/li>
&lt;li>在 Depay 获取充值的地址，注意选择一致的网络，比如我选择的是 TRC20
&lt;ol>
&lt;li>充值是有最小金额限制的，一般需要大于 5USDT，&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>提现后大概等十来分钟 USDT 就能入账到 Depay&lt;/li>
&lt;li>将 Depay 当中入账的 USDT 转换成 USD，就可以充值到申请的卡当中，充值完成后就可以获取到卡号等相关信息，算是激活成功了&lt;/li>
&lt;/ol>
&lt;p>在充值过程中，从欧易提现 USDT 花了 1$ 手续费，然后充值到 Depay 当中又收了 1.35% 的手续费（这个还有个最小 1$ 的限制），最后 USDT 转成美元又有损耗（1USDT 约等于 0.99USD）。这样一轮转换下来，我原本是买了 50USDT，最终搞定转入卡中的 USD 只有 47.5$ 左右，过程大概花了 2.5$ 的手续费。总的来说手续费还是有点点高的，因此最好充值的时候考虑一次性充值足够的钱，当然也不要太多，&lt;del>Depay 跑路就麻烦了&lt;/del>，看手续费来衡量吧。&lt;/p>
&lt;h2 id="openai-绑定">OpenAI 绑定&lt;/h2>
&lt;p>有了卡之后就可以去 OpenAI 处添加消费方法，绑卡。绑卡主要填写的内容是卡号，安全码，以及账单地址。卡的信息可以在 Depay 的 app 上面找到，地址信息可以到一些地址生成网站获取，如 &lt;a href="https://www.haoweichi.com/Index/custom_result">haoweichi&lt;/a>。&lt;/p>
&lt;p>然而 OpenAI 的风控非常的诡异，除了限制国内许多的信用卡外，很多时候还会因 IP 而不让绑卡。网上的说法五花八门，比如让开全局代理，开无痕模式，甚至还说要梯子的 IP 要跟填写的地址一致的。根据亲身体验，其实并不一定要使用美国的 IP，而且 IP 和填写的地址也不一定需要一致。相反地，感觉非美国的其它区域的 IP 地址可能回因为冷门点反而更好通过。最后我是使用了一个日本还是新加坡的节点，在第四次的时候成功绑定。&lt;/p>
&lt;p>在绑定 OpenAI 之后，卡会扣 5$ 的授权额度，然后应该是根据每个月使用的情况进行扣费，到时候还得看能不能顺利扣费成功🤣&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/AI/">AI</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E6%94%AF%E4%BB%98/">支付</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category></item><item><title>无意识 Preferences</title><link>https://scottyeung.top/2023/unconscious-preference/</link><guid isPermaLink="true">https://scottyeung.top/2023/unconscious-preference/</guid><pubDate>Sun, 09 Apr 2023 11:07:33 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>前几天关注的一个 up &lt;a href="https://space.bilibili.com/1322440019?spm_id_from=333.337.0.0">難聽歌手俱樂部&lt;/a>，因为新视频中继续吐槽了某位女歌手，惹来了众多的粉丝攻击，然后 up 受不了了，发动态表示停更了。这个 up 主要是做一些香港歌手的难听现场的合集点评，一直以来我都是看个乐子，有些现场确实会让人忍不住发笑，在这个 up 的视频里面我也确实见识到了“歌手”的多样性 &lt;del>，确实什么样的人都可以做歌手&lt;/del>。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202304091128898.png" alt="">&lt;/p>
&lt;p>对于停更这个事情，知道后感觉到很魔幻，想不到还真的会有人较真起来。本来是否唱得难听这件事，就是一件很主观的事情，每个人的程度都不一样，有些人要求高，有些人要求低。然而评论里居然还有人会搬出既然要吐槽，怎么没有 XX，怎么又有 XX，up 是不是对 XX 有偏见，是不是双标。然而之前连发几个吐槽 Mirror 视频的时候大家都还是乐呵呵地跟着笑，那时就没有人说 up 是双标了。但是如果说到了某个女星，就会变成她其实还好，她还年轻，应该多给机会她。&lt;/p>
&lt;p>想了想，会出现这种事情的原因，还是因为自己喜欢的人或事被别人评价了，因此可能就会觉得自己所爱被攻击了。到这个时候，在评论区争辩其实就变成了立场的战争，变成了守卫自己的所爱了。有 preference 其实是很合理的事情，但 preference 被别人锐评时，自己还能不能保持理智的思考，就是一个能力了。&lt;/p>
&lt;p>晚上的时候自己其实也忽然想到，如果自己支持的某个歌手或者艺人，也被这样锐评了，我还能够笑得出来吗？然后转念一想，自己之前很喜欢听 AGA 的歌，也很喜欢她，但还是不妨碍我在 up 这里乐呵呵地看 &lt;a href="https://www.bilibili.com/video/BV1Lr4y1G72s/?spm_id_from=333.999.0.0&amp;amp;vd_source=2a7aa969015404d2b62ea4a38e2bfbf7">up 吐槽 AGA 唱歌&lt;/a> ，但也可能是我不够爱吧哈哈。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/">随笔</category></item><item><title>Why Firefox?</title><link>https://scottyeung.top/2023/why-firefox/</link><guid isPermaLink="true">https://scottyeung.top/2023/why-firefox/</guid><pubDate>Sun, 26 Mar 2023 17:39:50 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>此前一直使用微软自带的密码管理工具。PC 端可以使用 Edge 提供的密码填充和查询功能，移动端则可以通过微软推出的 Authenticator 作为手机的密码管理工具。虽然好用，但基本上意味着 PC 的浏览器需要和 Edge 及微软强绑定。如果想换其他浏览器，就不太方便了。&lt;/p>
&lt;p>最近两周，我开始使用 Bitwarden 作为密码管理器，从而摆脱了对 Edge 的依赖。于是，我立即更新了电脑上的 FireFox 浏览器，并尝试将其作为默认浏览器使用。使用体验还不错，它拥有我需要的所有功能，表现与 Chrome 和 Edge 差不多。&lt;/p>
&lt;p>然而，FireFox 的表现只是还可以，实际上没有太多出彩的地方，只能说它接近或者差不多好于 Edge。这也并不是 FireFox 的问题，因为它已经很好地完成了自己的任务，而浏览器很难做出令人惊艳的创新。&lt;/p>
&lt;p>但是这种只是表现差不多的程度，遇上使用人数上的极大差距，就会变得很没有竞争力。例如，最近 ChatGPT 很火，出现了许多相关插件。我看上了一个整合各种 AI 的 Chathub 插件，但它没有 FireFox 版本，因此我又改回了 Edge，尽管后来我也没有太多使用这个插件。&lt;/p>
&lt;p>当新软件面临着已经形成的庞大用户群体，这些用户群体拥有成熟且庞大的社区时，该怎么办呢？这确实很难。&lt;/p>
&lt;p>如果还有使用 FireFox 浏览器的用户，请在评论区分享你使用它的原因，说服更多的人加入。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/">随笔</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E5%90%90%E6%A7%BD/">吐槽</category><category domain="https://scottyeung.top/tags/%E6%9D%82%E8%B0%88/">杂谈</category></item><item><title>AI 时代，Prompting 时代</title><link>https://scottyeung.top/2023/prompt-times-coming/</link><guid isPermaLink="true">https://scottyeung.top/2023/prompt-times-coming/</guid><pubDate>Wed, 15 Mar 2023 17:52:25 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>一早醒来，就看到 OpenAI 发布的新一代 GPT-4 模型刷屏，加上之前火热的 &lt;a href="chat.openai.com">chatGPT&lt;/a>，似乎真人工智能时代已到，大家都开始尝试使用 AI，各种各样的场景都在尝试用 AI，看起来确实前途光明，机会满满。在看着如此强势的 AI 的表现下，有人开始调侃以后许多职业可以被取代了，比如我们写代码的，还要啥 software engineer，不如 prompting engineer，直接让 AI 写就好了。当然对于我这个一直在用 GitHub Copilot 的人来说，面对 ai 的态度早就是打不过就加入了，当然是积极拥护 AI 的发展。&lt;/p>
&lt;p>在这个背景下，许多 AI 使用的教学开始火热起来，甚至在推特上还看到有人在收费卖 chatGPT 的使用课程，确实有商业头脑。于是我也不能落后，在今天刷到一个 &lt;a href="https://learnprompting.org">Learning Prompting&lt;/a> 的文档后，马上开学，争取成为一个及格的 prompting engineer.&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202304051948782.png" alt="">&lt;/p>
&lt;p>下面是一些看完文档记录的一些 notes，建议大家阅读前最好先体验下 chatGPT，毕竟如果找不到使用的方法，学来也没什么意义。&lt;/p>
&lt;h2 id="基本概念">基本概念&lt;/h2>
&lt;p>简单来说，prompt 就是告诉 AI 要怎么做，怎么满足你的需求。当中可以包括上下文，指令，以及一些提问与回答的例子。&lt;/p>
&lt;blockquote>
&lt;p>The process of instructing an AI to do a task is called prompting. We tell the AI a set of instructions (the prompt) and it performs the task. Prompts can be as simple as a question, or as complex as multiple paragraphs.&lt;/p>
&lt;/blockquote>
&lt;p>可能会有人感觉疑惑，为什么还需要学习专门的 prompt 呢？直接向它下命令，直接向它提问不就好了吗？然而现在的 AI 确实没有这么智能，很多时候并不能达到想要的效果。上面的文档中提到一个挺有意思的 case&lt;/p>
&lt;pre>&lt;code>What is 965*590? // 可能会返回错误答案
Make sure your answer is exactly correct.
What is 965*590?
Make sure your answer is exactly correct
// 重复强调后返回正确答案
&lt;/code>&lt;/pre>&lt;p>因此掌握一定的 prompt 技巧可以更好地得到想要的答案。&lt;/p>
&lt;h2 id="一些策略与技巧">一些策略与技巧&lt;/h2>
&lt;p>除了直接给指令与提问以外，下面的一些策略与技巧可能可以得到更好的效果。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>角色扮演。&lt;/strong> 让 AI 扮演某个角色，来回答某些问题，或者做某些行为。比如是充当一个词源学家来解释单词的词根构造，或者是充当售后中心的服务人员，回答消费者的问题。
&lt;ol>
&lt;li>看到这个时突然有点开了点脑洞猜想上面的算数 case 为什么会出错，既然可以扮演角色，意味着其实可能在某种情况下扮演一个数学不好或者不会算数的人？&lt;/li>
&lt;li>这个东西其实还挺好玩的，除了扮演角色以外，还可以充当一些物品或者机器，甚至还看到过有人用 chatGPT 扮演一个 shell，并且成功执行命令&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>传递 context。直接的提问可能让 AI get 不到你想要传递的点，所以可以在 prompt 中传递上下文背景，或者通过连续对话的方式，让 AI 掌握上下文背景，有更多的信息来生成回答。&lt;/li>
&lt;li>Chain of Thought. 在 prompt 中先给出一些在答案中包含解释的 QA 例子，从而让 AI 在回答时也进行解释，通常地带解释的回答更加准确和详细。&lt;/li>
&lt;li>Zero shot Chain of Thought. &lt;strong>直接让 AI 在回答中给出解释，比如让它 'step by step' 回答&lt;/strong>。在某些情况下，可以做到不需要例子就能有 Chain of Thought 的效果。&lt;/li>
&lt;li>Self-Consistency. 基于 zero shot CoT，在 step by step 的过程中综合多次回答来选取正确答案。&lt;/li>
&lt;li>&lt;strong>提问或指示前先让其生成相应的知识&lt;/strong>。
&lt;ol>
&lt;li>如需要写一篇关于某内容的 post 时，可以让其先列出关于内容的若干事实，再开始写&lt;/li>
&lt;li>作用是让其知识生成和知识集成处于同一步骤&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Least to Most Prompting
&lt;ol>
&lt;li>将问题或者 case 分解成子问题求解&lt;/li>
&lt;li>在 CoT 教导解释时，可以用递归的方式来解释&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>借助工具。偶然刷到现在已经有工具可以根据需求的类别选择模块，快速生成 prompt，比如 &lt;a href="https://app.aiprm.com/">AIPRM&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>就这个发展趋势看下来，AI 降临到每一个人身边似乎已经是板上钉钉的事情了，即使是“服务在所在地区不可用”的情况下，国内的各家公司还是以自家的产品来为大家普及 AI 服务。这其实也是个好事情，毕竟不好用也比没得用好 &lt;del>，不过某种程度上算不算硬给人们造出个信息差呢？&lt;/del>。作为一个积极拥抱新技术新事物的人，我对于 AI 还是很乐观的，尤其是在感受 GitHub Copilot 的魅力之后，写代码简直离不开了。希望能够有机会尽快体验到 GPT-4，以及有条件订阅 chatGPT plus.&lt;/p>
&lt;p>所以作为普通人，应该如何应对这般趋势呢？感觉还是得靠下面三方面的能力，确保不被时代抛下：&lt;/p>
&lt;ol>
&lt;li>广泛获取阅读并提炼信息&lt;/li>
&lt;li>快速学习知识和工具的使用&lt;/li>
&lt;li>为问题提出解决方案并落实&lt;/li>
&lt;/ol>
&lt;p>希望自己能够做到，与大家共勉！&lt;/p>
&lt;hr>
&lt;p>最后附上一个 AI 生成的命题作文式后记，生成了几次都不是很满意，但是以足够应付一些没有意义的文字工作了。&lt;/p>
&lt;blockquote>
&lt;p>AI prompt 技术的出现，让我们看到了人工智能的无限潜力。然而，在使用 AI 技术时，我们也需要注意如何更好地引导 AI 解决问题。因为 AI 能力的发挥，很大程度上取决于我们所提供的输入数据和问题引导方式。如果我们不善于引导，AI 将会被困在一个不断重复的循环中，无法创造出真正的创新和价值。&lt;/p>
&lt;p>通过学习 AI prompt 的引导方法，我们也可以获得一些对我们自身有益的启示。例如，学习如何更好地理解问题，如何针对不同问题提供不同的引导方式，以及如何从问题中发现隐藏的机会和潜力。这些能力不仅可以帮助我们更好地引导 AI 解决问题，也可以帮助我们更好地应对现实生活中的各种挑战。&lt;/p>
&lt;p>当然，AI 技术的发展也需要我们保持一定的警惕性和负责任的态度。我们需要认真考虑 AI 技术带来的潜在风险和挑战，并积极寻求解决方案。只有在这样的前提下，我们才能更好地引导 AI 技术发挥它的潜力，为我们带来更多的创新和价值。&lt;/p>
&lt;/blockquote></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/AI/">AI</category><category domain="https://scottyeung.top/tags/coding/">coding</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/notes/">notes</category></item></channel></rss>