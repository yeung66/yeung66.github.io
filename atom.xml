<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeungYeah 的乱写地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.top/"/>
  <updated>2021-05-23T05:09:23.147Z</updated>
  <id>http://scottyeung.top/</id>
  
  <author>
    <name>YeungYeah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS 选择器</title>
    <link href="http://scottyeung.top/2021/css-selector/"/>
    <id>http://scottyeung.top/2021/css-selector/</id>
    <published>2021-05-22T10:39:56.000Z</published>
    <updated>2021-05-23T05:09:23.147Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>翻 MDN 文档重新系统地学习下 CSS 选择器知识，记录下来当作笔记。</p><a id="more"></a><p>所谓 CSS selector 用于在 HTML 文档中选取指定的元素节点，可用于 CSS 文件中设置 style 或者在某些库中选取元素节点（如爬虫）。</p>        <h2 id="css-rules-中使用">          <a href="#css-rules-中使用" class="heading-link"><i class="fas fa-link"></i></a>CSS Rules 中使用</h2>      <p>在 CSS 文件中 selector 通常为 Rules 的开头，每个 Rules 可以指定单个 selector 或者指定 selectors list，后者以逗号分割 (,)</p>        <h3 id="invalid-情况">          <a href="#invalid-情况" class="heading-link"><i class="fas fa-link"></i></a>invalid 情况</h3>      <p>当</p>        <h2 id="css-选择器类型">          <a href="#css-选择器类型" class="heading-link"><i class="fas fa-link"></i></a>CSS 选择器类型</h2>      <ul><li>Type selectors: 类型选择器，根据 <code>tagname</code> 来选择对应的元素</li><li>Universal selectors: 通用选择器，使用 <code>*</code> 来匹配所有元素<ul><li>可以增强伪类选择器的可读性： <code>div *:first-child</code> instead of <code>div :first-child</code></li></ul></li><li>Class selectors: 类选择器，使用 <code>.classname</code> 来选择相应的元素<ul><li>可以结合其它选择器如 <code>span.highlight</code></li><li>可以同时选取包含多个 class 的元素 <code>.class1.class2</code></li></ul></li><li>ID selectors: ID 选择器，使用 <code>#id</code> 来选取相应元素</li><li>Attribute selectors: 属性选择器，根据元素的属性来选择元素<ul><li><code>[attr]</code>: 元素包括 attr 属性</li><li><code>[attr='val']</code> : 元素的 attr 属性值为 val</li><li><code>[attr~='val']</code> : 元素的 attr 属性为 val 或该属性的列表中包含 val（如 <code>attr='val val1'</code></li><li><code>[attr|='val']</code> : 元素的 attr 属性为 val 或该属性以 val- 开头（如 <code>attr='val-val1'</code></li><li><code>[attr^='val']</code> : 属性以 val 开头</li><li><code>[attr$='val']</code> : 属性以 val 结尾</li><li><code>[attr*='val']</code> : 属性包含 val</li><li>取否定需要伪类选择器 <code>:not([attr])</code></li><li>末尾添加 <code>i</code> 可以是匹配大小写不敏感</li></ul></li><li>pseudo-class: 伪类选择器，用 <code>:pseudo-class-name</code> 可选择在特定状态的元素<ul><li>选择指定顺序: <code>first-child</code>, <code>last-child</code>, <code>first-of-type</code>, <code>nth-child(n or an+b)</code></li><li>选择特定状态: <code>checked</code>, <code>disabled</code>, <code>visited</code></li><li>for action: <code>hover</code>, <code>focus</code></li></ul></li><li>pseudo-element: 伪元素选择器，使用 <code>::pseudo-element</code> 选取<ul><li>与伪类的区别伪元素会为选中的元素添加 HTML 片段，而伪类只会在原元素中修改</li><li>选取特定位置: <code>first-line</code></li><li>生成特定内容: <code>before</code>, <code>after</code> 然后通过 content 属性设置</li></ul></li></ul>        <h2 id="css-combinators">          <a href="#css-combinators" class="heading-link"><i class="fas fa-link"></i></a>CSS Combinators</h2>      <ul><li>Descendant: <code></code> 后者元素的某个祖先是前者元素</li><li>Child: <code>&gt;</code> 后者是前者的直接子节点</li><li>Adjacent sibling: <code>+</code> 后者紧接着前者，且是同一个父元素节点</li><li>General sibling: <code>~</code> 后者出现在前者的后面，且是同一个父元素节点</li></ul>        <h2 id="css-selector-的优先级">          <a href="#css-selector-的优先级" class="heading-link"><i class="fas fa-link"></i></a>CSS Selector 的优先级</h2>      <p>如果有多个 CSS Rule 同样选择到了某个元素节点且声明的 CSS 样式出现冲突时，会根据首先根据优先级进行处理，当优先级相同时，选择后声明的规则。</p><p>优先级可以用一个四位数表示，每出现一个选择器在相应位上加一</p><ol start="0"><li>inline style: 行内的 css style 的优先级时最高的，直接在千位加一</li><li>百位: ID Selector</li><li>十位: Class selector,  attribute selector, preudo-class selector</li><li>各位: type selector, preudo-element selector</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;翻 MDN 文档重新系统地学习下 CSS 选择器知识，记录下来当作笔记。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="CSS" scheme="http://scottyeung.top/tags/CSS/"/>
    
      <category term="前端" scheme="http://scottyeung.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="笔记" scheme="http://scottyeung.top/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>种树，直到把自己围住</title>
    <link href="http://scottyeung.top/2021/forest-for-what/"/>
    <id>http://scottyeung.top/2021/forest-for-what/</id>
    <published>2021-05-18T14:36:14.000Z</published>
    <updated>2021-05-19T02:32:46.331Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>对于五月假期回来后状态的复盘，其实是写于 5.15 的周记记录</p></blockquote><p>是否还应该要使用 <span class="exturl"><a class="exturl__link" href="https://www.forestapp.cc/">Forest</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> 种树呢？在去年的四五月份的时候就曾经有过这样的<a href="/2020/%E7%AA%81%E7%84%B6%E4%B8%8D%E6%83%B3%E5%86%8D%E8%AE%B0%E5%BD%95%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8/">想法</a>，怀疑自己使用 Forest 等时间记录工具的意义在哪，甚至会觉得使用这些工具使自己对于时间的利用变得很焦虑，进而对自己的时间安排产生焦虑。</p><a id="more"></a><p>说起来也比较讽刺，原意使用 Forest 是为了记录我日常使用时间的情况，但是演变到今天，已经变成了推动自己工作学习的工具，用来衡量自己有无努力学习，认真工作的工具。我对于 Forest 的使用心态，已经从以往看看今天学了多久时间，变成看看今天能不能学到 300 分钟。一般来说，这个任务是可以达到的，但如果有些特殊的情况，例如昨天提到的状态不好，不想干活，导致开始工作的时间晚了，我就会觉得今天的任务预期好像完成不了，就会觉得愧疚与焦虑。当出现这种心态之后，就会出现想要让自己的数据更加好看的想法，继而会出现一些不妥的功利的想法，例如将一些非工作的活动也计时，又或者是中途需要打断活动的时候还是继续计时，通过这样的方式来让种树的时间更多更好看。</p><p>但这样的行为并没有意义，这样获取到的数据也没有意义，相反，还会给自己增添许多的压力。翻了翻以前的种树的记录，在 19 年刚刚开始使用的时候，那时使用 Forest 就真的纯粹就是记录自己的时间使用情况而已，以及让自己增添的一个开始工作的仪式感。那个时候的我虽然有时种树也能种比较多的时长（挺多 300-400+ 分钟），但是其中也不乏一些 200+ 分钟的日子夹杂在其中。状态的起伏，可利用时间的变化都是很常见的状况，尤其是在读书阶段还需要去上课，需要处理一些额外的状况，又或者是出去玩之类的活动，为什么需要强求自己每天都能够学习到某一个固定的时间呢？</p><p>这种转变大概发生在保研之后的大四上学期，那个阶段的我一下子没有了比较紧迫且具体的任务推动，很多时候不想干活，也不知道要干些什么，干到什么程度。为此，我就想出了一个比较好能够推动自己的方法，既然没有具体的目标，不知道需要完成到什么程度，那我就按照学习时间来衡量，每天学多少时间来判断自己当天有无认真学习。想法是很好的，但这个标准任何制定，制定得是否灵活，就需要衡量太多东西了。</p><p>这样的想法放到了如今重新回到学习生活的我来说，又显得不够灵活。一方面我被其制约，无法更加灵活而合理地利用时间，另一方面，我对于时间的利用也变得更为洁癖与讲究。具体表现为</p><ul><li>有些重要但是与学习不太相关的事情，我可能会因为其不能种树（计时）而将其优先级放得比较低，从而导致自己不会去做这些事情。例如运动，尤其是在学习途中的休息活动，因为这些活动不能很直观地将它们的好处与效果表现出来，不像学习能够通过种树显示出学习时间，知道自己今天努力了多久，做了多少。所以不愿意去，也不敢去做，担心占用我的时间。</li><li>对于时间的利用不够灵活，仿佛洁癖一般，总是会抱着一种完美主义的效率至上心态。会认为与其在上课的半个小时里面低效的学，不如在这期间摸鱼休息，然后等到之后可以高效率学习。这样的心态会导致自己在某些时候心安理得地摸鱼不学习，把时间白白浪费掉。其次就是对于时间的要求越来越多，然后就开始成为拖延某些任务的借口。明明可以做半个小时，一个小时，但是觉得这么短的时间干不出什么结果就干脆放弃，不做，选择做一些短平快的事。</li></ul><p>当然其实工具的本身还是其次，本质上还是自己的心态出现了问题，现在的自己不是很能够接纳没有学习的自己，不能接受好像一天都没怎么学习的自己。原本只是为了对于时间记录这个用于以后留念的数据，现在逐渐演变成证明自己有在努力的工具，很是不妥，而自己也仿佛被困在 Forest 这个工具当中。</p><p>当然你要我一下子就完全不用，我也还是做不到，甚至在写这篇文章的时候，我也开着了 Forest 来计时。不过还是需要改变，正如昨天文章所写，改变只需要一点点的改进，就从看少点 Forest 的种树记录，看轻点里面的数字开始。或许首先可以做到的就是，减少学习时间吧 <span class="github-emoji" alias="laughing" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8">😆</span></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于五月假期回来后状态的复盘，其实是写于 5.15 的周记记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是否还应该要使用 &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://www.forestapp.cc/&quot;&gt;Forest&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt; 种树呢？在去年的四五月份的时候就曾经有过这样的&lt;a href=&quot;/2020/%E7%AA%81%E7%84%B6%E4%B8%8D%E6%83%B3%E5%86%8D%E8%AE%B0%E5%BD%95%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8/&quot;&gt;想法&lt;/a&gt;，怀疑自己使用 Forest 等时间记录工具的意义在哪，甚至会觉得使用这些工具使自己对于时间的利用变得很焦虑，进而对自己的时间安排产生焦虑。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="时间管理" scheme="http://scottyeung.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>“什么都不做”</title>
    <link href="http://scottyeung.top/2021/do-nothing/"/>
    <id>http://scottyeung.top/2021/do-nothing/</id>
    <published>2021-05-18T13:21:49.000Z</published>
    <updated>2021-05-18T14:39:22.131Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>对于五月假期回来后状态的复盘，其实是写于 5.14 的周记记录</p></blockquote><p>经历了不太想工作的一周工作日，可能是还处在五一的假期后遗症当中，缺乏干活的动力，每天都不想起床，不想干活，但偏偏事情又感觉很多，因而会陷入一种焦虑当中，不想干，但又要干，让人很是闹心。因为不想干活导致了无意义的拖延行为，因为拖延导致不得不利用一些另外的时间来尽量补回被拖延的时间，因为额外的时间被占用了导致某些想做的事情难以完成甚至无法完成，因为做不了自己想做的事情觉得不甘心又导致因为不愿就这样结束自己的一天而自然地熬夜，因为睡得不够又导致了第二天很困起不来，更加缺乏做事的动力与决心。</p><a id="more"></a><p>感觉像是陷入了一个无解的死循环中，但自己还在寄希望于只是今天先这样，明天就能好起来的幻想当中，还觉得自己只是陷入了一种每个人都会进入的，缺乏动力不想干活的状态。只要等它过去，只要等自己进入一种充满活力的状态，问题就能够自己消解。尽管如此，我也没有去尝试或寻找让自己进入充满精力的状态，只有空想，而没有实践。</p><p>我能够做什么，或是需要做什么呢？应该要意识到，改变并不总是需要翻天覆地，彻彻底底的。我想要变得更具活力，更有动力，做不到也不需要今天还无心工作草草种树 200 分钟，明天就一下子能学到五六小时甚至更多。每天比昨天赖床时间短一点，起床时间早一点，开始学习的时间早一点，走神摸鱼的时间少一点，拖拉的时间短一点，学习的时间多一点，也是一种很棒的改进了。</p><p>但为什么做不到呢？我觉得是现在的自己缺乏一种勇气，一种能够坦然接受现状并寻求应对解决方法的勇气。遇到问题，处于不满意的状态，不能够坦然地接受自己就处于这种状态，以及承受接下来可能出现的后果。出现这种情况，第一时间想到的是逃避，想着明天再来，全然不想处理当天比较糟糕的开局，哪怕只是稍微起晚了一点，哪怕只是上午的学习时间没了。内心居然隐隐会觉得，在状态不好时间不足的一天学习，还不如一天都不学，或者是干一些所谓轻松点的，与任务无关的事情。</p><p>迎着糟糕的情况前进比放弃或拖延所需要承担的压力还要多，因而会使人退缩。所以现在的我会选择早上醒来晚后就多赖一会床，起床晚了后就干脆不去实验室学习，去不了实验室就干脆上午不学习，上午不学习就中午早点睡下午再努力。当事情的一点点发展得不如心意就干脆将后续的发展也跟着打乱，舍弃掉本可利用的时间资源，想的是从下个阶段再开始。但很现实的是，既然第一个阶段的开端会出现意外，那么之后的又如何担保其一定按照预期发展呢？</p><p><img src="/2021/do-nothing/1.png" alt="懂得都懂不懂都不懂的示意草图"></p><p>勇气怎么培养，我自己也不知道。不过现在的我已经不是之前那个只会接受一切的我，我相信一切都能够改变，都可以尽力去做到。改变自身性格就是一个，哪怕可能只是一点点。当以后出现这种情况的时候，直面它，接受它，应对它，战胜它。希望以后出现今天状态不好不想学习的时候，我的想法不再是等到明天状态好点再开始，而是状态不好的话我应该做些什么，应该怎么做，能做多少算多少的心态。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;对于五月假期回来后状态的复盘，其实是写于 5.14 的周记记录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经历了不太想工作的一周工作日，可能是还处在五一的假期后遗症当中，缺乏干活的动力，每天都不想起床，不想干活，但偏偏事情又感觉很多，因而会陷入一种焦虑当中，不想干，但又要干，让人很是闹心。因为不想干活导致了无意义的拖延行为，因为拖延导致不得不利用一些另外的时间来尽量补回被拖延的时间，因为额外的时间被占用了导致某些想做的事情难以完成甚至无法完成，因为做不了自己想做的事情觉得不甘心又导致因为不愿就这样结束自己的一天而自然地熬夜，因为睡得不够又导致了第二天很困起不来，更加缺乏做事的动力与决心。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="时间管理" scheme="http://scottyeung.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>dotnet 爬虫的神</title>
    <link href="http://scottyeung.top/2021/dotnet-god-of-web-crawler/"/>
    <id>http://scottyeung.top/2021/dotnet-god-of-web-crawler/</id>
    <published>2021-04-07T10:57:41.000Z</published>
    <updated>2021-04-12T07:33:46.067Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这一周干了两次需要批量下载图片或文件的自动化工作，连续两次使用都是 dotnet 来完成，着实不错，尤其是配合 c# 的 async/await 语法糖，异步下载性能确实够快。这两次的下载让我对于这种需要批量获取信息或者下载的任务解锁了新的姿势。</p><a id="more"></a><p>首先需要明确一点，我们需要的只是爬虫的结果而已，只是为了能够自动化获取我们所需要的数据或资源，所以我们所做的事情，所写的代码即使稍微 dirty 点也无妨，只要能 work 就好。尤其是在工程中，过于追求所谓的 elegant 只会让自己痛苦不已，不过这些都是题外话了。</p><p>So glad to make it dirty. 爬虫遇到例外情况时就做特殊判断，有异常就针对异常对个例单独处理，全自动化不行就手工做点操作加点信息。</p>        <h2 id="html-parsing">          <a href="#html-parsing" class="heading-link"><i class="fas fa-link"></i></a>html parsing</h2>      <p>html 的解析库用的是 <span class="exturl"><a class="exturl__link" href="https://html-agility-pack.net/">Html Agility Pack</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，可以解析字符串，也可以直接发请求获取页面来解析。其使用 XPath 作为选择器，不支持 css 选择器，学过 XPath 的可以接受，而且 XPath 的表达性足够的强，足够使用。</p><p>code sample 如下，能够根据 XPath 选出特定的节点，然后取出其中的属性和文本其实已经差不多了。</p><figure class="highlight cs"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> html =  <span class="keyword">await</span> <span class="keyword">new</span> HtmlWeb().LoadFromWebAsync(url);</span><br><span class="line"><span class="keyword">var</span> node = html.DocumentNode.SelectSingleNode(xpath);</span><br><span class="line"><span class="keyword">var</span> text = node.InnerText;</span><br><span class="line"><span class="keyword">var</span> attr = node.GetAttributeValue(<span class="string">&quot;href&quot;</span>, defaultValue);</span><br></pre></td></tr></table></div></figure>        <h2 id="download">          <a href="#download" class="heading-link"><i class="fas fa-link"></i></a>download</h2>      <p>完全就是根据 dotnet 的 API 来操作的，重点推荐 System.Net.Webclient 的 DownloadFileTaskAsync 方法，直接根据 url 开启异步下载任务，开启下载任务后将所有的 tasks 一起等待运行结束即可。<br>这里有个需要注意的点是，API 内置的 WebClient 是不支持并行的,这意味着一个 Client 发请求后必须完成任务后才能用它进行下个任务，所以需要并行的时候建议多开几个 client。</p><p>sample 如下</p><figure class="highlight cs"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tasks = <span class="keyword">new</span> List&lt;Task&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> url <span class="keyword">in</span> urls)</span><br><span class="line">&#123;</span><br><span class="line">  tasks.Add(<span class="keyword">new</span> WebClient().DownloadFileTaskAsync(<span class="keyword">new</span> Uri(url), path));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> tasks.WhenAll(tasks);</span><br></pre></td></tr></table></div></figure>        <h2 id="tricks">          <a href="#tricks" class="heading-link"><i class="fas fa-link"></i></a>tricks</h2>      <ul><li>需要下载或者访问的 urls 有时并不需要通过代码中发请求获取页面解析这样的方式来获取，很多时候直接在开发者工具里面用 XPath 来取出相应的 urls 更加简单快捷<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$x(<span class="string">&quot;//a[@id=&#x27;target node&#x27;]&quot;</span>).map(<span class="function"><span class="params">x</span>=&gt;</span>x.href)</span><br></pre></td></tr></table></div></figure></li><li>并不需要一次性就能把全部数据抓取下来，不妨合理分批分成多个任务来完成，这样 fail 一次也只需重新执行改部分，而不需要全部重来。</li></ul>        <h2 id="performance">          <a href="#performance" class="heading-link"><i class="fas fa-link"></i></a>performance</h2>      <p>性能只能说好得离谱，也可能是因为之前的 Python 爬虫给我留下太糟糕的印象作为 baseline 了。这主要得益于 dotnet 本就良好的性能，以及其支持得很好的异步编程设计，基本每个可能会阻塞的 API 都提供了 async 版本。</p><ul><li>下载了 90 posts，包括其中的文字和图片，每个 post 平均有两张图片，加起来用了一分钟左右。</li><li>下载了差不多 60 个 pdf，用来不到 20s</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一周干了两次需要批量下载图片或文件的自动化工作，连续两次使用都是 dotnet 来完成，着实不错，尤其是配合 c# 的 async/await 语法糖，异步下载性能确实够快。这两次的下载让我对于这种需要批量获取信息或者下载的任务解锁了新的姿势。&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="自动化" scheme="http://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="dotnet" scheme="http://scottyeung.top/tags/dotnet/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>如盲人走路</title>
    <link href="http://scottyeung.top/2021/like-blinds-walking/"/>
    <id>http://scottyeung.top/2021/like-blinds-walking/</id>
    <published>2021-04-06T14:35:25.000Z</published>
    <updated>2021-04-07T09:47:05.121Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对比上个学期，自感最近放了比较多的时间在练习太极拳上面，甚至还曾经自我打趣道，这个学期的工作生活重心就在练拳上面。确实是练得比较多，一方面是在杨协呆得久，需要我去带练功操，有时是必须要去，另一方面则是王真人这边也约得比较勤，一周两练，因为人少（就三个人），鸽都不好找理由鸽。当然这些都还只是外部因素，真的是不得不练，被逼着练吗？也不全见得是。</p><a id="more"></a><p>之前曾经写过<a href="/2020/taichi-practice-reflections/">博客</a>说，感觉自己练拳一直得不到进展，似乎陷入瓶颈位置，导致练习得不太畅快，继而不太想练习。不过最近这种不得劲的感觉似乎逐渐在减退，仿佛找到一些东西，开始在真正地练拳。尽管还是在练习几乎一样的东西，练习的过程还是一如既往地觉得自己很菜，但确实能够发现处处都有不同的感觉。于是近来对于练拳都有着比较高的积极性，即使是自己一个闲在宿舍，或是走在路上，都会不由自主地走走站站，或是伸展肩膀手臂，颇有将太极与练拳融入到日常生活当中的感觉。</p><p>现在的练习其实与之前差别也不是很大，功操，套路，推手，站桩，都还是这些东西。然后我自己的所谓功力，其实也没有提升多少，而且也还是能在练习中发现许多的问题，例如力量不足，例如不够放松而导致的肌肉紧张。为什么会觉得之前的不畅快感已经消失了？</p><p>大概是我开始找到练拳中的所谓<strong>感觉</strong>了。</p><p>在之前的博客或者动态当中，其实自己之前一直都在吐槽，传统的内家拳过于看重这些玄之又玄的所谓感觉，通过文字口诀来描述，需要靠练习者自己去感悟，不免太难，太过于虚无缥缈。正因为此，所以之前开始练习功操时，可以很明显地让自己出现有被锻炼到的很累的感觉，会觉得很感人，并且会将这些所谓肌肉很累很酸的感觉当成是有练到的表现。</p><p>练得很累很酸就是有练到练对了吗？我曾经问过杨协的人这个问题，然而很可惜的是，很多人都还确实只能通过这种方式来判断，有没有被练到。但事实上，练确实是有被练到，练的东西对不对就不好说，练死肌肉也可以练得很累。之前就试过一次练习步法发力推人，练完几天发现双臂酸软得抬不起，但其实只是全用了肌肉发力来推人，练到的并不是想要的东西。</p><p>前两周王真人转了一篇<span class="exturl"><a class="exturl__link" href="https://mp.weixin.qq.com/s/7RGAwdNH1TYASBSe4OI2sw">推送</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，提到“练拳要学瞎子走路”，瞎子走路身子前后都提着小心，从头到脚都有反应，练拳不是练拳头，而是全身敏感。所以在练拳的时候，感觉是应该重于一切的，一方面感受自身身体的各处状态，另一方面则是接受外界的感受。当然这个说得也很是玄妙深奥，只能看看作为参考。</p><p>上学期刚开始练拳的时候，王真人曾经跟我说过要练出掤劲，并且将其应用到身体的每一处。具体怎么练，靠站桩，练套路，和推手，来撑筋拔骨，锻炼自身。不过我上学期的我一直都感觉很迷，似乎一会出现了，一会儿又找不到了，在与其他人推手的时候，推着推着对方说有点感受到，但自己却觉得其实没有变化过。这个学期好像好了一点，似乎开始感到这种劲，体会到所说的把劲打匀到全身是种什么感觉。</p><p>上周练拳的时候，王真人问我练拳之后有没有什么收获与变化。这个问题其实我自己在寒假的时候就思考过很多次，什么还写了不少文字从身体上和信赖来进行总结。好处与收获当然是有，更健康的身体，更积极的内心，虽然可能并不足以与外人称道，也可能不太明显，不过内心还是真切感受到自己是有不同的。</p><p>想起最开始重拾练拳想法的原因，是因为想着锻炼身体，让自己变得健康。不过其实到自己真正开始练拳的时候，反而并没有了这个想法，甚至觉得其实练拳最多也不过是种锻炼方式，再怎么健康，也不过相当于多运动了。纯粹是觉得挺有意思（以及加入组织开始练习之后不好退出了。</p><p>最后再分享在知乎看到的一个很棒的评论。有个人贴出了他在武当山上面练习传统武术的经历，然后评论区中就出现了很常见的杠精，张嘴就发出传武能不能打的怀疑，什么学得不值，是被骗了之类的评价。然后答主就很坦然地回复，对于他来说，武术只是一个个人的爱好而已，像有的人喜欢跳舞，有的人喜欢打球，一定需要能打，有用，才去做，才去学吗？显然不是。</p><p>所以为什么练习太极拳，喜欢就够了。</p><p>上面提到的推送中说到练拳需要如盲人走路，在练拳过程中要注重全身的感觉。对于整个练拳的历程来说，其实需要像盲人走路一样，专注于当下走的每步路，练的每次拳，也不太需要考虑前路怎样，可以练到什么程度，可以收获什么。反正练习下去，走下去，自然能够进入新的境界。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对比上个学期，自感最近放了比较多的时间在练习太极拳上面，甚至还曾经自我打趣道，这个学期的工作生活重心就在练拳上面。确实是练得比较多，一方面是在杨协呆得久，需要我去带练功操，有时是必须要去，另一方面则是王真人这边也约得比较勤，一周两练，因为人少（就三个人），鸽都不好找理由鸽。当然这些都还只是外部因素，真的是不得不练，被逼着练吗？也不全见得是。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="太极" scheme="http://scottyeung.top/tags/%E5%A4%AA%E6%9E%81/"/>
    
      <category term="内家拳" scheme="http://scottyeung.top/tags/%E5%86%85%E5%AE%B6%E6%8B%B3/"/>
    
  </entry>
  
  <entry>
    <title>GraphQL 入门</title>
    <link href="http://scottyeung.top/2021/intro-to-GraphQL/"/>
    <id>http://scottyeung.top/2021/intro-to-GraphQL/</id>
    <published>2021-03-17T07:46:25.000Z</published>
    <updated>2021-03-19T07:00:11.966Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。</p></blockquote><a id="more"></a>        <h2 id="why-graphql">          <a href="#why-graphql" class="heading-link"><i class="fas fa-link"></i></a>Why GraphQL</h2>      <p>GraphQL 的出现主要是针对于传统的 REST API。传统的 REST API 使用资源实体的概念来划分各个数据实体，当我们需要请求数据的时候，我们往往需要发送多个请求来获取所需要的数据，一般来说，实体当中往往与其它不同类型的实体有着各样的关系。</p><p>例如我们需要展示各个用户所编写的博客文章，这需要获取博客的数据以及用户的数据。如果我们通过 REST API 获取，我们首先需要通过 <code>GET /api/posts</code> 获取所有的文章，返回的数据中就包含了文章的相关信息，如标题，内容，创建时间，以及作者的 id。根据获取的作者 id，我们需要根据每一个用户 id，发送请求 <code>GET /api/users/:id</code> 获取每个作者的信息。所以这样单一个展示页面，我们就可能需要发送大量的请求来获取数据。如果这个情况发生在需要数据现场渲染页面的网站，就比较尴尬，尤其是当网络情况较差时。</p><p>而使用 GraphQL 的话，只需要单个 Query 即可</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">    posts &#123;</span><br><span class="line">        title,</span><br><span class="line">        content,</span><br><span class="line">        tags,</span><br><span class="line">        date,</span><br><span class="line">        user &#123;</span><br><span class="line">        username,</span><br><span class="line">          avatar,</span><br><span class="line">          catchphrase,</span><br><span class="line">          favorite_dog</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>另外传统的 API 在前后端进行接口交互时，往往需要文档来进行沟通交流，通过文档上面的定义和描述，来告诉前端接口到底长什么样，可以获取怎样的数据，以及怎样获取数据。然而文档的质量参差不齐，什么经常存在信息缺失的情况，尤其是需要人工编写的接口描述~~（给你写个类型信息和返回信息都不愿意）~~。尽管有着 Swagger 这些接口文档自动生成的工具，但是还是需要后端开发者付出额外的精力来添加描述信息。而如果写 GraphQL 的话，写一个 Scheme 就可以把支持的类型及其属性都清楚地暴露出去，只要再完善一下其中的 Query 以及 Mutation 内容，即可以把 GraphQL 支持的查询和更改操作都清楚地暴露出来。这些内容都可以通过算是内置的辅助工具 <span class="exturl"><a class="exturl__link" href="https://github.com/graphql/graphiql">GraphiQL</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，进行文档的查询，以及实际的尝试。</p>        <h2 id="how">          <a href="#how" class="heading-link"><i class="fas fa-link"></i></a>How</h2>              <h3 id="to-build">          <a href="#to-build" class="heading-link"><i class="fas fa-link"></i></a>to build</h3>      <p>如何编写一个 GrahpQL 服务呢？我们首先需要定义好它的 Schema，包括其定义的类型（Type），输入类型（Input）。在 GraphQL 里面，服务能够支持的查询和更改操作，也是类型，分别是 Query 和 Mutation。</p><ul><li>Type: 每个类型由多个属性组成，每个属性包含一个名字，以及该属性字段的类型，该类型可以为基本类型（Int, String, Boolean, Float, ID），数组，或者是自定义的对象类型</li><li>Input: 输入类型也是一个 Type</li><li>Query: 表示服务支持的查询内容，每个属性表示某个 query，其类型则为返回类型，可以接收参数</li><li>Mutation: 表示服务支持的更改操作，每个属性表示操作名，需要接收输入类型的参数，其类型为返回类型</li></ul><p>以下为一个关于 todo 的 GraphQL Schema</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type TodoItem &#123;</span><br><span class="line">    id: Int!</span><br><span class="line">    title: String!</span><br><span class="line">    content: String</span><br><span class="line">    checked: Boolean!</span><br><span class="line">    createdTime: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">    todoItems: [TodoItem]</span><br><span class="line">    todoItem(id: Int!): TodoItem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">input TodoItemInput &#123;</span><br><span class="line">  title: String!</span><br><span class="line">  content: String</span><br><span class="line">  checked: Boolean!</span><br><span class="line">  createdTime: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">    createTodoItem(todo: TodoItemInput!): TodoItem</span><br><span class="line">    updateTodoItem(id: Int!, todo: TodoItemInput!): TodoItem</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="to-use">          <a href="#to-use" class="heading-link"><i class="fas fa-link"></i></a>to use</h3>      <p>怎么使用 GraphQL 服务呢？</p>        <h4 id="query">          <a href="#query" class="heading-link"><i class="fas fa-link"></i></a>Query</h4>      <p>需要查询数据时，我们只需要通过花括号把需要的类型和字段的列举出来即可。当需要传入变量，我们可以在 query 处进行定义，然后在变量处进行值传递。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  TodoItem &#123;</span><br><span class="line">    title</span><br><span class="line">    content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># or</span><br><span class="line"></span><br><span class="line">query ($id: Int!) &#123;</span><br><span class="line">  todoItem(id: $id) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h4 id="mutation">          <a href="#mutation" class="heading-link"><i class="fas fa-link"></i></a>Mutation</h4>      <p>进行数据更改时，也是类似，传入变量，调用相应的 mutation 方法即可，另外根据需要，我们还可以选择返回的属性。</p><figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mutation ($todo:TodoItemInput!)&#123;</span><br><span class="line">  createTodoItem(todo:$todo) &#123;</span><br><span class="line">    id</span><br><span class="line">    title</span><br><span class="line">    content</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># variables</span><br><span class="line">&#123;</span><br><span class="line">  &quot;todo&quot;: &#123;</span><br><span class="line">  &quot;title&quot;: &quot;asdafa&quot;,</span><br><span class="line">    &quot;content&quot;: &quot;asdaf&quot;,</span><br><span class="line">    &quot;createdTime&quot;: &quot;today&quot;,</span><br><span class="line">    &quot;checked&quot;: false</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>        <h3 id="to-implement">          <a href="#to-implement" class="heading-link"><i class="fas fa-link"></i></a>to implement</h3>      <p>怎样快速搭一个 GraphQL 服务出来呢？当然是采用动态语言最快了，而其中，又自然是选择使用 GraphQL 最多的 JavaScript 语言实现起来最快。</p><p>这里我们使用 express 来提高 http 服务，使用 express-graphql 来搭建 GraphQL 服务</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express express-graphql graphql</span><br></pre></td></tr></table></div></figure><p>然后就是一把梭地实现，首先构建 GraphQL Schema，然后搭建 http 服务，构建并绑定一个 GraphQL handler，启动服务，完。</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> &#123; graphqlHTTP &#125; = <span class="built_in">require</span>(<span class="string">&#x27;express-graphql&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> &#123; buildSchema &#125; = <span class="built_in">require</span>(<span class="string">&#x27;graphql&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> schema = buildSchema(<span class="string">``</span>) <span class="comment">// 内容省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 那个数组假装一下数据库</span></span><br><span class="line"><span class="keyword">const</span> todoItemDb = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = &#123;<span class="comment">// 这里用来存储各个 query 和 mutation 的响应函数</span></span><br><span class="line">  todoItems: <span class="function">() =&gt;</span> todoItemDb,</span><br><span class="line">  todoItem: <span class="function">(<span class="params">&#123;id&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> todo <span class="keyword">of</span> todoItemDb) &#123;</span><br><span class="line">        <span class="keyword">if</span>(todo[<span class="string">&#x27;id&#x27;</span>] == id) <span class="keyword">return</span> todo</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  createTodoItem: <span class="function">(<span class="params">&#123;todo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">      todo[<span class="string">&#x27;id&#x27;</span>] = todoItemDb.length</span><br><span class="line">      todoItemDb.push(todo)</span><br><span class="line">      <span class="built_in">console</span>.log(todo)</span><br><span class="line">      <span class="keyword">return</span> todo</span><br><span class="line">  &#125;,</span><br><span class="line">  updateTodoItem: <span class="function">(<span class="params">&#123;id, todo&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;todoItemDb.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(todoItemDb[i][<span class="string">&#x27;id&#x27;</span>]== id) &#123;</span><br><span class="line">            todo[<span class="string">&#x27;id&#x27;</span>] = id</span><br><span class="line">            todoItemDb[i] = todo</span><br><span class="line">            <span class="keyword">return</span> todo</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&#x27;/graphql&#x27;</span>, graphqlHTTP(&#123;</span><br><span class="line">  schema: schema,</span><br><span class="line">  rootValue: root,</span><br><span class="line">  graphiql: <span class="literal">true</span>,</span><br><span class="line">&#125;));</span><br><span class="line">app.listen(<span class="number">4000</span>);</span><br></pre></td></tr></table></div></figure><p>实现就这么简单 2333</p>        <h2 id="后记">          <a href="#后记" class="heading-link"><i class="fas fa-link"></i></a>后记</h2>      <p>在写这篇博客的时候，其实写到后面有点点迷茫，所谓的 GraphQL 真的是这么好吗？如果真的这么好，为什么当前主流的前后端分离，后端接口的方式还是用传统方式的类 RESTful API 的方式来设计和实现呢？</p><p>其实回过头看上面举出的例子，那些所谓的需要多次请求才获取到的数据，其实本质上也是因为后端考虑要获取多个数据，才将其整合在一起，作为一个新的独立的 endpoint 来暴露出来的。换句话，其实传统的 API 也可以做到，只需要再写一个 endpoint，专门为这个情况设置独立的 handler。</p><p>不过这种专门设置一个新的 endpoint 也未免太过不够 elegant，而且 GraphQL 对我这种还没经历过实际项目的新手来说，最大的优点，还是其自带的 GraphiQL 吧，一个带 ui 的 playground 提供给使用者来了解 API 中支持的类型，查询和变更操作，并且可以随时进行尝试，实在吸引。</p><p>所以以后如果需要到 GitHub 挖点数据的时候，不妨把请求方式从其传统的 REST API 上搬到 GraphQL 当中。这样就不需要再在命令行或者是 Postman 的方式来发请求尝试，直接在网页端界面解决。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余，也让 API 更容易地随着时间推移而演进，还能用于构建强大的开发者工具。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="JavaScript" scheme="http://scottyeung.top/tags/JavaScript/"/>
    
      <category term="API" scheme="http://scottyeung.top/tags/API/"/>
    
  </entry>
  
  <entry>
    <title>双拼使用后记</title>
    <link href="http://scottyeung.top/2021/learn-and-use-shuangpin/"/>
    <id>http://scottyeung.top/2021/learn-and-use-shuangpin/</id>
    <published>2021-02-09T04:00:22.000Z</published>
    <updated>2021-02-10T03:41:44.572Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>切换到双拼输入法一个多月了，算是掌握了双拼这个技能，现在基本上是完全使用双拼作为日常的输入方案。日常使用过程中，大问题基本没有，但是所宣传的大幅效率提升，也并不见得。不过现在用来已经顺手，应该还是会一直用下去。</p><a id="more"></a>        <h2 id="双拼简介">          <a href="#双拼简介" class="heading-link"><i class="fas fa-link"></i></a>双拼简介</h2>      <blockquote><p><span class="exturl"><a class="exturl__link" href="https://zh.wikipedia.org/wiki/%E5%8F%8C%E6%8B%BC">双拼</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>是汉语拼音输入法的一种编码方案。相对于全拼而言，使用双拼输入汉字时只需输入一个代表声母的字母，一个代表韵母的字母，就可以打出任意一个中文单字了。</p></blockquote><p>简单来讲，双拼就是通过编码的方式，将拼音当中的韵母用一个单个字母来映射，比如韵母 ang 可以用 h 来输入。通过这种方式，每个汉字的输入，都可以通过两个字母来确定，从输入的编码平均长度来看，可以说是一种更加高效的输入编码方案，每个字符的输入都只需要两个字符。</p>        <h3 id="编码方案">          <a href="#编码方案" class="heading-link"><i class="fas fa-link"></i></a>编码方案</h3>      <p>双拼的思路比较简单，关键是怎样选择一个合适的编码方案。网络上面的方案也比较多，而我这里选择的是小鹤双拼，一个使用量比较大的编码方案。这个编码方案用起来也比较趁手，符合使用习惯，值得安利给大家。</p><p><img src="/2021/learn-and-use-shuangpin/p1.png" alt></p><div style="text-align:center;color:#999;margin-top:-15px;margin-bottom:10px">小鹤双拼键位</div><p>不过微软自带的输入法还没有这个编码方案，还需要额外设置一下。微软输入法支持手动设置编码方案，所以我们可以通过控制面板中的输入法设置，添加方案，一个一个映射规则的添加上去。当然这个方法也太麻烦了，所以可以直接通过改注册表的方式来改，具体参考这个<span class="exturl"><a class="exturl__link" href="https://ifttl.com/add-flypy-to-win10-microsoft-pinyin-and-other-configuration/">博客</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>。不过在我的机器上尝试这个方法没有效果，最终还是找了一个脚本来一键修改注册表，得以成功，可以参考<span class="exturl"><a class="exturl__link" href="https://www.jianshu.com/p/ed15869e03e6">本篇文章</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，使用脚本的话就连设置选择拼音方案都不需要自己来了，直接一步到位。</p><p>至于移动端，常用的手机输入法支持的双拼编码方案基本都有小鹤编码，毫无问题。我现在使用的是 Gboard，用起来也很不错（这个输入法其实本身也很不错，值得推荐，如果不是被墙了，将会绝杀</p>        <h2 id="使用体验">          <a href="#使用体验" class="heading-link"><i class="fas fa-link"></i></a>使用体验</h2>      <p>通过将所有的输入发切换为小鹤双拼进而强迫自己使用双拼的方式，我很快就基本掌握了双拼的使用，从刚开始的时候想不起某个字某个韵母怎么打需要去查表，到现在完全可以直接一个个试/猜出来，其实还是很快上手的，就是刚开始的时候会觉得有点难受，尤其是在你跟人聊天的时候，宛如掉线一般久久不能发言，在群里发言就更加觉得插不上话了。所以我刚开始的时候还专门在手机保留了一个使用全拼的输入法，方便随时切换，转换到能够快速发言回复的状态。</p><p>总体使用下来体验，我觉得还是能够接受的，大体有以下的优缺点：</p>        <h3 id="优点">          <a href="#优点" class="heading-link"><i class="fas fa-link"></i></a>优点</h3>      <ol><li>更高的输入效率。因为双拼将多个字符的韵母映射到了单个符号，所以平均输入的字符自然降低了。这个也比较直观，例如打出一个 jiang，全拼需要需要敲五个字符，而双拼只需要敲两个字符。</li><li>更快的输入速度。因为需要输入的字符少了，按道理来说输入的速度自然会提上来，打字也应该更加快了。</li><li>更少的键盘敲击。换用机械键盘后总是觉得敲击键盘会不会吵到别人，影响到别人。使用双拼之后，敲击键盘的次数少了，再加上双拼的话有时需要想要敲的字符，不那么肯定，敲击的力度也自然表小了。</li><li>更好的设备定制。这个我是在 LUG@NJU 群看到的，说是使用双拼之后，别人就用不了你的设备打字了 2333，也确实很有道理。不过在另一方面来看，这也能算是一个缺点。</li></ol>        <h3 id="缺点">          <a href="#缺点" class="heading-link"><i class="fas fa-link"></i></a>缺点</h3>      <ol><li>经常打错。这里的错误有两个方面，一是记错编码规则，想输入的韵母与输入的字符不匹配。二则是直接拼音打错了，尤其是对我这些周期性前后鼻音不分的人来说，就 in 与 ing 我就已经不知道搞混几次了，而全拼的话打前鼻音 in 大多时候就能够直接匹配了，尤其是组词。</li><li>需要打全拼的字母或者单词的时候很麻烦。输入法中显示的是经过编码方式转换之后的拼音，所以导致看不到原输入了，这样如果我们需要打一些纯拼音，例如某人的名字拼音，就看不到自己是否打对了，是否打完了，需要记住，或者盲猜。另外，当我们需要输入单词的时候，微软输入法是可以给你直接拼个单词出来的，但是使用双拼之后，我们也看不到原来的输入，经常输错，实在难顶。（为什么不切换到英语输入呢，自然是拼不出来单词呀哈哈哈</li><li>有时打一些常用的输入简写很麻烦。例如打一些常用语，最简单的哈哈哈哈哈也要多打一倍字符 (hhhhh -&gt; hahahahaha)，又或是要输入一些姓名，需要从名字的拼音首字母，变成完整地把整个名字的拼音打出来 (yhl -&gt; yhhclb)。</li></ol><p>虽说从编码效率来看，双拼的输入效率确实应该提高，不过从个人使用的情况来看，结合上自身输入常常出现的手误，其实也没有提高多少。不过在移动端上面体验就好很多了，因为我在手机打字总是经常按错，打得越快就越容易错，而且一错就是打错一堆，换用双拼之后，因为输入少了，删除都快了。</p>        <h2 id="值得推荐">          <a href="#值得推荐" class="heading-link"><i class="fas fa-link"></i></a>值得推荐？</h2>      <p>所以双拼其实值得推荐给大家用吗？个人还是觉得可以尝试一下的，尤其是喜欢学习与尝试新事物的人来说，掌握一门新的技能，学习一个新的东西，也还是大有脾益。回想起我当时想要学习双拼的缘由，也不过是刚好看到了一篇推送，然后刚考完试，实在不想学习，找点有意思的事情做一下而已，这样坚持了一个来月，确实也收获了不少的乐趣。许多事情，其实不去亲自尝试过，就单纯靠着别人的三言两语评论，根本就无法有一个很好的了解。我知道它很好，与我做起来很好区别还是很大的。</p><p>这大概就是学习的魅力吧，我是真的喜欢学习，去学一些杂七杂八的事，去做一些感兴趣的事情。有用无用，好用与否，并不关键。<s>就如同我写这篇博文本身，导致自己的论文一直没看完，虽然良心有点过意不去，但还是很爽的。</s></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;切换到双拼输入法一个多月了，算是掌握了双拼这个技能，现在基本上是完全使用双拼作为日常的输入方案。日常使用过程中，大问题基本没有，但是所宣传的大幅效率提升，也并不见得。不过现在用来已经顺手，应该还是会一直用下去。&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="工具" scheme="http://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="输入法" scheme="http://scottyeung.top/tags/%E8%BE%93%E5%85%A5%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Find Your Sparks</title>
    <link href="http://scottyeung.top/2021/find-your-sparks/"/>
    <id>http://scottyeung.top/2021/find-your-sparks/</id>
    <published>2021-01-05T14:19:04.000Z</published>
    <updated>2021-01-05T15:17:39.332Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>看完了皮克斯的心灵奇旅（<span class="exturl"><a class="exturl__link" href="https://movie.douban.com/subject/24733428/">Soul</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>），还是挺多感慨的。昨天才看到拼多多一应届毕业生猝死，今天又看到母校有一博后跳楼。有时真的怀疑，现在的社会风气到底是出了什么问题。</p><a id="more"></a><p>Soul 中提到的故事背景为，每个人（或者说是灵魂）都需要找到自己的 spark，才能够投胎成人。这里的 spark 可以是热爱的事物，非常感兴趣的事情，主人公甚至将其当作是个人生来就要做的事情（born to do）。看似很有道理，人生就是要寻找生活的意义，为了自己的目标和理想付出一切，来追求并实现自己的 spark。然而真正抓住了这些之后，真正找寻到所谓的意义之后，接下来呢？</p><p>男主费尽一切心思，忽略了家人与身边人，放弃稳定的职位，就是为了抓住一个表演的机会，成为一个 musician。然后当他真正做到之后，在首次演出之后的晚上，他却陷入了迷茫，我看着也会感到迷茫：他热爱音乐，热爱 jazz，因此想要将音乐作为他的工作，作为他生活的绝大部分，然后他真正做到之后，他有机会可以给众多观众表演，并且作为谋生的方式，然而这样的生活以后每天都会上演，“明晚还是弹奏一样的内容”。当我们穷尽一切去追求某些事情，从而达到某个目标的时候，若真的实现了目标，甚至这个目标以后变得平凡起来，融入日常之后，它还有意义吗？去追求实现这样目标，真的有那么大的意义吗？</p><p>问题的答案也还是很简单，所谓的 spark 无非就是当下，有趣的永远是事情的本身，而不是事情的结果。生活的意义，也仅仅是生活本身，而不是要去做点什么，要取得什么成就。<br>活在当下，回归过程本身，已是老生常谈了，但真的落实到生活中每一处中，并不容易。我们往往很轻易地就被某些东西所蒙蔽住，从而忘记了生活的本质，就像现在正在准备期末考试的我，每天基本上就是复习，但复习的内容其实并不感冒，甚至自己都觉得极大概率以后用不上（如果现在学几天就能够在以后用上，那在以后要用的时候抽几天现学效果不是更好），但还是要做，要为考试做准备，尽管无趣，更无意义。</p><p>近来的我越发想去寻找生活的意义，想要真正地在生活，而不是平凡地过日子，甚至仅仅只是活着。真的非常佩服甚至羡慕身边会生活的人，能够从一样的生活当中，过出一个不一样的生活，找寻出不一样的乐趣。然而会生活这件事本身，除了需要自身对于生活的感受能力之外，这样的生活方式，还是需要一些成本的，例如时间，需要付出一些额外的时间来做一些不同的事情，又或者是金钱，某些时候花费一点小小的钱财确实可以带来更好的体验。我们是否原意付出这些代价，来更好的生活，或者说我们又是否有能力来作出交换呢？</p><p>不过也不必太过于悲观，这里的核心还是在自身的感受能力上面。拥有良好细致的感受能力，即使是在普通的日常生活中，我们仍然能够找到其中的乐趣，满怀期待地去迎接生活的到来。另外，对于改变来说，进一步有进一步的欢喜，即使是改变一点点，即使是只能改变一点点，生活就会有极大的不同出现。</p><p>热爱生活，从来不应只是一句简单的口号。希望上面的这些文字，能够帮助到大家，以及提醒自己，将注意力回归到生活本身，找寻回对于生活的热爱。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看完了皮克斯的心灵奇旅（&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://movie.douban.com/subject/24733428/&quot;&gt;Soul&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;），还是挺多感慨的。昨天才看到拼多多一应届毕业生猝死，今天又看到母校有一博后跳楼。有时真的怀疑，现在的社会风气到底是出了什么问题。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://scottyeung.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="心态" scheme="http://scottyeung.top/tags/%E5%BF%83%E6%80%81/"/>
    
  </entry>
  
  <entry>
    <title>当我们在上课时，我们在</title>
    <link href="http://scottyeung.top/2020/complaints-about-courses/"/>
    <id>http://scottyeung.top/2020/complaints-about-courses/</id>
    <published>2020-12-30T15:59:59.000Z</published>
    <updated>2021-01-05T17:12:49.158Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>某门课程的触发下，忍不住在周记记录里面写了点<strong>暴论</strong>发泄一下。<br>然而越写越觉得确实如此，实在有点可悲，也更加想要放出来倾诉一下<br><s>然而因为各种杂事加上自己的懒惰，硬是拖到了第二年才放出来，但觉得新年第一篇文章就写这种消极暴论实在不太好，于是还是改回了在 OneNote 写这篇记录的时间</s></p></blockquote><p>有时实在感到迷惑，当我们学一门课程的时候，我们到底在学什么。</p><a id="more"></a><p>首先，怎样才算是学了一门课程呢？选上某门课程并且通过，看起来就算是已经掌握了某门课程，然而，我本科期间修过的不少课程，可能还有些取到了非常不错的分数，但我自认为是没有学会这门课的，甚至某些情况，我可能什么知识都没有学到，什么收获都没有，仅仅只是拿到了学分而已。</p><p>这样的分数有什么意思，实在不明白，更不明白的是，这些反映不了什么的分数在校园生活中还有着非常大的作用，评优评奖，保研推免，出国留学，考公编制，甚至某些单位的工作都需要看你的成绩，看你的绩点，看你的排名。就这样，我们往往就要为这些没什么意义的成绩卷个你死我活。</p><p>一门课，有没有学到知识，是否掌握了其中的核心能力和方法，才是最为重要的，至于学了多少，学得好不好，这些其实都很难衡量，也是很主观的。想起大三修的软件体系结构这门课，基本上一节课都没有听过，平时也没有任何的作业，就一个期末的开卷考试，最终凭借着抄书拿到了 89 分，按照这个分数，我学到了很多东西，而事实上，我已经完全想不起来这门课讲的是什么，考的是什么。</p><p>所以分数能够说明什么呢？无非就是在某次考试或者某次展示上面拿到了好的成绩，并不一定反映了你的真实水平。当然实力足够强的人，或者是为了卷而做了足够多准备的人来说，即使是每一次考试都能拿到好的成绩。这个足够多的准备，就包含了为了考试而进行的超级全面细致的考试，包括课本或者 ppt 中一些非常细节，非常边角的内容，生怕自己遗漏了这些内容也丢了分，从而不能满绩，尽管这些知识真的很冷门，也很无用 <s>（这也是我以前经常会做的事情）</s> 。</p><p>很好奇，为什么课程的成绩不能够以是否通过来衡量呢？我学一门课，学会了，或者学到了足够的内容，就可以通过，学不会，或者没学够，就不通过。不过这样也就丢失了区分度，你学了全部，他学了一半，大家都只是通过，未免自己也会觉得有点不爽。但其实又很奇怪，为什么会不爽，区分度为什么一定要存在呢，大家都通过了这门课，又有什么问题，你比他学到了更多，掌握到更多知识，你赚了；他可能能力有限，有部分内容就是掌握不了，也可能是他只需要部分的知识，就足够他使用了，学多反而浪费。这样给个分数来增加区分度，没什么意义。</p><p><strong>为什么需要成绩来作为区分度，我觉得还是因为很少可以让自己知识或者能力真实地反映出来的机会。我学习能力比较好，知识储备比较丰富，代码能力也比较强，那又怎么样呢？没有机会展示，也没有人知道。因此，只能通过做题，通过考试，通过成绩来展示自己的能力，证明自己学得好，尽管这其实只能够证明自己拿好成绩的能力更强。但即使这样，也比什么都没有要好。</strong></p><p>另外，还有一个挺有意思的事，就是课程的先修课程。通常我们选课的时候，其实很多时候并没有关心这门课程的先修课程是什么，事实上开这门课的老师也不关注。因此在第一节课的时候，往往只是单纯列出这门课的前置课程有什么，看看大家有没有修过。<br>然而前置课程需要到一个怎么样的程度呢？仅仅修过这门课并且勉强通过的程度够不够，还是需要中等一般的水平，还是需要掌握到优秀的程度。没说，确实也不好衡量，而且往往老师认为你掌握的程度，与实际上大多数人的水平是有着挺大的落差的。<br>想起在修微机接口的时候，老师经常问的问题就是：这个东西有没有学过，在计组/计网里面的 XXX，然后下面基本都没有人可以回答上来，可能是真没学过，但更多是学过但是没有学好，或者已经忘了。</p><p>现在对于成绩的态度，说是及格就行，课程能过就行，分数没什么意义。说是这样说，但真的来个六七十分，真的不会觉得难受吗？</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;某门课程的触发下，忍不住在周记记录里面写了点&lt;strong&gt;暴论&lt;/strong&gt;发泄一下。&lt;br&gt;
然而越写越觉得确实如此，实在有点可悲，也更加想要放出来倾诉一下&lt;br&gt;
&lt;s&gt;然而因为各种杂事加上自己的懒惰，硬是拖到了第二年才放出来，但觉得新年第一篇文章就写这种消极暴论实在不太好，于是还是改回了在 OneNote 写这篇记录的时间&lt;/s&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有时实在感到迷惑，当我们学一门课程的时候，我们到底在学什么。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="学习" scheme="http://scottyeung.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>非主流下的少数选择</title>
    <link href="http://scottyeung.top/2020/minority-under-mainstream/"/>
    <id>http://scottyeung.top/2020/minority-under-mainstream/</id>
    <published>2020-12-13T11:52:23.000Z</published>
    <updated>2020-12-14T03:29:26.481Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>又再因为环境的差异，因为所使用的操作系统与主流，或者说是大多数人用的不一样，导致额外浪费了不少的时间，尽管最终还是解决了，但内心很是不爽，在这期间还无数次诞生出了重装环境，换个发行版系统的念头，不过考虑到近段时间实在太忙，没时间配置新的系统环境而放弃。话虽如此，新的系统的镜像我已经下好几个了，实在忍不住了，或者是有时间之后，估计马上就会换掉。</p><a id="more"></a><p>这大概就是使用一些非主流环境和工具所需要付出的最大成本了。这里的非主流，也并不是说所使用的东西很是冷门，没什么人用，更多指的是，在某种使用场景或情况下面，它不是绝大多数人使用的解决方案，也不是官方推荐的方案。因为不是官方推荐，导致文档里面缺失方法步骤，因为它不是绝大多数人的选择，所以我们在搜索问题时能看到的大家出现的问题，其发生的环境都与我们不一样，自然给出的解决方法也不能应用到我们的环境上面。</p><p>以刚遇到的问题为例，我想要在 docker 里面开启 GPU 支持，但是拉下 cuda 的 docker 镜像后使用 <code>--gpus</code> 的参数却报错了。把错误提示到网上一搜，首页几乎全是一样的错误，然而这些错误发生的环境都是在 ubuntu 当中，给出的解决方法全都需要用到 debian 系的包管理工具 apt，使用 pacman 的 arch 系 Linux 提供自然用不了这些解决方法。即使在搜索框前加上系统的关键词 arch/manjaro，出现的搜索结果仍然还是这些 ubuntu 上的错误。难道说就没有人在 manjaro/arch linux 上面出现过这样的问题吗？这怎么可能？</p><p>参考了一下 ubuntu 上面的解决方法，似乎需要下个 nvidia-container-toolkit 的包。在搜到的官方文档看了一下，给出的安装方式就是没有 arch 系的环境。到 pacman 安装试了一下，没有，发现似乎有用户在 aur 传了相关的包了，yay 试了一次，构建的过程中链接出问题了，构建失败。最终在 yay 试了几个包后才下好，暂时解决了问题。</p><p>明明就是一个很简单的问题，就因为环境的差异，找不到在该环境下面的解决方案，导致额外付出了精力与时间。当然这次算是运气比较好，最终解决了问题，但如果问题解决不了，就真的只能够自己无能狂怒了。在这个过程中，自己也无数次懊悔过为啥要选择 Manjaro，不老老实实选一个最多人选择的 Linux 系统环境。现在选择成为少数，自然要为其付出相应的时间和精力成本。</p><p>即便如此，仍然还是会有很多人选择成为这少数，也包括我。当时为什么会做出这个选择，选择成为少数呢？</p><p>主流很多时候能够成为主流，并不是因为它有多好，更多的只是因为它抓住了某个机会，抢占了绝大多数的用户和市场，而它一旦有了规模效应之后，就能够非常容易地吸收到绝大多数用户的加入这个选择，反向地壮大这个群体。因为绝大多数用户都是 Ubuntu 用户，因此它们所写的教程和资料自然都是在 Ubuntu 环境上的相关内容，作为一个新用户，自然更倾向于加入 Ubuntu 阵营。尤其是在中文互联网社区，百度搜索总是会给你返回在某所谓技术社区上面的大批相似文章。当然这里也不是说 Ubuntu 不好，只是<strong>我们能不能多点选择，对各种选择，各个方向更加友好点，从而让互联网社区更加友好呢？</strong> 为此，某些时候我更加倾向于所谓少数的选择，也算是一种支持，在某些时候，它们也能够给到我一些惊喜。尽管很多时候我自己也坚持不了，就比如 Chrome，先后转到 Edge 和 Firefox，还是忍不住要回来。</p><p>互联网自由开放的特点，一直都是我比较推崇和向往的。但现在的现象却是比较诡异的，不够自由，开放不足。各家互联网公司的画地为牢，把用户死死地圈在自己的一亩三分地里面，生怕用户和流量的流失，越垄断，越强大，越强大，就越有垄断的实力，不到你不屈服。最近就有一个被点名的现象：互联网企业下场到社区里的生鲜零售，通过超低价格和超高的补贴来占领市场，企图重现一次打车和外卖行业的现象。幸好很快就被大家意识到，官方也下场点名了资本了。</p><p>有实力的公司或者软件，逐渐成为主流难以避免，即使进化到垄断，也不足为奇。我们又能够做些什么呢？我们能不能给予更多的机会给不同的选择，尤其是处于弱势的选择呢？给多一点支持，多一次的尝试，可能就会有不一样的情况出现。然而在处于各种因为并非主流选择带来的不方便情况下，我们又可以坚持多久这些选择，不向主流投靠呢？</p><p>不管怎样，起码我也是坚持过了，而你呢？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又再因为环境的差异，因为所使用的操作系统与主流，或者说是大多数人用的不一样，导致额外浪费了不少的时间，尽管最终还是解决了，但内心很是不爽，在这期间还无数次诞生出了重装环境，换个发行版系统的念头，不过考虑到近段时间实在太忙，没时间配置新的系统环境而放弃。话虽如此，新的系统的镜像我已经下好几个了，实在忍不住了，或者是有时间之后，估计马上就会换掉。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="Ubuntu" scheme="http://scottyeung.top/tags/Ubuntu/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="Manjaro" scheme="http://scottyeung.top/tags/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>近期太极练习的反思</title>
    <link href="http://scottyeung.top/2020/taichi-practice-reflections/"/>
    <id>http://scottyeung.top/2020/taichi-practice-reflections/</id>
    <published>2020-12-04T09:07:43.000Z</published>
    <updated>2021-04-06T14:37:03.482Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>从十月份开始练太极拳至今，已经差不多两个月了。在这个期间，基本每周会去练两三次，晚上九点跑去恩玲剧场练习松柔功操，周四跑去武术馆练练拳架套路。虽然感觉上已经练得很多，但实际上投入的时间也不算多。</p><p>兴趣确实是有的，收获也似乎算有，用王真人的话来说，也是有一点功力的，算是有点劲出来了。</p><a id="more"></a><p>然而在这两周的练习中，却感觉到自己好像已经进入到一个瓶颈期，感觉自己练了也有一段时间了，但是没什么长进，尤其是在功操上面。</p><p>当初第一次练松柔功操的时候，因为里面有着比较多的会锻炼到下半身一些不太常用的肌肉群的动作（比如揉膝，蹲坐等集中在下盘的动作），而且强调身体其它地方放松，只靠特定的肌肉群出力，因而特别酸爽。第一次练完，就跟健身练完腿差不多，酸软无力，抬不起来的感觉。</p><p>可惜的是，直到现在的我，也依然会在练习几个揉膝动作后感到大腿酸软，而其余的动作，也依然在练习时有着比较强烈的感觉，让我感觉到自己其实并没有长进，并没有提升。至于其它的套路，站桩，因为太过于强调劲，强调感觉，也太过难以捉摸，这次好像有点感觉，下次同样的动作，同样的打法，却找不回来了。套路动作是学到了，而是否打对了，是否打得更好了，自己也不知道。</p><p>虽说只是为了兴趣在练习太极拳，但是如果一直这样练都还是这个水平，一直都没什么长进的话，其实自己内心也不太舒服，练习也练得没什么干劲。当然练习时间确实不长，每周最多也就三四小时，加起来可能就一两次机会练习，较大的提升自然不容易出现。但我也确实时间不多，虽说晚上去练拳可能也就练个一个小时多点，但是练拳前准备，练拳后的洗浴休息，前前后后可能需要花费自己三个小时的学习时间，作为一个懒散的人来说，代价其实挺大，因为本来的学习时间就不多。</p><p>这也似乎陷入了一个不好的循环，时间不多导致选择去练拳的时间不多，练拳的时间不多自然效果不好进展缓慢，效果不好导致自己练拳的时候找不到感觉，兴趣消减，逐渐就更加不想去练拳，通过自己时间不同的事实作为借口来逃避练拳。这导致我已经一个星期没去练松柔功操了🤣。接下来一个月估计更加忙，可能练习次数更少（逃</p><p>要逼着自己先去练了再说吗？这样就似乎感觉违背自己所谓兴趣的性质了。其实更希望能够将太极，将练拳融入生活当中，时不时就站起来打打拳，站站桩，甚至在平时的生活活动里面，融入一些动作，进行锻炼。然而这样的行为在他人眼中实在有点奇怪，尤其是对于我这种性格的人，总是害怕在他人面前表现自己，羞于被他人看到我在干什么，即使是无意的。</p><p>离这个学期结束还剩一个月，希望自己能够剩下的拳架套路学完吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从十月份开始练太极拳至今，已经差不多两个月了。在这个期间，基本每周会去练两三次，晚上九点跑去恩玲剧场练习松柔功操，周四跑去武术馆练练拳架套路。虽然感觉上已经练得很多，但实际上投入的时间也不算多。&lt;/p&gt;
&lt;p&gt;兴趣确实是有的，收获也似乎算有，用王真人的话来说，也是有一点功力的，算是有点劲出来了。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="太极" scheme="http://scottyeung.top/tags/%E5%A4%AA%E6%9E%81/"/>
    
      <category term="内家拳" scheme="http://scottyeung.top/tags/%E5%86%85%E5%AE%B6%E6%8B%B3/"/>
    
  </entry>
  
  <entry>
    <title>记第一次把系统搞挂掉</title>
    <link href="http://scottyeung.top/2020/broke-up-the-os/"/>
    <id>http://scottyeung.top/2020/broke-up-the-os/</id>
    <published>2020-11-08T14:46:18.000Z</published>
    <updated>2020-11-08T15:32:55.712Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>高度的自由有时就意味着高度的脆弱性。</strong></p><p>今天就因为更换显卡驱动的原因把我实验室的机器给搞挂了，导致无法进入系统。</p><a id="more"></a><p>在实验室的机器到位之后，基本上我就逐步把工作环境迁移到实验室的机器上面，装了一个 Manjaro 系统，来感受一下滚动升级的爽快（<s>遇坑</s>）体验。系统采用的是 KDE 桌面，相关的工具环境都已经搞得七七八八了（到时写个文章来讲讲我是咋样在多终端同步工作<s>挣扎</s>的），在日常的工作和娱乐使用上面，基本已经没什么问题。</p><p>不过最近发现一个问题（bug），就是设备总是会在停止使用一段时间后，界面变色闪烁并且卡死。在忍受几次因卡死不得不重启之后，终于打算上网搜搜解决方法（感谢 vscode 与 typora 等软件的自动保存功能以及坚果云的自动同步让我即使卡死重启也没有丢失数据资料）。网上大多数人说是显卡驱动问题，我就跟着看到的其中一个回答的建议进行操作，把我所装的显卡驱动换成了另一个版本。看上去已经解决了。</p><p>然后出去打个水回来，发现机器又再次卡死了，然而这次重启，却已经启动不了。提示</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Failed to start! Load kernel modules</span><br><span class="line">Failed to start! Load kernel modules</span><br></pre></td></tr></table></div></figure><p>当时的第一反应居然不是感到很慌，而是在想上午计划的任务做不完了，也是好笑。虽然这是第一次遇到这种状况，而且当时的我还没找到原因，但居然觉得这好像是习以为常的小事，可能这就是 <strong>Linux User Group 成员的觉悟</strong>吧。因为当时没带电脑，就用手机上网搜了搜相关问题，发现好像是刚刚更换的显卡驱动出问题了，把它换回来应该就没问题了吧。</p><p>那怎么更换显卡驱动，把新装的删掉，把旧的重新装回来呢？首先需要进入 bash。又怎样进入 bash 呢？网上说的 tty 我也进入不了，只能通过启动 U 盘（Live USB）进入系统然后加载本机环境。所以不得不跑回宿舍重新刻录一个启动盘，顺便睡了个午觉。</p><p>拿到启动 U 盘之后就比较简单了，直接通过 U 盘进入 U 盘的系统，然后在里面开终端通过 chroot 命令改到硬盘中的系统执行环境，然后把驱动换回来。（说起来很简单，但事实上这几个步骤以及当中的细节，我重复组合尝试了好几次才好起来了。主要操作为</p><figure class="highlight shell"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">manjaro-chroot -a # 根据硬盘安装的系统进行挂载等操作，来切换到硬盘中系统的 bash 环境</span><br><span class="line"></span><br><span class="line">sudo mhwd -li # 列出安装的驱动，</span><br><span class="line">sudo mhwd -r driver-to-delete # 显卡驱动全删了</span><br><span class="line">sudo mhwd -i pci nonfree 0300 # 自适应安装一个闭源的显卡驱动</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新升级所有的 package，这一步感觉挺莫名其妙的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 大概是需要更加内核和引导文件以适配驱动文件？</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里几乎把所有的 package 都重新安装了（因为这样导致我第一次不敢尝试又重启多了几次</span></span><br><span class="line">sudo pacman -Syyu </span><br></pre></td></tr></table></div></figure><p>现在回顾起来感觉修复好像也还挺简单的，然而当时却搞了我两个多小时。在这次问题之后，重新打开了我里面的备份软件 timeshift，还是有在每天备份快照的（意外发现今天的升级把系统也升了一个小版本号），这也让我萌生出了一种<s>豪气</s>错觉：</p><p><strong>只要给我一个 Live USB 让我进去 terminal，啥问题都好像可以解决。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;高度的自由有时就意味着高度的脆弱性。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;今天就因为更换显卡驱动的原因把我实验室的机器给搞挂了，导致无法进入系统。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="Manjaro" scheme="http://scottyeung.top/tags/Manjaro/"/>
    
  </entry>
  
  <entry>
    <title>又一次的漫画爬取</title>
    <link href="http://scottyeung.top/2020/crawl-commic-again/"/>
    <id>http://scottyeung.top/2020/crawl-commic-again/</id>
    <published>2020-10-08T03:54:28.000Z</published>
    <updated>2021-03-14T10:55:09.718Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script>        <h2 id="背景">          <a href="#背景" class="heading-link"><i class="fas fa-link"></i></a>背景</h2>      <p>最近刚开始追了一部 b 站的<span class="exturl"><a class="exturl__link" href="https://www.bilibili.com/bangumi/play/ss34230">新番</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，觉得挺有意思，就打算看看它的漫画，但这漫画也是某站独家，不太想花钱，就打算上网找点资源白嫖（当然大家还是要支持正版的！我是已经支持太多了想省一省 <span class="github-emoji" alias="joy" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span>)。然而网上找到的资源太少，且大多已经不可用，唯一找到的一个可以看的网站，图片质量太高，加载太慢，而且它的加载方式也很离谱，每一话在一个页面直接丢给你十几二十张图片，而且也没有 lazy load, 全部图片一起加载，体验极差。</p><p>所以没有办法，只能重操旧业，把它爬下来，免去了阅读过程中的等待时间。（对上一次的爬取可以<a href="https://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/">看此</a>）</p><a id="more"></a>        <h2 id="爬取思路">          <a href="#爬取思路" class="heading-link"><i class="fas fa-link"></i></a>爬取思路</h2>      <p>在漫画页的路径规则非常统一，都是那种 <code>http://host/:type/:commic-name/:chapter.html</code>, 直接根据规则生成 url 就行了。</p><p>打开开发者工具看了看页面的文档具体内容，发现漫画图片就直接硬编码嵌入在 <code>table tr td img</code> 中，而且每个图片还直接给了个形如 <code>img2</code> 这样的唯一的 id，XPath 都不需要思考怎么写了，直接 <code>//*[starts-with(@id,'img')]</code> 就可了。于是马上拿出 C# 写了一个函数，解析出单话的所有图片链接，然后下载。</p><p>然而发现 xpath 居然找不出了目标元素，一开始还以为是我的 XPath 写得有问题，换了几种写法都不行，看了看获取到的 html 文档全文，才发现这个页面是靠导入 Javascript 脚本，动态插入 DOM 节点来生成完整页面的，所以普通的静态爬取文档方法无效。对这种动态的页面，要么用模拟浏览器，等待它加载执行完 js, 再来解析页面元素，要么就直接深入它动态操作页面的 Javascript 脚本，直接从源头来找数据。因为我算是对 JavaScript 有点熟悉，而且爬虫等待页面加载完再解析页面，性能开销也未免太大（而且 C# 我也不太知道有啥可以像 Python 中的 Selenium 可以模拟浏览器操作的），于是就看了看它导入的一些 js 文件，居然还发现了它所使用的一份来自 2011 年的历史遗留 js 代码。</p><p><img src="/2020/crawl-commic-again/1.png" alt></p><p>在现在的角度来看这份代码，简直就是灾难。</p><ul><li>随意地在随处定义全局变量</li><li>使用匿名对象的成员来封装函数</li><li>随心所欲的变量命名：<ul><li>大量的 a, aa, bb, ll 无意义命名</li><li>英语拼音混杂看不出意义的代码</li></ul></li><li>字符串拼接硬编码组成的待插入 html 标签</li></ul><p>还好有 IDE, 能够有变量搜索和函数跳转，大概的功能还是看出来了：加载文档时调用一个初始化方法，初始化方法根据一个图片的路径变量，生成一系列的 img 标签，插入到 html 文档里面。</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">imgload:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a,b;</span><br><span class="line">  b=<span class="string">&quot;&quot;</span>;</span><br><span class="line">  a=qTcms_S_m_murl.split(<span class="string">&quot;$qingtiandy$&quot;</span>);</span><br><span class="line">  qTcms_page.Pic._arr=a;</span><br><span class="line">  qTcms_page.total=a.length;</span><br><span class="line">  <span class="keyword">var</span> ll1=a.length;</span><br><span class="line">  <span class="keyword">var</span> ll=<span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span>(ll&gt;ll1)ll=ll1;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;ll;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> srcid=<span class="string">&#x27;img&#x27;</span>+(i+<span class="number">1</span>);</span><br><span class="line">    qTcms_page.curpage=(i+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> bb=a[i];</span><br><span class="line">    <span class="keyword">var</span> cc=f_qTcms_Pic_curUrl_realpic(bb);</span><br><span class="line">    <span class="keyword">var</span> limg1=<span class="string">&quot;/statics/images/pic_loading.gif&quot;</span>;</span><br><span class="line">    $(<span class="string">&quot;#qTcms_Pic_middle tr td&quot;</span>).append(<span class="string">&#x27;&lt;div&gt;&lt;img class=&quot;comic_img&quot; src=&quot;&#x27;</span>+cc+<span class="string">&#x27;&quot; data-original=&quot;&#x27;</span>+cc+<span class="string">&#x27;&quot; id=&quot;&#x27;</span>+srcid+<span class="string">&#x27;&quot; style=&quot;display: inline;cursor: zoom-in;&quot; onclick=&quot;qTcms_page.relpic(\&#x27;&#x27;</span>+cc+<span class="string">&#x27;\&#x27;,\&#x27;&#x27;</span>+srcid+<span class="string">&#x27;\&#x27;)&quot;&gt;&lt;/div&gt;&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>但是这个变量 <code>qTcms_S_m_murl</code> 我怎么找都没找到它在哪里定义的，用倒是到处都在用，找了几个其它的 js 文件也没有找到，后来发现这居然是在原始的 html 文档直接给出的，原始 html 文档给了一个经过 base64 编码的所有图片链接地址作为一个全局变量，然后导入的 js 文件将该变量中的地址解码再分别取出每个图片的地址，生成 img 标签并插入到源文档中。</p><p>发现了它的这个方式之后，工作就很简单了，直接从原 html 文档中找出这个编码后的图片地址合集，解码后分别下载这些图片保存。</p>        <h2 id="实现">          <a href="#实现" class="heading-link"><i class="fas fa-link"></i></a>实现</h2>      <p>这次我选择了用 C# on dotnet core 来实现爬虫任务。按照上面的思路，具体的实现方式也很简单：</p><ol start="0"><li>根据要下载的漫画章节号，生成它的 url</li><li>发个 Get 请求获取这一话漫画的 html 文档，通过正则获取其中编码后的图片链接合集</li><li>对于图片链接中的每个图片链接，使用自带的 WebClient.DownloadFileAsync 方法直接下载图片文件到本地</li><li>然后就是统筹整个下载任务，逐话下载，每话分别获取图片链接，创建文件夹，下载所有漫画图片</li></ol><p>这里必须赞一句 dotnet core 对于异步编程的支持，着实做得太好了，自带的 async 和 await 关键字，以及其中用的几乎所有网络请求或者本地 IO 的方法，都给出了异步版本的实现，可以很容易地就实现异步编程，而这种基本是完全交由编译器去处理多线程的调度处理方式，所实现的效果我觉得是比我自己简单地开几个线程分别跑任务的部分是高效得多的。</p>        <h2 id="结果">          <a href="#结果" class="heading-link"><i class="fas fa-link"></i></a>结果</h2>      <p>这个 C# 的实现效率确实太强了，我尝试性下载了一话，二十来张图片，加起来四十多兆，十来秒就下载完了。下载前 80 话漫画，共 1.8G 的图片，总共也就用了 17 分钟，太快了！尤其是对比上一次的下载，下一话居然需要一两分钟，下载了不到一百话就用了两三个小时。当然这里面还有很多因素影响，而且上次的代码的异步编程实现也实现得很糟糕。</p><p>不过还是不妨碍我吹一句：<strong>我们 dotnet 真是太强啦！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;背景&quot;&gt;
          &lt;a href=&quot;#背景&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;背景&lt;/h2&gt;
      
&lt;p&gt;最近刚开始追了一部 b 站的&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://www.bilibili.com/bangumi/play/ss34230&quot;&gt;新番&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;，觉得挺有意思，就打算看看它的漫画，但这漫画也是某站独家，不太想花钱，就打算上网找点资源白嫖（当然大家还是要支持正版的！我是已经支持太多了想省一省 &lt;span class=&quot;github-emoji&quot; alias=&quot;joy&quot; style fallback-src=&quot;https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8&quot;&gt;😂&lt;/span&gt;)。然而网上找到的资源太少，且大多已经不可用，唯一找到的一个可以看的网站，图片质量太高，加载太慢，而且它的加载方式也很离谱，每一话在一个页面直接丢给你十几二十张图片，而且也没有 lazy load, 全部图片一起加载，体验极差。&lt;/p&gt;
&lt;p&gt;所以没有办法，只能重操旧业，把它爬下来，免去了阅读过程中的等待时间。（对上一次的爬取可以&lt;a href=&quot;https://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/&quot;&gt;看此&lt;/a&gt;）&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C#" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="dotnet" scheme="http://scottyeung.top/tags/dotnet/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="异步编程" scheme="http://scottyeung.top/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>对知行合一的一些想法</title>
    <link href="http://scottyeung.top/2020/knowledge-as-action/"/>
    <id>http://scottyeung.top/2020/knowledge-as-action/</id>
    <published>2020-10-03T05:49:25.000Z</published>
    <updated>2020-10-03T11:53:46.057Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨天无意中看到了一个关于王阳明心学的回答，谈到了其中心学的精髓是什么，觉得挺有意思，就在晚上的时候重新认真地翻了翻这个问题，并且将其中的高赞回答摘录到了印象笔记中细细品味： <span class="exturl"><a class="exturl__link" href="https://www.zhihu.com/question/28052564/answer/1282463260">王阳明的心学精髓是什么? - 知乎</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，也算是有点收获，对于一直以来都觉得非常神奇，也非常向往的陆王心学有了更深的了解。</p><a id="more"></a><p>心学到底是什么？我对其的最主要印象，莫过于当中最为有名的一个信条——知行合一。什么是知行合一，按照字面理解，就是自己的认知，应该与自己的行为相符合一致，怎么想的，就应该要怎么做。这也是我个人对其比较浅显的理解。我对其的了解其实也不算深，大部分好像还是来源于以前初中的历史？ Anyway, 我还是很向往，很佩服这种状态的。知行合一，让自己的行为能够跟上自己的认知，而我现在，或者一直以来的一个很大的问题，就是行为跟不上认知，想得太多，做得太少。</p><p>在初三准备中考的时候，曾经某次跟金鱼闲聊就聊到过，我们很多时候并不是不知道怎样才能学好，怎样才能取得一个好的成绩，学习又有什么难的，每节课认真听课，每晚晚修认真完成作业并按时复习预习，周末回家也保持着完成作业和练习等各种学习任务，学得好自然是顺理成章的。但真的这么简单吗？不是，原因在于我们很多时候都并不能做到这些事情。想起来，计划起来确实简单，但做起来，并坚持做，太难了。</p><p>到了现在，缺少了一些外部环境的约束，以及一些比较紧迫近期的目标推动，自己的行为就更加缺少动力了。想法确实是充满雄心壮志，但是想法最终也只是想法，远远未达到实现的程度。好比最近的我，作业很多，任务很多，也想了一下计划来完成，每天列的 todo 也充满干劲，然而最后每天也并没有完成多少的任务，内心反而充满愧疚与负罪感。</p><p>所以我向往这种知行合一的状态，我也想能够找到方法进入这样的境界，能够让我的行动跟上我的想法。当然，因为弱鸡的行动力，加上其它各种杂事缠身，最终也还是不了了之。不过昨晚看到的这一篇回答，或许就是一个转机？</p><p>所以知行合一到底是什么？文章虽然很长，举了一大堆的例子和背景铺垫，但是核心还是那几样：</p><ul><li>知：当我们遇到某一个特定的状况，情景，问题时会自然而然地出现的感觉，潜意识，认知。</li><li>行：就是我们对于这个特定的状况，情景，问题所做出的（应对）行为</li><li>知行合一：我们遇到特定状况时，会自动根据出现的感觉，做出相应的行为</li></ul><p>所以，实质上，知行合一就是一个<strong>一一对应</strong>的的思维模型，也就是行为规律，遇到什么样的问题，在怎样的情况下，会怎么做。那知怎么来呢？</p><blockquote><p><strong>知不来自于你的意识，而是来自于你上一次对这个媒介做出的行。</strong></p><p>一个人出现在你面前，你一眼看到，一瞬间给你的感觉来自之前，每个人都是，每个人都不一样，都是独一无二的媒介。那这个之前，是哪一次呢？刚认识？还是哪次出去玩的时候？可是生物本能来说，一瞬间的事儿，哪可能给你选啊，这不是你用意识能选的东西。只能来自上一次。可能是上次他的行为给你留下的印象，也可能是上次他出现在你脑海里你对他的想法，总之是来自上次，不是上上次，也不是上上上次，只能是上一次。这一瞬间的感觉，决定了你对他的态度。<br>这次用这种方式做一件事，下次你还是首先想起来用这种方式。做过的事情再做觉得很简单，没做过的就觉得很复杂不想去做。因为做过的，在你的脑子里有对应的知了，每一步下意识就能完成。</p><p>因此，我们可以通过对问题做出不同的行为，来修正我们此前的知，来不断替换已有的知。<br>通过不断的替代，一个人给你的印象，也会随之变来变去。假如你通过靠谱渠道听说了一个之前和蔼的亲戚原来是个凶险的逃犯，你下次面对他，还觉得他是那个和蔼的人吗？不要说你因为害怕会装作不知道，我说的是你心里对他的感觉。</p></blockquote><p>总结下来，所谓的知行合一，关键点还是在知，**这里的知，是所谓的感觉，是一种出离于意识，与思维无关的感觉，这样的感觉，会决定个人的想法和行为。**而感觉又会被不同的行所积累，修正，甚至是替换。 我们能够做些什么来好好贯彻知行合一，或者说利用好知行合一呢？翻了翻文章本身的评论，并结合我所理解的文章本身，大概可以有几个方向：</p><ul><li><p>多尝试不同的行。尽可能多地尝试不同方向，不同领域的事情，通过一些活动或行为，积累自己在各个方面的感觉/经验，让自己能够在不经意间积累到将来可能会用到的知。</p></li><li><p>只有行，才能改变个人的知，才能取代以往的可能有瑕疵的知。所以我在培养习惯，或者指定计划的时候，最重要的还是首先让自己开始起来，让自己进入状态，进入计划。就像早起，即使在脑海中再怎样强调自己早起的各种好处，强迫自己一定要早起，但该起不来还是起不来，该不想起还是会不想起。还不如直接就通过一些别的手段，让自己强制起来，在意识到好像早起其实也没有那么难/早起好像还挺爽的。</p></li><li><p>良知很重要。正确的感觉很重要，所以我们应该尽可能地在最开始的时候就选择正确的行为，培养正确的感觉</p><blockquote><p>一些错误的“行”，会导致自身不合适的“知”，近而导致自身出现不合适的潜意识，所以我们在平时的时候，也要注意慎独，如果一件事情是不合适的，那么我们从一开始就不要做，可能我们会觉得一次两次没什么大不了的，但是会影响一个人的以后对此事物的看法，从而千里之堤溃于蚁穴，最终出现严重的后果。</p></blockquote></li></ul><p>在写本文的时候多次回看他人的回答和评论，越看越觉得自己的认识实在浅薄。确实需要多花点时间再好好探索一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨天无意中看到了一个关于王阳明心学的回答，谈到了其中心学的精髓是什么，觉得挺有意思，就在晚上的时候重新认真地翻了翻这个问题，并且将其中的高赞回答摘录到了印象笔记中细细品味： &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://www.zhihu.com/question/28052564/answer/1282463260&quot;&gt;王阳明的心学精髓是什么? - 知乎&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;，也算是有点收获，对于一直以来都觉得非常神奇，也非常向往的陆王心学有了更深的了解。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="心学" scheme="http://scottyeung.top/tags/%E5%BF%83%E5%AD%A6/"/>
    
      <category term="知行合一" scheme="http://scottyeung.top/tags/%E7%9F%A5%E8%A1%8C%E5%90%88%E4%B8%80/"/>
    
  </entry>
  
  <entry>
    <title>总是感觉自己很忙</title>
    <link href="http://scottyeung.top/2020/looks-so-busy/"/>
    <id>http://scottyeung.top/2020/looks-so-busy/</id>
    <published>2020-09-26T13:00:00.000Z</published>
    <updated>2021-01-25T02:55:37.745Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从上了大学之后，总是感觉自己莫名地很忙，但你要说真的有很多事情做吗？也不是，起码就不是那种忙到说基本没有空闲时间的那种程度。然而还是感觉很忙，感觉会没有空闲时间，去做一些其它的事情，因此选择了避开很多的活动与交际，即使是这样，也仅仅是维持在时间勉强够用的程度。</p><a id="more"></a><p>最近的一次报告任务就是这样的情况：上两周布置的任务，看五篇论文，然后做个 ppt 来讲一讲论文的内容。时间给的很充足，老师也没有 push. 按理说我应该能够早早地完成阅读任务，从容地准备好论文报告的 ppt 和内容。但最终我却需要奋战到最后一刻：直到今天下午作报告，我中午吃饭前都还在改 ppt。虽说最终报告也还算顺利，但是自我感觉还是挺恐怖的，恐怖的点不在报告本身，而是在完成任务的过程。原本时间很宽裕的任务，随着 ddl 的逼近反而越来越赶，情绪上也是日益焦虑，时不时就会担心好像事情太多要完成不了。</p><p>为什么会出现这种情况？在前几天因午睡赖床产生的愧疚情绪下，分析了一下原因，尝试解答一下为什么自己越做事越感到时间不够用，会感到越来越忙。然后就发现自己当前状态的一个现象：</p><p>如果我有 10 分的时间，完成工作需要 6 分的时间，所以我会觉得在接到任务时觉得时间很宽裕，剩下的 4 分时间可以随意安排在其它地方，比如运动，比如社交，比如娱乐，还可以将多余的时间作为后备，以防突发情况的出现。但实际上，当我在完成这个工作的时候，虽然我只需要 6 分的时间就能够完成，但是我在开始工作之前，或者工作之间的休息时间，总会拖延，或者是干一些不太相关的杂事，总是会花费一些额外的时间。因为完成工作所需要的 6 分时间，一般来说都是比较大块的时间，会选择分开成在一周的几天来完成，那这些拖延，便随之分布在各个小的工作时间之前或之后，聚少成多。完成工作只需要 6 分，但是全部拖延的时间，浪费的时间，加起来就可能有 2 分了。也就是说，完成这个任务实质上用了 8 分的时间。</p><p>因为工作用到了 8 分的时间，变相就挤压了原本存在的空闲时间，所以随着工作的推进，原本存在的空闲时间越来越少，自然就感觉越来越忙了。然后因为剩下的时间少了，对于完成不了的焦虑就更加多了。对于这些空闲时间，也不敢随便使用了，有什么活动不敢参加，有什么事情也不敢尝试，甚至某些人际交往，我也会可免则免，尽量避免。所以会给到别人一种很忙的感觉，自己也会这样觉得，我真的很忙，我没时间干别的事情了。</p><p>这样的状态对于我还是影响很大的，日常焦虑，日常担心，害怕事情不能按照预期正常完成。因为害怕，所以总会有意无意地拒绝了很多可能的发生，因此也错过了不少的机会，在竞赛上，科研上，交往上。对于我的本科生活，常常会感到遗憾，遗憾没有取得更多的成果，遗憾日子过得过于平淡，尽管我也是甘于平淡的人，也并不会对这样的生活觉得枯燥厌倦，但是如果我不那么的“忙”，是不是就会有着更多的可能呢？</p><p>尽管因为拖延这种习惯，让我一直都有一种很是忙碌的感觉，但在大四保研之后，可用的时间一下子大增，尽管还是拖延，需要 6 分时间的任务还是会拖到要用 8 分来完成，总是整体可用的时间却从 10 分变成了 20 分，于是好好地体验了一把时间充足的空闲状态是怎样的。在保研后的一年中，因为所谓变“闲”的状态，我也做出了不少的改变和尝试：</p><ul><li>加入了一些群并大量的水群（顺带练习出了朋友圈和动态等各种评论技能</li><li>通过群参加了一些线下的活动并认识到了新的朋友</li><li>大量的约饭并维系感情（尽管约来约去都还是固定那些人</li><li>与一些以前很要好的朋友重新建立并保持着联系</li><li>。。。</li></ul><p>现在研究生开学，又重新变回到忙的状态，可用时间又回到了 10 分的状态，而任务时间则可能已经不止 6 分了。开学第三个星期，已经出现了 3 proposal 作业以及一个 reading and report 的作业了。能怎么办呢？一方面拖拉的问题需要改改，提高自己做事的效率，更快地完成任务，另一方面也需要开源一下时间了，怎样从原本利用不了的地方，发掘出更多的可用时间，也是一门学问。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自从上了大学之后，总是感觉自己莫名地很忙，但你要说真的有很多事情做吗？也不是，起码就不是那种忙到说基本没有空闲时间的那种程度。然而还是感觉很忙，感觉会没有空闲时间，去做一些其它的事情，因此选择了避开很多的活动与交际，即使是这样，也仅仅是维持在时间勉强够用的程度。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="时间管理" scheme="http://scottyeung.top/tags/%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>notes on How to Read a Paper</title>
    <link href="http://scottyeung.top/2020/how-to-read-a-paper/"/>
    <id>http://scottyeung.top/2020/how-to-read-a-paper/</id>
    <published>2020-09-19T10:48:53.000Z</published>
    <updated>2020-09-19T12:18:03.351Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在本周的某门研究导引课上，被推荐了一篇讲述如何读 paper 的 <span class="exturl"><a class="exturl__link" href="http://ccr.sigcomm.org/online/files/p83-keshavA.pdf">paper</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>. 一直以来，其实我都觉得科研（research）明明是一个 skill, 但是一直都没有过方法或者课程的教授，也没有一个好的学习过程和机会。基本都是老师布置任务方向，交代看些什么 papers, 完成什么任务，就这样靠着所谓的做中学，靠着所谓的骚扰师兄师姐，大家就能突然领悟，就能够上手很好地完成科研工作，掌握科研的方法和技能。<s>而领悟不到的，就只能够解释为自己不适合科研而遗憾退场，或者当一颗科研的螺丝钉来苟活着。</s><br>当然其实基本所有的事情，都有着其自身的方法论，都能够找到相关的系统的训练（maybe</p><p>回到正题，这篇 paper 主要讲了怎样读一篇 paper，以及如何判断读到什么程度和该不该读。</p><a id="more"></a>        <h2 id="why-reading-papers">          <a href="#why-reading-papers" class="heading-link"><i class="fas fa-link"></i></a>Why reading papers?</h2>      <ul><li>reviewing papers for a conference or a class</li><li>keep current in our fields</li><li>doing survey for exploring a new field</li></ul>        <h2 id="three-pass-approach">          <a href="#three-pass-approach" class="heading-link"><i class="fas fa-link"></i></a>Three-Pass Approach</h2>      <p>本文最主要还是提出了一个分成三个阶段阅读的方法。第一阶段的阅读获取文章的大体 idea, 第二阶段的阅读获取文章的主要内容，第三个阶段则深入了解文章，获取各种 details。</p>        <h3 id="the-first-pass">          <a href="#the-first-pass" class="heading-link"><i class="fas fa-link"></i></a>The First Pass</h3>      <blockquote><p>a quick scan to get a bird’s-eye view of the paper</p></blockquote><p>第一阶段的阅读快速浏览 paper, 大概以五到十分钟的时间，了解它的大体想讲什么，从而决定后续要不要继续阅读。主要通过以下部分获取信息：</p><ol><li>仔细阅读文章的 title, sub-title, abstract 和 introduction</li><li>阅读各个章节的标题（仅标题</li><li>跳到最后仔细阅读 conclusion 部分</li><li>扫一下 references, 看看有无熟悉/看过的</li></ol><p>通过第一阶段的略读，应该能够回答以下的问题：</p><ul><li>文章的类别：本文是什么类型的文章？measurement paper, analysis of systems, description of prototype</li><li>Context: 文章属于什么领域？与什么方向相关？</li><li>正确性</li><li>contribution</li><li>写得怎么样（从行文的角度来看</li></ul><p>如果出现以下情况，就可以选择 stop 不看了:（如果不是被安排了必须完成的任务</p><ol><li>不感兴趣</li><li>没有相关的前提知识无法理解</li><li>文章存在问题</li></ol>        <h3 id="the-second-pass">          <a href="#the-second-pass" class="heading-link"><i class="fas fa-link"></i></a>The Second Pass</h3>      <p>第二阶段的阅读可以花上一个小时，对文字的主要内容作一个更加详细的了解，找到 paper 中的关键点。可以通过仔细浏览文章给出的图表入手，通过浏览图表的内容，找出它所表现的数据特征，它 support 的内容或结论，来发掘文章的关键点。</p><p>完成第二阶段的阅读后，应该能够把握到文章的内容，并且能够向他人进行本篇文章的 summarize. 如果所阅读的文章不是当前所研究方向的内容，仅是感兴趣的话，到这一阶段则可以结束阅读了。</p><p>如果结束第二阶段后还没理解一篇文章，则可能是：</p><ul><li>对该领域不熟悉，不了解这方向的名词概念</li><li>证明或实验技巧不理解</li><li>写得不行影响阅读理解</li></ul><p>对于这些情况，我们可以：不看了；读点背景材料再来看；直接跳到第三阶段</p>        <h3 id="the-third-pass">          <a href="#the-third-pass" class="heading-link"><i class="fas fa-link"></i></a>The Third Pass</h3>      <p>第三阶段则是通过解构重构的方法来读文章，通过由读者来在脑海中重新实现 paper 的方法来进行：基于作者提出的一些 assumptions，我们会怎样来写这篇文章，怎样来展示里面的工作。通过这样的方法，我们自然会对文章中的 assumptions 有着更深的了解，也自然地会去 challenge 它们。当我们自行 virtual re-implementing 之后，再与文章进行比对，查看一致与不一致的地方</p><blockquote><p>At the end of this pass, you should be able to reconstruct the entire structure of the paper from memory, as well as be able to identify its strong and weak points</p></blockquote>        <h2 id="如何综述-survey">          <a href="#如何综述-survey" class="heading-link"><i class="fas fa-link"></i></a>如何综述 / survey</h2>      <p>当我们想要了解某个领域某个小的方向时，如果能够搜到 survey 自然是最好的，但有时找不到，可以通过从相关文章中的 related works 里面去找。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在本周的某门研究导引课上，被推荐了一篇讲述如何读 paper 的 &lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;http://ccr.sigcomm.org/online/files/p83-keshavA.pdf&quot;&gt;paper&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;. 一直以来，其实我都觉得科研（research）明明是一个 skill, 但是一直都没有过方法或者课程的教授，也没有一个好的学习过程和机会。基本都是老师布置任务方向，交代看些什么 papers, 完成什么任务，就这样靠着所谓的做中学，靠着所谓的骚扰师兄师姐，大家就能突然领悟，就能够上手很好地完成科研工作，掌握科研的方法和技能。&lt;s&gt;而领悟不到的，就只能够解释为自己不适合科研而遗憾退场，或者当一颗科研的螺丝钉来苟活着。&lt;/s&gt;&lt;br&gt;
当然其实基本所有的事情，都有着其自身的方法论，都能够找到相关的系统的训练（maybe&lt;/p&gt;
&lt;p&gt;回到正题，这篇 paper 主要讲了怎样读一篇 paper，以及如何判断读到什么程度和该不该读。&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://scottyeung.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="科研" scheme="http://scottyeung.top/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="reading" scheme="http://scottyeung.top/tags/reading/"/>
    
  </entry>
  
  <entry>
    <title>生活记录杂谈</title>
    <link href="http://scottyeung.top/2020/record-of-life/"/>
    <id>http://scottyeung.top/2020/record-of-life/</id>
    <published>2020-08-30T15:31:25.000Z</published>
    <updated>2021-04-02T08:12:25.698Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>到达南京之后，基本上每个晚上都是比较早地就回到酒店，洗澡之后就瘫坐在床上看手机，看视频，很颓废，也很无趣，有一种在消磨时间，等待下一天到来的感觉，像是在浪费自己的人生。</p><a id="more"></a><p>大概是在上了大学之后，我开始变得可以接受无意义地度过某段时间，等待这一段过程的结束。以前的我明明是一个很害怕无聊的人，让我去亲戚家一个下午，即使有电脑可看，有游戏可玩，也有亲友的陪伴，我还是接受不能，感觉在浪费时间，浪费一个美好的假期。现在的我，即使是在乘坐高铁时提早了两个多小时，我也能够安然等待，在完成每周的组会报告之后，也能够心安理得地颓废一两天，美其名曰给自己放一个假。这些都是以前的自己不敢想象的。</p><p>刚刚手机刷到一个同学的同学的个人公众号推送，记录她的每周日常生活，很有意思，并不是说她的日常生活有多么精彩，多么的有意思，主要感觉是她很会抓住这种生活中的一个个有意思/有趣味的瞬间，配上简单的配图与文字，就已经让人有一种身临其境的重现。真的让人有一种是在生活的感觉。</p><p>反观我自己，如果问我近来过得怎么样，都在干些什么，我多半说不出些什么，只能简单地回一个还好，没啥，让我觉得自己仿佛在浑浑噩噩地过日子。我不禁反思，到底是我日子没有过好，还是我没有记录好生活中的各种美好，值得记录回忆的事情。大概率两者都有，而这两个方向都需要我继续努力，尝试找寻更多的生活乐趣。</p><p>原本只是因为看到了别人的推送，想简单地记录下这几天的状况，但刚开了个头，思绪就被拉回到对于过去无趣生活的愧疚，于是又写了点看似很有道理的反思文字。</p><p>希望能够改进现状。</p><p>希望希望能够实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;到达南京之后，基本上每个晚上都是比较早地就回到酒店，洗澡之后就瘫坐在床上看手机，看视频，很颓废，也很无趣，有一种在消磨时间，等待下一天到来的感觉，像是在浪费自己的人生。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://scottyeung.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>C# 爽点记录-1</title>
    <link href="http://scottyeung.top/2020/csharp-merit-1/"/>
    <id>http://scottyeung.top/2020/csharp-merit-1/</id>
    <published>2020-07-30T03:11:06.000Z</published>
    <updated>2020-07-30T03:41:17.833Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。</p><a id="more"></a><p>使用的场景为，需要对数组里面的不同元素分别进行计数，如：</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> List&lt;<span class="built_in">string</span>&gt;&#123;<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;bat&quot;</span>,<span class="string">&quot;rat&quot;</span>,<span class="string">&quot;dog&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;rat&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> count = CountEle(arr);</span><br><span class="line"><span class="comment">// should return</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   &quot;cat&quot;: 3,</span></span><br><span class="line"><span class="comment">//   &quot;bat&quot;: 1,</span></span><br><span class="line"><span class="comment">//   &quot;rat&quot;: 2,</span></span><br><span class="line"><span class="comment">//   &quot;dog&quot;: 1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></div></figure><p>最为常规的方法当然就是遍历计数了</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> word <span class="keyword">in</span> arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(result.ContainsKey(word)) result[word]++;</span><br><span class="line">      <span class="keyword">else</span> result.Add(word,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>这样的方法简单直接，但是我对于在遍历时里面还要对于是否包含元素进行一次判断，要多写一个判断，多写一个语句感到不爽，就想着搜搜有没改进的办法，像是在 Python 里面，就可以通过 setdefault 或者 get 方法来避免键值还不存在的情况。</p><p>然后发现了 Linq 的方法，起飞。Linq 的方法思路大概就是将可遍历的元素用 Sql 的方法来处理，还是挺爽挺直观的。</p><figure class="highlight csharp"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="built_in">string</span>,<span class="built_in">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="built_in">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groups = arr.GroupBy(s =&gt; s)</span><br><span class="line">      .Select(s =&gt; <span class="keyword">new</span> &#123;</span><br><span class="line">        Word =&gt; s.Key,</span><br><span class="line">        Count =&gt; s.Count()</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups.ToDictionary(s=&gt;s.Word,s=&gt;s.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>最后送上一个 Python 版本更加 tricky 的方法。</p><figure class="highlight python"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountEle = <span class="keyword">lambda</span> arr: &#123;i:arr.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">set</span>(arr)&#125;</span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C#" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="Linq" scheme="http://scottyeung.top/tags/Linq/"/>
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>稳定性与新特性</title>
    <link href="http://scottyeung.top/2020/stability-and-features/"/>
    <id>http://scottyeung.top/2020/stability-and-features/</id>
    <published>2020-07-19T02:39:31.000Z</published>
    <updated>2020-07-19T08:04:26.029Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。</p><a id="more"></a><p>以前的我，一直都不喜欢更新软件，无论是手机还是电脑。新手机拿到，第一时间就是关闭应用商店里面的自动更新，即使更新提示里面的数字到达了 99+，也完全不为所动，除非是当前版本的软件不能用了，或者是新出的版本出了一些大家都在用的现象级的新特性，我才会跟上。当时的我对于更新的印象，还是非常刻板的，觉得：</p><ul><li>更新会占硬盘 / 存储空间</li><li>更新后更吃性能导致卡顿</li><li>更新带来的新特性新功能没有多大的用途</li><li>更新带来的新交互方式设计让自己不习惯</li></ul><p>当然现在回想起来，其实这些印象还是挺可笑的，前两条现象确实存在，不过最主要还是局限于当时的手机硬件配置以及软件设计实现上面，而后两者其实还是为前面所找的理由，没有多大用途 != 没有用途，而新的交互方式设计，不深入体验过也难以获得最为真实的体验，习惯之后，可能会觉得更好。现在手机的配置上来了，我会隔一段时间就自觉地打开应用商店，批量选取软件进行更新，以往觉得会不习惯，没什么用的新特性，现在往往是我所寻找的新体验。包括电脑也是，准时更新系统以及各种软件，想要获取最好最新的体验。甚至我还想着加入 Windows Insider，想着提前试用新特性，获取新体验。</p><p><img src="/2020/stability-and-features/200719.png" alt></p><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">尽管加入了 Windows Insider，但是设备不支持也升级不了（好像有特定设备的 bug </center> <p>新特性新体验很美好，但随之而来的，还有各种各样的小问题。新的版本没有经过足够多的使用和测试，很可能就有一些莫名其妙的小问题，稳定性不够好。这也是预料之中，早早体验新版本新功能，本身也是当作一个 beta 版来测试，但是某些时候，我们真的能够接受这些稳定性不足带来的问题吗？或者说，能够接受用多少的稳定性来换取新特性呢？</p><p>新的 Windows 2004，带来了新的开始界面 UI，WSL2 以及其它的新特性，对我来说虽说不是刚需，但还是挺想体验一下的，官方通知在 5 月底的时候正式推送，但是因为设备兼容的原因，直到 7 月中还没有收到升级通知。于是就萌生出加 Windows Insider 的想法，想着加入预览版本应该能够收到升级通知，能够自动升级，当然结果就如上图，最终没有成功，我也干脆就关了 Windows Insider。</p><p>没能成功更新的原因似乎是<span class="exturl"><a class="exturl__link" href="https://support.microsoft.com/zh-cn/help/4568129/issue-with-some-storage-spaces-configurations-after-updating-to-window">磁盘管理相关问题</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>，某些设备上面分区可能会被错误识别，可能会导致数据丢失，暂时还没好的解决方法。这个 issue 是 7 月份才提出来的，之后才禁止相关的设备更新。换而言之，如果早点加入了预览版本，在该 issue 提出之前升级到了对应版本，可能我的设备就遇上了这个问题，我的数据也可能会丢失。作为当前的主力机，出问题丢数据几乎是不能接受的事情，即使有 OneDrive 做了一些最基础的备份。</p><p>想到此内心其实是有一些后怕，也是因为这个问题，我才开始对于稳定性与新特性的权衡有了一点不一样的理解。新特性固然是好，但也仅仅是好，不是必须要的，而为了追求这些可以没有的新特性而把稳定性破坏了，搞出问题影响到基本的使用，就非常难受了，尤其是当前基本所有的工作都在我的唯一主力机上进行，它出了问题就等于我出问题了 <span class="github-emoji" alias="cry" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></p><p>所以还是稳一点好，电脑关掉了预览版重新等待漫长的更新推送，手机上 MIUI 的开发版也回刷回去稳定版了，而软件上面的更新还是会及时去更新升级，毕竟软件挂了出问题可以删了重来，系统出问题可能就直接把数据都搞挂了（尤其是之前我还为了囤空间把分区只剩下一个 C 盘了）。</p><p>仅以此文来对自己做一个提醒，以后要时刻考虑稳定性的问题。<s>本文开始时间太久了很多想法都不清楚了<span class="github-emoji" alias="joy" style fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></s></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="软件" scheme="http://scottyeung.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>不同系统环境下的换行符</title>
    <link href="http://scottyeung.top/2020/%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
    <id>http://scottyeung.top/2020/不同系统环境下的换行符/</id>
    <published>2020-06-18T08:11:46.000Z</published>
    <updated>2020-07-16T16:28:17.518Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。</p><a id="more"></a>        <h2 id="换行符">          <a href="#换行符" class="heading-link"><i class="fas fa-link"></i></a>换行符</h2>      <p>一般会使用转义字符作为换行字符，包括 <code>\n \r \r\n</code>。</p><p>在不同的操作系统的文件系统中，会使用不同的字符作为换行符：</p><ul><li>Linux：<code>\n</code> LF(Line Feed)</li><li>Mac OS：<code>\r</code> CR(carriage return)</li><li>Windows: <code>\r\n</code> CR/LF</li></ul><p>当然这些对于换行符识别的差异主要还是出现文件系统对于文件的识别当中，实际的 coding 过程中一般都还是全部使用 <code>\n</code> 作为字符串当中的换行符。</p>        <h2 id="踩坑">          <a href="#踩坑" class="heading-link"><i class="fas fa-link"></i></a>踩坑</h2>      <p>记录一下因为换行符不同所踩的坑。</p>        <h3 id="javascript-油猴脚本解析">          <a href="#javascript-油猴脚本解析" class="heading-link"><i class="fas fa-link"></i></a>JavaScript 油猴脚本解析</h3>      <p>因为比较经常使用 Google Translate 翻译所看的文档，有挺多的复制待翻译内容到网页端上进行翻译的使用场景，但是 PDF 文档复制时会被换行符也一并复制，所以粘贴的时候原本成句的内容会被分成几段，当作几句话来处理，内容很可能不正确，需要手动删除。一两次还好，次数多了就很麻烦，于是写了一个油猴脚本，捕获 Google Translate 中的粘贴内容，把想要粘贴的内容去除换行符。</p><p>想法很简单，就在输入框元素中监听 paste 事件，当出现 paste 事件时，获取粘贴的内容，阻断粘贴的操作，并把输入框的值改为去除换行符后的粘贴内容。</p><p>第一次尝试没有效果，就在代码里面添加一些 log，来进行 debug，从控制台的输出看到脚本是可以捕获到要粘贴的内容，然后去除换行符后的输出内容也是正常的，但是这个去除换行符后的内容重新复制并粘贴到控制台输入时，却仍然会有换行现象。如果是在控制台中获取元素，用同样的语句移除换行符的话，功能也是正常的。</p><p>最终发现问题就在换行符上面，我从 pdf 中复制的文字中，换行符为 <code>\r\n</code>，而我去除换行符的操作为 <code>replace('\n',' ')</code>。当我去除了 <code>\n</code> 之后，网页端的解析还是当有换行符，在控制台的输入上面也还是有换行的作用，最终把去除换行符的语句改为 <code>replace(/(\r\n|\r|\n)/g, ' ')</code>，套了个正则匹配所有类型的换行符，问题解决。</p>        <h3 id="cmakelist">          <a href="#cmakelist" class="heading-link"><i class="fas fa-link"></i></a>CMakeList</h3>      <p>打算使用 LLVM 在 GitHub 中的代码仓库拉下来的源代码进行构建，在使用 CMake 的时候出现问题，提示问题在 <code>cmake/config.guess</code> 文件中，但是又完全没有说是什么问题，而且它提示的行号基本全是空行。搜了一下，发现这个问题出现得还挺多，不过别人的提示信息更多，提示是字符 <code>\r</code> 出问题，说的大概就是换行符不一致，给的方法是将文件的换行符转成 unix 的换行符即可。</p><p>下了一个工具 <code>dos2unix</code> 可以直接将文本文件的换行符转成 unix下的换行符，转换之后，cmake 就可正常运行，生成构建文件了。（尽管直到现在过了我都还没有成功 build 好 llvm 及其配套工具。）</p>        <h3 id="git">          <a href="#git" class="heading-link"><i class="fas fa-link"></i></a>Git</h3>      <p>这个是之前遇到的问题了，在 Windows 系统下通过 Git 提交的文件，在使用 WSL 打开时，会提示每一个文件都有修改。在本地中同样的 repo，同样的历史记录，当前状态显示不一样。</p><p>这个可以通过设置 <code>core.autocrlf</code> 来解决，打开了这个选项之后，在提交时会把所有的 CR/LF 换行符转成 LF 换行符，在 checkout 代码时又会把文件中的 LF 换行符转成 CR/LF。本质就是统一在提交记录里使用 LF 作为换行符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
  </entry>
  
</feed>
