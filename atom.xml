<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeungYeah 的乱写地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.top/"/>
  <updated>2020-03-25T15:56:53.859Z</updated>
  <id>http://scottyeung.top/</id>
  
  <author>
    <name>Scott Yeung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客域名迁移</title>
    <link href="http://scottyeung.top/2020/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%BF%81%E7%A7%BB/"/>
    <id>http://scottyeung.top/2020/博客域名迁移/</id>
    <published>2020-03-25T03:56:16.000Z</published>
    <updated>2020-03-25T15:56:53.859Z</updated>
    
    <content type="html"><![CDATA[<p>一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年72元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些cn后缀的都贵，有点离谱。于是果断选择转换回去最早使用的top域名，续费也才25一年，加上首年优惠三年才花了60不到。</p><p>另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的SEO和RSS订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。</p><p>本站现已迁移到域名 <strong><a href="http://scottyeung.top/" class="uri">http://scottyeung.top/</a></strong></p><a id="more"></a><h2 id="相关工作">相关工作</h2><p>以下是迁移域名做的一些工作：</p><ul><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> Github Pages 切换解析到新域名<ul><li>域名添加DNS解析，两个A记录指向Github的ip地址，一个cname绑在二级域名www上指向博客的源地址</li><li>Github Repo修改Github Pages的Custom domain</li><li>修改public文件夹当中的CNAME文件的内容为新域名（我已经忘了这个的作用了2333</li></ul></li><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> Coding.net 添加解析（现在已经感觉完全归属到腾讯了）。原本是当作国内百度搜索引擎的专用解析，但因为下面的Google Search 需要旧网址跳转，遂暂时使用它来提供Pages服务。</li><li><p><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> LeanCloud修改安全域名，添加对新域名的支持。发现可以直接使用过往的阅读量数据和评论数据</p></li><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> Google Analytics： 修改监测网址即可。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> Google Adsense： 添加新网址即可，需要重新进行审核，等待通过中。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> Google Search<ul><li>添加新域名并进行所有权验证</li><li>新域名添加站点地图抓取</li><li>尝试将旧网站的索引的SEO资源继承到新域名中，Google Search Console中的确有网站转移的功能，要求旧网址发301响应重定向到新网站。可选的方法有：旧域名DNS解析中添加显式URL跳转，跳转到新域名，但是目标跳转域名需要备案。选择支持绑定多个域名的Pages服务提供商，如coding.net，可以绑定多个域名，然后选择一个首选域名，其它域名跳转到该域名，浏览器调试验证确实可行，但Google Search Console不知道为啥通不过，暂时放弃。过了一个多小时又可以了，不过需要一段时间来处理，不知道要多久，然而提示最好保留重定向180天，旧域名只剩下一个月，如果不能在一个月之内迁移成功旧白干了。</li></ul></li><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 百度站长工具：类似于Google Search，添加新的网址进行所有权认证即可。依然采用主动推送和sitemap的方式来提交链接。</li><li><p><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> 360站长工具：同上，操作简单，不过连同上周其实没有期望多大的效果。</p></li></ul><h2 id="数据损失">数据损失</h2><p>因为转换域名而无法继承的数据造成的损失：</p><ul><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 卜算子站点统计。因为它的统计似乎是以站点网址作为键值来进行统计的，更换后直接重新进行统计。（服务开启得太过简单的后果就是维护性/扩展性的牺牲</li></ul><h2 id="信息修改">信息修改</h2><p>此处是一些记录下我网址的需要改过来的地方</p><ul><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> GitHub上博客的repo简介和个人简介</li><li><span class="github-emoji" data-alias="construction" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f6a7.png?v8">🚧</span>中文独立博客repo中的博客列表需要修改网址，发PR来改</li><li><span class="github-emoji" data-alias="heavy_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2714.png?v8">✔</span> twitter上面写的个人网址</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年72元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些cn后缀的都贵，有点离谱。于是果断选择转换回去最早使用的top域名，续费也才25一年，加上首年优惠三年才花了60不到。&lt;/p&gt;
&lt;p&gt;另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的SEO和RSS订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。&lt;/p&gt;
&lt;p&gt;本站现已迁移到域名 &lt;strong&gt;&lt;a href=&quot;http://scottyeung.top/&quot; class=&quot;uri&quot;&gt;http://scottyeung.top/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="域名" scheme="http://scottyeung.top/tags/%E5%9F%9F%E5%90%8D/"/>
    
      <category term="腾讯云" scheme="http://scottyeung.top/tags/%E8%85%BE%E8%AE%AF%E4%BA%91/"/>
    
      <category term="博客" scheme="http://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="迁移" scheme="http://scottyeung.top/tags/%E8%BF%81%E7%A7%BB/"/>
    
      <category term="SEO" scheme="http://scottyeung.top/tags/SEO/"/>
    
  </entry>
  
  <entry>
    <title>Python中的并发编程</title>
    <link href="http://scottyeung.top/2020/Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://scottyeung.top/2020/Python中的并发编程/</id>
    <published>2020-03-09T12:51:07.000Z</published>
    <updated>2020-03-11T05:18:29.694Z</updated>
    
    <content type="html"><![CDATA[<p>尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。</p><a id="more"></a><p>以下只考虑Python3的状况。</p><h2 id="threading-multiprocessing">Threading / Multiprocessing</h2><p>最简单的并发编程形式，莫过于直接开启新的线程或者进程来执行代码。</p><ul><li><code>threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code> 通过调用该方法可以直接创建线程对象，其中target为需要执行的目标函数，args和kwargs为该目标函数的参数，创建后，通过<ul><li>调用start方法以开启线程，进行调度执行target函数</li><li>线程开启调度后，调用<code>join(timeout=None)</code>方法可以阻塞调用线程，等待线程结束或者超时</li><li>使用threading进行多线程编程实现并发的话，仍然受到GIL的限制，但仍可以避免因等待IO完成的阻塞</li></ul></li><li><code>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code> 类似于线程的创建，创建进程实现多线程可以避免GIL的限制从而利用到CPU的多个核心，在CPU密集的代码中非常有用。<ul><li>类似于线程的使用，通过start方法开启进程任务调度，调用join方法等待完成</li><li>除此以外，可以调用进程池Pool进行多个任务的调度处理，通过map或者apply方法，开启多个进程处理多个任务</li></ul></li></ul><p>直接创建线程/进程这种方式简单、直接、粗暴，不过大多时候需要自己进行任务的调度，需要自己安排怎样创建进程，怎样完成任务。在之前尝试<a href="http://scottyeung.club/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/" target="_blank" rel="noopener">批量下载漫画</a>的过程中，使用的就是threading方法，就需要自己进行任务的安排，进而安排线程的创建和执行。当时还不知道怎么合理地分配调度任务，就只能将任务分为若干子集，每个子集开启独立的线程来完成下载任务，但是仍然无法避免下载过程中网络访问和文件保存的IO阻塞。另外，线程创建之后就是独立运行的线程，除了等待结束返回之后，无法传输数据进行额外的控制。</p><h2 id="concurrent.futures">concurrent.futures</h2><p>它在Python3.2中被引入，提供了高层次的异步可调用对象执行的接口。我们可以通过ThreadPoolExecutor在线程级别上进行异步执行，或者通过ProcessPoolExecutor在不同的进程中实现。两者实现相同的抽象接口类Excutor，因而具有一样的调用方法，便于进行转换。</p><h3 id="executor">Executor</h3><ul><li><code>submit(fn, *args, **kwargs)</code> 提交任务进行调度，返回Future对象</li><li><code>map(func, *iterables, timeout=None, chunksize=1)</code> 类似于map方法，对于iter里面的每一个对象都会异步地调用func，当任务结束时返回各个函数返回结果的迭代器</li></ul><h3 id="future">Future</h3><p>在futures里面具体的任务类，由submit方法创建。</p><ul><li>result 获取任务的返回结果，若未结束则阻塞至结束或超时</li><li>cancel 关闭任务</li><li>canceled 是否关闭</li><li>done 是否结束</li></ul><h3 id="使用方式">使用方式</h3><ol type="1"><li><p>通过submit提交任务创建获取任务的future对象，再通过as_completed等待future对象结束，获取结果。as_completed接收future对象的迭代器。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure></p></li><li><p>通过map方法批量执行任务，再获取结果。但是map方法返回结果的顺序与调用顺序即传入的迭代对象的顺序一样，若前面的任务耗时过长会阻塞后面执行快的任务返回。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br></pre></td></tr></table></figure><h2 id="asyncio">asyncio</h2><p>asyncio采用event loop的事件驱动型的异步调度执行。</p><h3 id="coroutine">coroutine</h3><p>coroutine（协程）从定义上来说，指的是包含yield/yield from语句的函数（在Python3.5引入async和await之前）。在此之前，我们可以通过生成器的形式来实现，样例如下。首先可以调用函数获得生成器对象，然后调用next方法或send(None)的方法开启coroutine，开启后，函数执行到yield位置，返回yield右侧的表达式后则挂起自己，将控制流交回给主线程。当再次调用send方法时，可以传输数据并激活协程，继续执行至结束或者下一个yield语句处。该样例则是一个计算累计输入的平均值协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># BEGIN CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg = averager()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(coro_avg)  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(10)  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    10.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(30)</span></span><br><span class="line"><span class="string">    20.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(5)</span></span><br><span class="line"><span class="string">    15.0</span></span><br><span class="line"><span class="string"># END CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        term = <span class="keyword">yield</span> average  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br></pre></td></tr></table></figure><p>当coroutine运行结束时，会抛出一个StopIteration的异常，告知协程结束。若协程函数有返回值，也会被存在StopIteration.value中随着异常返回。如果我们要获得返回值，必须要捕获异常。另外，在使用coroutine的过程中，我们还需要手动调用next方法来开启coroutine。这些不方便之处，使我们通常会使用一个delegating generator来进行中间的调用操作。在delegation generator当中，通过yield from来调用subgenerator，并可以直接获取返回值，且delegating generator可以处理subgenerator抛出的异常。</p><h3 id="使用方式-1">使用方式</h3><p>asyncio库则是通过协程的方式，引入事件循环（event loop）的方式，通过事件轮询与回调的方式进行异步编程。具体的使用方式通过书中一个具体的例子来说明。这个例子是批量从网上下载不同国家国旗的图片，通过将每一个国家国旗的下载任务封装为一个协程，进行并发编程。在协程中，对于每一个可能会发生阻塞，需要等待的操作，均使用yield from进行调用。当运行到此处时，程序会交出当前的控制权，异步调用并执行coroutine，当运行完返回之后才会将控制权交回给之前的线程。</p><p>当编写完协程函数之后，通过list comprehension批量生成协程对象，通过wait方法开启新的协程，来调用开启所有的任务协程对象。在通过loop.run_until_complete等待所有协程完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine  # &lt;3&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(cc)  <span class="comment"># &lt;7&gt;</span></span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">    loop.close() <span class="comment"># &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure><p>PS： 1. 可能会出现的阻塞应该全部使用异步调用。因为这里采用的是event loop，其实还是在同一个线程，如果使用了线程阻塞的操作，依然会阻塞其余所有的操作。因而应该使用异步调用的方式，如aiohttp进行http请求，或者asyncio.sleep进行休眠操作，当会发生阻塞的时候，抛出控制权给回event loop 2. 此处调用wait后再调用run_until_complete，需要等到全部协程完成时才会一并返回结果，不利于判断完成情况。可以利用asyncio.as_completed进行代替，可以马上返回以及完成的任务 3. 只有通过loop或async中相关的run方法，任务才会被执行</p><h3 id="update">update</h3><p>在Python3.5中，引入了关键字async和await，以及coroutine类型。可以更加清晰地使用asyncio进行并发编程。其中async等价于装饰器<code>@asyncio.coroutine</code>，可以将函数声明为coroutine对象。await关键字则可以取代yield from关键字，进行异步函数的调用。看了看变化还挺大的，尽管核心的思想没变，还是需要重新看看。具体的文档<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">见此</a></p><h2 id="后记">后记</h2><p>在学习了Fluent Python中的并发编程之后，突发兴趣打算使用asyncio和concurreny.futures来重写之前的漫画下载任务，来看看实际的效果提升。尽管在看书的过程中，感觉自己掌握得好像还行，对于样例代码也能一看就可以理解，而且目标任务也比较简单，应该可以比较快就实现目标任务。然而实际操作编写代码就发现并不是这么简单。首先，书中的代码有些已经落后（如async和await关键字没有引入），越看文档就越能发现新的features，有些还与书中的样例代码有所出入。其次，现实中代码的实际运行状况远比书中的理想状况复杂。就错误处理而言，一开始并没有做错误处理，导致出错后就静静地挂起，没有提示，也不会结束。后面做了简单的错误处理后发现，异常类型真可谓各式各样。最后，就是书中不能对全部状况状况作出全面的介绍，存在着许多未知的状况。发现很多错误也还好，最怕的是发现不了错误，或者知道有问题但是找不出来，还没有信息。</p><p>coding还是需要多动手实践，从具体的代码编写入手，这样才能真正提高所谓的coding 能力，否则只看书的话，很容易就会陷入一种我都会了的感觉，但这其实只是我都知道的状态，并不代表我都会用，我都能用，我都可以用好。看书更多的是留下一种对某方面知识或技能的印象，当需要的时候能够根据这些印象进行快速的索引和学习，重新获取知识。两者都很重要，缺一不可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Python" scheme="http://scottyeung.top/categories/Python/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Concurrency" scheme="http://scottyeung.top/tags/Concurrency/"/>
    
      <category term="asyncio" scheme="http://scottyeung.top/tags/asyncio/"/>
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>记一次漫画批量的爬取/下载</title>
    <link href="http://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/"/>
    <id>http://scottyeung.top/2020/记一次漫画批量的爬取-下载/</id>
    <published>2020-02-28T14:01:33.000Z</published>
    <updated>2020-02-29T04:19:23.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。</p><a id="more"></a><h1 id="实现思路">实现思路</h1><p>漫画下载无非就是图片的抓取下载，也算是一种比较简单的爬虫。分析选为抓取来源的网页的URL，发现其URL规律为<code>host/type/漫画的ID+漫画章节号+第几页</code>，可以按照该规律生成所有漫画每一页的URL，则可以根据每一个URL获取里面的漫画图片下载。进一步分析这些页面上漫画图片的URL，发现是跳转到一个ASP页面进行提供，链接为三级ID组成，包括漫画ID，章节号，页码组成。在浏览器直接访问图片的URL，发现会跳转到404页面。根据开发者调试工具的Network栏中拦截的请求，发现图片实则来自另一个URL，并且图片URL的规律十分明显。于是问题就转变成根据规律批量生成图片的URL并下载。</p><h1 id="具体实现python">具体实现：Python</h1><p>为了简单，就没有使用任何的轮子。直接使用requests库访问这些URL获取图片资源，并写入到本地文件中保存。</p><h2 id="v1">v1</h2><p>具体的实现思路大概如下。对于漫画的每一话，先创建目录，然后根据该话的序号和页面生成目标资源URL，发送GET请求获取资源，通过文件写入保存到本地，直到访问的URL不存在漫画图片，跳转到404页面，此处我们通过判断响应首部的内容长度是否等于404图片的大小来判断该话是否结束爬取。根据漫画的总数，对每一话进行下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">'https://www.xxxxxx.com/1234/1234/&#123;0:0&gt;3d&#125;/&#123;1:0&gt;3d&#125;.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getChapter</span><span class="params">(no)</span>:</span></span><br><span class="line">    <span class="string">'''获取并保存第no话的漫画'''</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    os.mkdir(saveDir + str(no))</span><br><span class="line">    req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    print(req.status_code, req.headers)</span><br><span class="line">    <span class="keyword">while</span> req.status_code == <span class="number">200</span> <span class="keyword">and</span> req.headers[<span class="string">'Content-Length'</span>] != size404:</span><br><span class="line">        <span class="keyword">with</span> open(saveDir + str(no) + <span class="string">'/'</span> + str(cnt)+<span class="string">'.jpg'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(req.content)           </span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    <span class="keyword">return</span> cnt - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><p>实在是太慢了！</p><p>尝试着下了一话大概花费半到一分多钟左右，这里总共有一百多话，两个多小时肯定是走不掉了，而且还没考虑网络不稳定的因素。考虑了一下其中效率的制约因素，最主要为： - 网络请求。发请求获取资源需要传输时间。 - IO。图片保存到本地需要写入时间。</p><h2 id="v2">v2</h2><p>考虑使用多线程进行并行下载，进而提高速度。虽说Python提供的多线程只是伪多线程，实际上还是只能有一个线程被核心处理，但应该还是可以减少其中的等待时间。采用threading.Thread对象，将下载任务分成若干个patch交由不同的线程完成，每个线程完成20话的下载任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPatch</span><span class="params">(start,size,max_chapter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,min(size,max_chapter)+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'save chapter &#123;:0&gt;3d&#125; page &#123;:0&gt;3d&#125;'</span>.format(i,getChapter(i)))</span><br><span class="line"></span><br><span class="line">patch = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    t = threading.Thread(target=getPatch,kwargs=&#123;<span class="string">'start'</span>:i*patch+<span class="number">1</span>,<span class="string">'size'</span>:patch,<span class="string">'max_chapter'</span>:<span class="number">136</span>&#125;)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="效果-1">效果</h3><p>并没有提升多少速度。感觉这个多线程并没提高多少并行程度，我开了7个线程，但是最开始只创建了4文件夹进行下载，在这4话中进行调度交替下载。也不知道花了多少时间，下完这4话之后，我就强制关掉了，弃掉该方案。</p><h1 id="具体实现goland">具体实现：Goland</h1><p>说到多线程，最方便的肯定就是Go语言了，直接的关键字支持多线程。于是拾起很久没碰过的Goland，甚至新电脑上还没安装环境，还需要重新安装Go语言，配置环境和开发工具，就下Vscode的插件都花了点功夫。</p><p>实现思路还是同Python版本一样，为了简单不使用任何额外的轮子，直接使用net/http包进行http访问，获取图片，并写入到本地文件。</p><h2 id="v3">v3</h2><p>具体的单话下载代码如下。方法跟Python版本的几乎一样，不过Go语言做了额外的错误处理，显得有点冗余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downChapter</span><span class="params">(no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">page := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ;; page++ &#123;</span><br><span class="line">_, err := os.Stat(fmt.Sprintf(saveDir, no))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(saveDir, no))</span><br><span class="line">os.Mkdir(fmt.Sprintf(saveDir, no), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line">res, err := http.Get(fmt.Sprintf(baseUrl, no, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.Header.Get(<span class="string">"Content-Length"</span>) == size404&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Create(fmt.Sprintf(saveDir, no) + fmt.Sprintf(postfix, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">io.Copy(file, res.Body)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down chapter %3d with %3d pages\n"</span>,no,page)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Go语言最主要就是要用它的多线程特性。在Go中只需要在调用函数前加上关键字Go就可以开启新的多线程调用函数。将下载任务分成20个为一批的多个patch，开启了7个线程进行下载。此处使用WaitGroup进行多线程的等待，避免主线程提前结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downPatch</span><span class="params">(start, patch, maxChapter <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> no:=start;no&lt;=start+patch &amp;&amp; no&lt;=maxChapter;no++&#123;</span><br><span class="line">downChapter(no)</span><br><span class="line">cnt++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down patch from %3d to %3d total %d"</span>,start,start+cnt<span class="number">-1</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;maxChapter/patch;i++&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> downPatch(i * patch,patch,maxChapter)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果-2">效果</h3><p>速度确实提升了，但是感觉没有到很快的程度。。。</p><p>直到写文章的此刻，跑了两个半小时，下了大概86话。打开任务管理器看了看情况，CPU占用率一直很低，磁盘读写占用也很低，感觉瓶颈就在网络传输上面。另外，觉得7个线程也开得有点少了，应该多开一点，榨干电脑的性能，而且开多了也不会有很大的浪费。不过似乎制约速率的瓶颈就这网络传输上面，确实没办法。</p><h1 id="思考">思考</h1><ul><li>对于网络爬虫/下载，最为制约效率的因素始终是网络因素，这个也是我们最不能把握的。可能是服务器端的接入速率因素，可能是服务器端的处理计算速度因素，可能是链路的传输速度因素，还可能是墙的因素，有很多的可能性。</li><li>在程序刚运行的时候，我想到过多的http请求会不会把那个站点搞崩。一百多话，每画平均25页，接近三千多张图片，需要发三千多个http请求，会不会over了，不过在当前这个速度下显然是想多了。不过这在以后的爬虫获取数据或者资源的时候确实需要考虑，为他人想想，可以考虑加点间隔时间。</li><li>东西不用了就会忘记，技能确实需要是不是拾起来使使。</li><li>有时候问题并不是在选择的方法或工具上面，可能只是简单的自己做错了/做得不够，或者当时的环境不行。</li></ul><h1 id="后记">后记</h1><p>最终因为电脑在休眠的时候自动更新，强行重启了，最终还是没下完，大概下了120话，花了4个半小时，远远超出我的预期。大概原因为</p><ul><li>线程设置有误。原本想设置7个线程，但没考虑到Go里面除法取整，少了一个线程，最后一个patch的任务没有执行，实际是六线程运行。</li><li>代码存在一些不合理的地方，造成了操作上的重复。如判断在每一话当中判断文件夹是否存在，我把他放到了循环当中，每下载一页的图片前都会判断；还有设置patch的时候没有考虑开闭区间，且下载的时候没有判断文件是否已经下载，导致首尾的漫画重复下载。</li><li>后期漫画的图片质量上去了，由前面的一百几十kb提升到后面的四五百kb，所以负责后面漫画下载的线程速度较慢，速度没有达到预期。</li><li>网络问题。可能昨天晚上的网确实不行，也可能是频繁访问被制约了网速。</li></ul><p>今天早上用Python把剩下的十几话下载下来，发现其实昨天的多线程代码有问题，修改了一下，顺利下载，而且速度还不错，我开了6个线程，下18话用了不到20分钟。看来还是网络的问题，难顶。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding记录" scheme="http://scottyeung.top/categories/Coding%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="Golang" scheme="http://scottyeung.top/tags/Golang/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="多线程" scheme="http://scottyeung.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>太极拳中的劲</title>
    <link href="http://scottyeung.top/2020/%E5%A4%AA%E6%9E%81%E6%8B%B3%E4%B8%AD%E7%9A%84%E5%8A%B2/"/>
    <id>http://scottyeung.top/2020/太极拳中的劲/</id>
    <published>2020-02-16T14:59:05.000Z</published>
    <updated>2020-02-17T13:18:54.320Z</updated>
    
    <content type="html"><![CDATA[<p>相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。</p><a id="more"></a><p>最近，又开始寻找锻炼方式，最好是一种万能的方法，能够对全身有着极大的帮助，于是又开始转回太极，在YouTube上面学了几个动作，回家后又再次搁置下来。在书柜乱翻时，心血来潮将高中时买的一本书《内家拳的瑰宝——懂劲》再次拿出来看看。这本书主要是描述内家拳当中最重要的核心——劲。所谓的劲，比较玄乎，大致的理解为肌肉收缩产生力，筋的收缩则产生劲。从太极拳等内家拳当中领悟到劲的感觉，且带着劲来打拳架，才是真的入门，用书中的话来说，才能到达“阶及神明”的地步。主要的好处有：</p><ul><li>劲能够刺激锻炼到全身，对身体当中的筋有很好的锻炼效果</li><li>通过劲在打拳当中能够更好的效果，尤其是在推手或技击中</li><li>只有领会到真正的劲，才能体会到太极当中的松，在生活当中有更好的状态</li><li>不伤身，可长久练习，不像一些刚猛的技击方法，对身体有所损耗</li></ul><p>怎样练习而找到这种劲呢？当时第一次看这本书，就是因为书中写得太过玄乎，而练习方式的叙述又太简单，被当时因学业紧张而对时间使用非常功利的我放弃掉。如今在家里比较闲，生活没有那么紧张，而且对有无所成感到没什么要求，又重新找了一下。劲怎么来？主要是从地来，力从地起，通过脚对地面的各种接触方式，产生根劲。再通过筋脉，由脚到腿，由腿到腰，由腰到全身。怎么练习呢？个人感觉关键有两点，一是怎么由脚产生劲，二是怎么在全身传导劲。前者，书中讲到一个脚掌落地与落地的方式，以左脚为例，从右上方根据顺时针分成四块，落地顺序为一四二三，离地则反过来。后者则需要注重旋转，变换重心等方式来转移劲。当然纸上谈兵非常简单，真的练习找到感觉非常困难，且是需要那种讲究顿悟的学习。具体的练习可以站桩，或者走拳架。书中给出了作者简化的二十二式太极拳，每天走十遍左右，可以试试感悟，不过书中的每一式就附上一张静态图片和一段文字解释（甚至不是动作描述），学会还是有难度的，不过太极拳的招式大致相同，且并不需要走套路，单独的招式也有效果（可能），网上找找估计能找到。</p><p>附上书中的二十二式太极拳： &gt; 起势，左掤，右掤，捋，挤，按，单鞭，采，挒，肘，靠（左右二式），提手上式，搬拦捶，右斜飞式，搂膝拗步（三式），上步十字手，半步崩拳，抱虎归山，如封似闭，倒撵猴（三步），半单鞭（三式），左每人照镜，收势。</p><p>常说传武式微，但就当前这种环境以及流传下来的资料，确实难以传承，就这本书来讲，一味地讲理论，讲劲的好处，而练习方式，拳架教学，只有短短不到三十页，还不到全书五分之一，仅凭这些就能够学会的确实是天赋非凡。因为没有资料，只能靠师傅人工传承，但终有各种的不方便，最主要的，还是好师傅难寻，寻到也不一定愿意教，这样的环境，技艺失传又有何奇怪。不过我也没想着练出啥绝世的武功，无非是希望能锻炼下身体，以及能够以太极的松柔状态来过生活，仅此而已，所以随缘就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="养生" scheme="http://scottyeung.top/tags/%E5%85%BB%E7%94%9F/"/>
    
      <category term="太极" scheme="http://scottyeung.top/tags/%E5%A4%AA%E6%9E%81/"/>
    
      <category term="运动" scheme="http://scottyeung.top/tags/%E8%BF%90%E5%8A%A8/"/>
    
      <category term="内家拳" scheme="http://scottyeung.top/tags/%E5%86%85%E5%AE%B6%E6%8B%B3/"/>
    
      <category term="玄学" scheme="http://scottyeung.top/tags/%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>就医当中的医疗选择——《最好的抉择》读书总结</title>
    <link href="http://scottyeung.top/2020/%E5%B0%B1%E5%8C%BB%E5%BD%93%E4%B8%AD%E7%9A%84%E5%8C%BB%E7%96%97%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E3%80%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E6%8A%89%E6%8B%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://scottyeung.top/2020/就医当中的医疗选择——《最好的抉择》读书总结/</id>
    <published>2020-02-01T09:20:32.000Z</published>
    <updated>2020-02-02T04:02:36.978Z</updated>
    
    <content type="html"><![CDATA[<p>在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。</p><a id="more"></a><h2 id="理想状况">理想状况</h2><p>最理想的就医情况，莫过于在就医时，医生可以根据个人的具体情况，进行具体的分析，对于病症，给出可供选择的治疗方案。每个方案，都给患者进行完备的解释，包括具体流程，治疗效果，方案成功率，副作用的几率及程度，并且可以提供一定的数据，对效果和概率进行形象化的说明。患者可以根据医生提供的方案和说明，清楚自己的选择可以带来的效果和副作用，并向医生提出自己的疑问和担忧以获得解答。最终两者达成一致，进行治疗。</p><p>但事实上，这样的理想情况，很难出现，尤其是在国内的就医环境当中。医生往往因为无法根据患者的具体情况进行判断，一是会诊时间不多无法对患者进行详细的询问以获取更多信息，二是病患有些时候也不知道如何表达自身情况，应该告诉医生什么信息。所以医生有些时候只能流水线般地给出一些固定的方案。另外，因为患者有些时候对于医生的权威有着畏惧，不敢提出自己的疑问，甚至反对意见。病人怕于见医生，怕于反对医生，最后可能糊里糊涂地就接受了医生的某个方案，最终只能对着不好的效果后悔。</p><p>所以，就医过程中，需要考虑若干因素，从医生的角度，从病人自己的角度，做出最佳选择。</p><h2 id="医生的建议">医生的建议</h2><p>当医生给出若干的选项，然后建议你其中一个最好时，甚至医生只给你提供了一个医疗选项，说其它的不够好时，你是否应该听从呢？</p><p>书中讲到了一个治疗甲亢的例子，主人公因为甲亢而去看内科医生，医生给出的方案是让其服用放射性碘丸，利用放射性烧掉甲状腺，日后通过口服甲状腺激素进行补充替代，需要终生服药。破坏掉人体中的一个器官，并且终身都离不开某种药物，相信很多人都不太能接受，真的只有这种方法吗？患者经过查询向其他医生求助时发现，其实还有两个方法，一是手术切除甲状腺，后续终身服药，另一种是通过服用一些抑制药物来抑制症状。在得知这些信息后，患者重新去询问该内科医生，医生只是简单地回答这个方法效果最好，好在哪里，也说不出个所以然。但是根据数据统计，其实三种方法的效果都差不多，而放射性碘丸还可能有辐射到其它器官的风险。说是最好，也未必是。</p><!-- 医生的偏见。 --><p>医生会有这样不同的观点，很显然医生也有着自己的偏好，当可供选择的方案相差不大时，医生可能会因为自己的主观因素而对其中的某种选择有着更高的偏好，或者对某种方案有着偏见。如同上面提到的三种方案，根据调查，经历过地震导致核泄露的日本医生就会更偏向于不使用放射性碘丸，而传统的极端的医生则倾向于通过手术切除甲状腺，一步到位。带有偏好的选项，真的适合我们吗？我们做出的选择恐怕会受其影响。为了避免这种情况的出现，不妨对医生深入地询问备选方案，问清其利弊，偏好或是建议的原因。若在该医生处得到的信息不够完备，不妨多问几个不同的医生，上网查询相关的方案信息和病例数据。</p><h2 id="选择的影响因素">选择的影响因素</h2><p>除了医生的影响之外，影响病人做出医疗方案选择的，还有许多因素。在选择时，我们需要考虑这些因素，排除噪声影响。</p><h3 id="易得性因素">易得性因素</h3><p>对于听到的具体的传言或故事，我们的印象总是要比冰冷的数据更为深刻。尽管医生推荐你可以用方案B，告诉你方案B相较于方案A的成功率要高，副作用相对可能较少，但若果你知道身边的某个人通过方案A成功治愈，且效果良好，没有副作用，你也会被这个真实的例子吸引住，进而选择方案A而不是方案B，因为你不知道这个成功率高，可能较少，是一种什么情况。同理，像治疗高血脂的药，如果不服用降低血脂，会有一定的概率出现心血管疾病，但是服用药物有一定的概率出现不良反应。一般来说，医生应该给出不服用的心血管患病概率，以及不良反应的症状和概率，由患者进行权衡（不过在国内好像很少会考虑药物的不良反应，都是有症状就直接开，出现不良反应就再治不良反应或换药）。尽管可能不良反应概率可能很低，或者可以通过停药而消失，但如果你的身边有人服用这些药物出现不良反应，而且消失不了，相信你的心里对服用这些药物也会有着一定的介怀。</p><h3 id="自然主义与极端主义">自然主义与极端主义</h3><p>有一部分人，对于服用药物，进行手术等通过外力改变身体状况的方式比较排斥，这些人可以成为自然主义者，这些人信奉可以通过自己调整生活方式或生活状态，使身体自然恢复。当身体出现某些症状后，他们第一时间通过调整生活方式，试图消灭这些症状，当没有效果时，他们才会去寻求医生和药物的帮助，即使如此，他们仍然希望接受最少的治疗，他们的内心对于医学有着一定的怀疑。与之相对的，还有极端主义者。他们一旦身体出现了某些症状，甚至只是某些身体指标的升高，他们就会第一时间寻求医生的帮助，试图通过药物或手术让身体指标回复正常，不能容忍身体存在一丝异常。</p><p>此处并不能指出两者谁更好，两者都有正面与反面的例子。当然这两者都比较极端，我们在生活中也很少极度偏向一端，而且我们的观点也很可能会随着某些事情的出现而改变。既然有着某一边的偏向，就要向医生表达出来，达成妥协，不然在治疗过程中，内心可能会心生不满，甚至事后埋怨治疗结果。</p><h3 id="病人的交流">病人的交流</h3><!-- 向病人寻求咨询和交流，获取信息以帮助交流 --><p>上面提到的易得性原则，大多数具体信息的获得来自于其它病人。当我们患病需要寻求其它信息帮助我们做出选择时，我们可以通过求助于此前使用这些治疗方法的病人。通过他们，我们可以获取详细而真实的信息，病人往往无所顾忌，对于疗效和后续的不良反应能够直接表达。当然，有些时候，病人也可能会因为某些原因而隐瞒一些状况。这就需要自己思考过滤信息了。</p><h3 id="承受程度">承受程度</h3><!-- 低估对生活状况的忍受程度。觉得接受不了，其实未必 --><p>在我们健康的时候，我们总会对生活质量的下降而感到不能忍受，就如若让你去除双眼以保住性命，很多人可能宁可不活了，也不能忍受失明后的生活。我们很多人其实都低估了自身对于生活质量下降的承受程度，觉得不能承受这些改变。不过当我们真的不得不做出如此改变，生活质量下降之后，我们其实也能够迅速适应，并且觉得不以为然。</p><blockquote><p>许多心理学研究发现，人们往往低估了自己适应新环境和新情况的能力。很多健康的人会把遭遇某种医疗问题后生活的“效用”或者“价值”低估，但是真正有这些问题的人却远没有那么悲观。比方说，健全的人会认为失明是非常糟糕的事情，但是失明几年之后的盲人却认为情况没有健全的人想的那么坏。这对那些在肠道造口术后无法控制排便的人也一样。许多健全人觉得这些结果非常可怕，所以给它们的“效用”或者“价值”打了非常低的分数，但是那些需要承受这些结果的人却觉得生活比前者所想的好多了。<strong>人们的适应能力其实是很强的，我们总能够在生活中发现“价值”，总有未爆发的抗挫潜力</strong>。</p></blockquote><h2 id="代理人的选择">代理人的选择</h2><!-- 代理人为在病人无法做出选择时，替代其做出医疗方案选择的人。三个原则：自决性，行善性，不伤害性。 --><p>除了需要病人自己做出选择以外，在有些特殊情况，还需要选择代理人，通过代理人来替自己做出选择。所谓的代理人，为在病人意识不清楚而不能做出决定时，代替病人做出选择的人。代理人做出的选择，也是需要通过非常艰难的抉择，一方面要符合病人的意愿，选择不能让其反对，必须要他接受，另一方面又要最为适合病人，效果最好。当病人的意愿与最佳疗法冲突时，当病人的想法与代理人的想法有出入时，当病人没有或无法表达选择意愿时，代理人应该怎样做出选择。</p><p>书中给出了三个原则以帮助代理人做出抉择，三种的优先级从高到低。首先是自决性原则，无论如何，承受治疗的主体都是病人本书，好与不好都由他本人承受，因而所有的选择都必须符合其意愿，至少在他做出选择的一刻是符合他当时的意愿的。其次，则是行善性，所做出的选择必须是对病人有利的，是不是最优的先不谈，但必须是有帮助的，有帮助的可以先上。最后，是不伤害性，治疗方案应该尽可能对人体无害，当然这个在有些时候也不能百分百保证，尤其是当情况紧急，状况不佳时，不得不采取一定的权衡。</p><hr><h2 id="后记">后记</h2><p>书中称医学为一门精确而不确定的科学。说其精确，是因为现代医学将一切都数据化，精确化。对于某些症状，其数据指标符合特定的数据指标，则判定为某疾病，采用某治疗方式。然而这种全通过数据，机械化的诊断流程，真的可以适应任何人，满足任何人吗？在这样的灰色地带，想要做决定往往并不容易，选择也往往不是那么明显。因此，医学涉及医生和病人微妙并且私人的决定。</p><blockquote><p>通过研究和数据，我们可以知道在100位像苏珊·鲍威尔那样的妇女中，会有一两位患有高胆固醇，但究竟是哪一两位呢？同样，我们也无法判断在300位妇女中，有哪一位或者两位妇女服用他汀类药物会产生疗效。甚至通过检测带有遗传信息的BRCA基因，我们也只能得到一个癌症发病率的估计值。没有人能够确切地知道，哪位妇女会在哪个确定时间患上乳腺癌；也没有人能够清楚地指出心房颤动、前列腺癌或者其他的疾病会给个体的生活带来怎样的影响，某种治疗方案在某个人身上又会出现怎样的副作用。我们每个人都是由不同的基因组合以及各自的环境造就出来的独一无二的个体。怎样保持健康或者从疾病中康复，并没有一个统一的方法。 然而这一本质性的问题往往被一些专家忽视，他们试图将治疗标准化，而不考虑病人的个体需求。虽然有人把这些公式当作科学来看，但是其实这种方法的实质是要把患病的经验转变成数字，这种努力的方向其实就是错误的，是徒劳的。然而保险公司和政府官员却总是在给医生和医院施加压力，要求他们通过各种公式把医疗服务标准化。保单设计人员，甚至是某些医生自己都宣称，把医学当作一门艺术的想法已经过时了。现在，医疗服务应当按照工业生产的方式来提供，医生和护士只要按照操作手册亦步亦趋就可以了。这些人甚至认为，医生和病人没有资格决定什么治疗方案最好。所以，当他们大谈医疗改革的目标是“以病人为中心”的时候，他们其实追求的是“以体制为中心”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="医学" scheme="http://scottyeung.top/tags/%E5%8C%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Sum Circular Subarray</title>
    <link href="http://scottyeung.top/2020/Maximum-Sum-Circular-Subarray/"/>
    <id>http://scottyeung.top/2020/Maximum-Sum-Circular-Subarray/</id>
    <published>2020-01-21T11:59:53.000Z</published>
    <updated>2020-02-06T04:43:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="problem">Problem</h1><ul><li>source: <a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">Maximum Sum Circular Subarray</a></li><li>difficulty: Medium</li></ul><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p><p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i] when 0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i] when i &gt;= 0</code>.)</p><p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray <span class="math inline">\(C[i], C[i+1], ..., C[j]\)</span>, there does not exist <span class="math inline">\(i &lt;= k_1, k_2 &lt;= j\)</span> with$k_1 mod A.length = k_2 mod A.length $.)</p><a id="more"></a><h2 id="examples">Examples</h2><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><p>Example 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure></p><p>Example 3: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure></p><p>Example 4: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure></p><p>Example 5: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p><h2 id="notes">Notes</h2><ol type="1"><li><span class="math inline">\(-30000 &lt;= A[i] &lt;= 30000\)</span></li><li><span class="math inline">\(1 &lt;= A.length &lt;= 30000\)</span></li></ol><h1 id="solution">Solution</h1><h2 id="暴力法">暴力法</h2><p>因为太久没有做过题了，对题目都没什么感觉了，感觉有点熟悉，可以用DP（发现是暑假的时候在紫书中看过），但是一下不知道怎么用。于是先用暴力法试试水。</p><p>题目当中要求的是最大子段和，所以考虑枚举所有的子段，每个子段包含一个普通的区间和一个首尾相接的连续区间。 枚举的情况有<span class="math inline">\(2 * C_n^2\)</span>种，每种情况计算子段和可以通过累计前缀和来计算，总复杂度为<span class="math inline">\(O(n^2\)</span>)。</p><p>最后结果为超时，大概能过 91 / 109 个样例。</p><h2 id="最大子序列和算法">最大子序列和算法</h2><p>暴力法超时后思考无果，上网看看别人的思路。发现求解最大子序列的和有一个很好的算法，就是 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">Kadane 算法</a>。很好理解，直接在下面提出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = cur = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">        cur = arr[i] + max(cur, <span class="number">0</span>)</span><br><span class="line">        ans = max(ans, cur)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>源方法来自于DP的化简，设 <span class="math inline">\(dp[i]\)</span> 为数组以元素<code>arr[i]</code>结尾的最大子序列和，则有下列的转移方程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>] = dp[i] + arr[i+<span class="number">1</span>] <span class="keyword">if</span> dp[i] &gt; <span class="number">0</span> <span class="keyword">else</span> arr[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>实际使用过程中无需存储dp数组，为了降低空间复杂度，使用数值变量记录数值即可。</p><h2 id="问题进一步分析">问题进一步分析</h2><p>于是问题就变成了在求解数组的最大子序列和的基础上，进一步考虑双向区间的和。原本的子序列，只考虑数组的单向区间，这一块可以通过kadane算法求解，所以所需考虑的问题为怎么求双向区间（一头一尾组成）的子数组和。大致有下面三种方法。</p><h3 id="相邻数组法">相邻数组法</h3><p>单区间子序列的最大值可以通过Kadane算法直接求出。 环形序列的双区间子序列则可分成左右两部分来找出，我们定义<code>maxright[i]</code> 为下标为i的元素右侧的最大子序列和，这个可以通过一次倒序扫描求出。所以双区间最大子序列和为<code>max(leftsums[i] + maxright(i+1) for i in range(N-2))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(A)</span>:</span></span><br><span class="line">    ans = cur = A[<span class="number">0</span>]</span><br><span class="line">    N = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">        cur = A[i] + max(<span class="number">0</span>,cur)</span><br><span class="line">        ans = max(ans,cur)</span><br><span class="line"></span><br><span class="line">    leftsums = [A[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N): leftsums[i] = leftsums[i<span class="number">-1</span>] + A[i]</span><br><span class="line"></span><br><span class="line">    rightsums = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    maxright = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        rightsums[i] = rightsums[i+<span class="number">1</span>] + A[i]</span><br><span class="line">        maxright[i] = max(maxright[i+<span class="number">1</span>],rightsums[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N<span class="number">-1</span>):</span><br><span class="line">        ans = max(ans, leftsums[i<span class="number">-1</span>]+maxright[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="变号法">变号法</h3><p>本方法将双区间的序列和转化为整个数组的总和减去单区间子段和，其值为<span class="math inline">\(S - \sum_{k=i}^jA_k\)</span>，该值的最大值为后者取最小值时的值，问题变成求解数组元素i到j的最小值，将数组元素全体乘以-1，则变成求解最大值，可套用kadane算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(gen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(gen) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = cur = gen[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> gen[<span class="number">1</span>:]:</span><br><span class="line">            cur = i + max(cur,<span class="number">0</span>)</span><br><span class="line">            ans = max(ans,cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    alls = sum(A)</span><br><span class="line">    ans1 = kadane(A)</span><br><span class="line">    ans2 = alls + kadane([-A[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)<span class="number">-1</span>)])</span><br><span class="line">    print(alls,ans1,ans2)</span><br><span class="line">    <span class="keyword">return</span> max(ans1,ans2)</span><br></pre></td></tr></table></figure><h3 id="前缀和优先队列">前缀和+优先队列</h3><p>因为数组A的循环子段必然是数组B=A+A的子段，所以可将数组拼接一次在求单区间的最大子序列和，只需满足子序列长度不超过原数组长度。 对于子序列<code>B[i+1:j+1]</code>，其和为<code>P[j]-P[i]</code>，这里我们固定j，找出使P[i]最小的i值，可通过优先队列实现，这里通过在插入元素时比较当前元素与队列末元素的大小进行插入处理，手动实现优先队列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(A)</span>:</span></span><br><span class="line">    P = A * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        P[i] = P[i] + P[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque([<span class="number">0</span>])</span><br><span class="line">    ans = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        i = queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> j-i &gt; len(A):</span><br><span class="line">            queue.popleft()</span><br><span class="line">            i = queue[<span class="number">0</span>]</span><br><span class="line">        ans = max(ans, P[j]-P[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> P[queue[<span class="number">-1</span>]] &gt; P[j]:</span><br><span class="line">            queue.pop()</span><br><span class="line"></span><br><span class="line">        queue.append(j)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;source: &lt;a href=&quot;https://leetcode-cn.com/problems/maximum-sum-circular-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Sum Circular Subarray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;difficulty: Medium&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.&lt;/p&gt;
&lt;p&gt;Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, &lt;code&gt;C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length&lt;/code&gt;, and &lt;code&gt;C[i+A.length] = C[i] when i &amp;gt;= 0&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray &lt;span class=&quot;math inline&quot;&gt;\(C[i], C[i+1], ..., C[j]\)&lt;/span&gt;, there does not exist &lt;span class=&quot;math inline&quot;&gt;\(i &amp;lt;= k_1, k_2 &amp;lt;= j\)&lt;/span&gt; with$k_1 mod A.length = k_2 mod A.length $.)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="LeetCode" scheme="http://scottyeung.top/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://scottyeung.top/tags/DP/"/>
    
      <category term="最大子序列和" scheme="http://scottyeung.top/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>谈谈牙齿</title>
    <link href="http://scottyeung.top/2020/%E8%B0%88%E8%B0%88%E7%89%99%E9%BD%BF/"/>
    <id>http://scottyeung.top/2020/谈谈牙齿/</id>
    <published>2020-01-03T11:43:59.000Z</published>
    <updated>2020-01-05T02:17:30.695Z</updated>
    
    <content type="html"><![CDATA[<p>周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。</p><a id="more"></a><p>因为来得比较早，加上只是挂了个普通号，比较快就看上了。拍了个牙片，给医生看了看，病情和治疗方式基本如之前设想的一样，需要做根管治疗。所谓的根管治疗，是将牙齿内部的根管/神经清理干净，彻底清理消毒后，填入消毒材料进行填充。根管治疗后牙齿因为失去神经/根管的营养，会比较脆弱，需要加个牙冠。在医生再三向我强调根管治疗的注意事项以及协商了时间之后，我签署了同意意向书，开始治疗。给我看牙的是一个很温柔的女医生。暂时的治疗只是在病牙上打了一个洞，对牙齿内部进行了药物冲洗，让其暴露几天，流出之前的发炎的分泌物。治疗后就不怎么痛了，不过仍然要进行后续的治疗。</p><p>一直以来，我的牙齿都不是特别的好，这也已经不是第一次牙齿出问题了。在小的时候，对于牙齿不是很重视，在没换牙之前，牙齿就出过问题，换了牙之后，也出过不少的问题。在中考结束后，第一次补了牙，当时是因为大牙出现冷热酸痛。后面陆续补过几个牙，之后才开始重视牙齿问题。但已经感到有点为时已晚。个人感觉小地方的牙医诊所有些不足的地方：一是治疗追求治标，蛀牙了便补，牙痛了便打开杀神经再补，再痛就再来一次。二是没有一个很好的教育预防理念，牙痛/蛀牙去看牙，都是帮你补了就算，也没有告诉你成因，提醒了你应该怎么做，更不会顺便检查你的其它牙齿，最有趣的是我箍牙的时候的医生，经常跟我说我没有好好刷牙，但事实是我刷的认真且勤快，他也不给出具体的解释或者补充。</p><p>大一的时候也有出现过牙痛的状况，寒假的时候以为是普通的小事就忍了忍，开学就发作，也是跑去了武大口腔，两个连着的牙齿蛀了，其中一个还疑似深髓，可能要根管，当时对于金钱还比较敏感（也可以说是没这么多钱），听到要可能2000+之后就放弃了在那里治疗，忍了一个学期回去小城市治，方法就是普通的去除蛀牙部分，补牙，痛了就下杀神经的药，下周再来，陆续也治了三周，最后不痛了，也不知道是不是就算是治好了。</p><p>在当时回去治疗之前，上网看牙齿相关的资料，发现了一本很有趣的书 <em>Cure Tooth Decay: Heal &amp; Prevent Cavities with Nutrition</em> 是说用营养学来治疗牙齿疾病的，中心内容就是多吃富含脂溶性维他命的东西，鱼肝油，无机盐钙和镁，少吃升血糖指数高的和植酸食物。书中其实没给出什么比较科学的解释，基本都是通过一些资料/实际情况做的实证研究/统计，试了下，也就那样，该疼还是疼。</p><p>在这次痛的过程中，我又重新翻了翻这本书，又上网搜了搜这本书，结果在豆瓣找到了一个对于这本书的读者&amp;实证者，此处贴出他的一篇<a href="http://blog.sina.com.cn/s/blog_6e979bb90100mnf0.html" target="_blank" rel="noopener">文章</a> 基本上就是在上面的营养防治的理论的完善补充。为什么会蛀牙，出现牙病，原因无非是细菌繁殖在我们的牙齿上，造成了酸性的环境，腐蚀我们的牙齿。一直以来的理论，都是让我们通过刷牙来消灭这些细菌，但对于有些人，例如我，效果就属实一般，即使是使用电动牙刷+牙线+漱口水，该蛀还是得蛀。采用营养学的方法是另一种思路，通过加固/恢复我们的牙齿，进行防治。一方面，还是需要使用牙线+冲牙器清洁牙齿，去除细菌，但另一方面，还需要补充一些营养来恢复牙齿，加固牙齿。 书中给出的主要方法是： - 使用牙线 + <strong>冲牙器</strong> 来保持牙齿的清洁 - 补充维生素<span class="math inline">\(K_2\)</span>和<span class="math inline">\(D_3\)</span>帮助牙齿吸收钙质元素 - 补充钙和镁等矿物质 - 尽量避免摄入酸性物质，对牙齿有腐蚀作用的食物</p><p>感觉还是挺有道理的，可以尝试一下。不过这些方法感觉都只能用在预防上面，当牙齿真的出了问题，还是建议去大医院好好地看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="生活" scheme="http://scottyeung.top/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="牙齿" scheme="http://scottyeung.top/tags/%E7%89%99%E9%BD%BF/"/>
    
  </entry>
  
  <entry>
    <title>&lt;唤醒大脑：神经可塑性如何帮助大脑自我疗愈&gt; 读书笔记</title>
    <link href="http://scottyeung.top/2019/%E5%94%A4%E9%86%92%E5%A4%A7%E8%84%91%EF%BC%9A%E7%A5%9E%E7%BB%8F%E5%8F%AF%E5%A1%91%E6%80%A7%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E5%A4%A7%E8%84%91%E8%87%AA%E6%88%91%E7%96%97%E6%84%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://scottyeung.top/2019/唤醒大脑：神经可塑性如何帮助大脑自我疗愈-读书笔记/</id>
    <published>2019-12-30T09:53:48.000Z</published>
    <updated>2019-12-30T09:55:01.194Z</updated>
    
    <content type="html"><![CDATA[<p>本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。</p><a id="more"></a><p>一直以来，大脑都是被认为是一个精密的仪器，一旦某处出现问题，身体就会出现相关的问题，且难以治疗。作者提出，可以利用神经可塑性的方法，使用一些自然的刺激手段，帮助大脑进行自我修复，进而治疗因大脑的问题而出现的疾病，如中风，帕金逊。</p><p>具体的疾病及其治疗如下：</p><h2 id="慢性疼痛">慢性疼痛</h2><p>疼痛其实并不是疼痛源引发疼痛而被大脑感觉到，而是大脑为了警告危险的出现，而发出疼痛的表现来提醒自身。每次疼痛，相应的神经元会进行放电，长期某个位置疼痛，会形成一个习惯，即使身体痊愈，疼痛系统仍然会放电，引发疼痛。</p><p>神经可塑性的一条核心规律是，同时启动放电的神经元是连接在一起的，也就是说，反复的精神体验使大脑处理该体验的神经元产生结构性变化，令神经元之间的突触连接更为强健。反过来也是一样。如果一个人长期放弃执行某一活动，这些连接就弱化了，随着时间的推移，很多连接甚至消失了。这说明了神经可塑性的一条更普遍的原理：用进废退现象。</p><p>疼痛需要大脑的神经元进行处理，因而我们可以通过分散大脑区域的资源，减少处理疼痛的大脑区域。具体可以通过可视化想象的方法来压倒疼痛。处理视觉信息和疼痛的有两个脑区，后扣带回（帮我们从视觉上想象东西所处的空间位置）和后顶叶（也用于处理视觉输入）。</p><blockquote><p>每当疼痛袭来，他就立刻开始可视化想象。但想什么内容呢？他想象的就是自己绘制的脑图，他提醒自己，大脑真的可以改变，好让自己保持动力。他先栩栩如生地想象大脑处于慢性疼痛中的画面，然后观察慢性疼痛过程中脑图有多少地方的神经可塑性在扩展。接着，他会想象启动放电的区域渐渐缩小，看起来就像是大脑没有感到疼痛时的样子。“我必须无情，比疼痛信号本身更无情。”他说。他用大脑疼痛区域缩小的画面迎接每一波疼痛，他知道，必须强迫自己的大脑后扣带回和后顶叶处理视觉图像。</p></blockquote><p>因为神经可塑性用进废退的特点，当每次慢性疼痛出现的过程，通过可视化的方式，分散/避开/减少大脑对疼痛的处理来减轻疼痛，弱化疼痛的感受，久而久之，疼痛的回路弱化，慢性疼痛的现象消失。</p><h2 id="走路疗愈帕金逊综合征的症状">走路疗愈帕金逊综合征的症状</h2><p>帕金逊综合征为大脑黑质出现问题，影响了关于身体活动所需的多巴胺，会导致身体的活动能力丧失，但通过每天坚持锻炼，尤其是走路，可以使身体保持活动的能力，当然这并不是治好帕金逊综合征，药物也不能轻易地减少，但通过保持每天的走路，保持每天的运动量，可以通过另一种方式来保持自身的活动能力。</p><hr><p>其它的章节感觉比较玄乎，篇幅也比较常，待填坑。包括：</p><ul><li>光帮助大脑连接</li><li>帮助自闭患者重新获得会话能力</li><li>一位盲人学会了看</li><li>重新习得发声的能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="大脑" scheme="http://scottyeung.top/tags/%E5%A4%A7%E8%84%91/"/>
    
      <category term="神经" scheme="http://scottyeung.top/tags/%E7%A5%9E%E7%BB%8F/"/>
    
      <category term="疗愈" scheme="http://scottyeung.top/tags/%E7%96%97%E6%84%88/"/>
    
      <category term="疼痛" scheme="http://scottyeung.top/tags/%E7%96%BC%E7%97%9B/"/>
    
  </entry>
  
  <entry>
    <title>&lt;被讨厌的勇气&gt;读书体会与摘要</title>
    <link href="http://scottyeung.top/2019/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%91%98%E8%A6%81/"/>
    <id>http://scottyeung.top/2019/被讨厌的勇气-读书体会与摘要/</id>
    <published>2019-12-19T04:08:40.000Z</published>
    <updated>2019-12-19T04:36:19.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26369699/" target="_blank" rel="noopener">《被讨厌的勇气》</a>通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。</p><p>这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃</p><a id="more"></a><h2 id="正文">正文</h2><ul><li>世界是简单的，人也是简单的。复杂是因为人把世界看得复杂，这就涉及到有无勇气，正视世界的问题</li></ul><h3 id="另一种心理学">另一种心理学</h3><ul><li>另一种心理学：阿德勒心理学，属于目的论，对比于传统心理学流派的原因论，区别相当于想法影响情绪还是情绪影响想法。对于原因论，有几个问题：对于当前遇到的心里问题，一味分析其成因，对于解决问题没有太多实际的意义，如同感冒去看医生，医生只告诉你感冒是因为之前着凉了一样了；给予同样的经历，即原因相同，但是不同人会有不同的结果。目的论讲究目的，认为主要是取决于个人的看待态度与方式。重要的不是经验本身，而是对待经验的方式。换而言之，情绪是可以控制的，情绪只是某些时候特定行为的一个借口。同样，人的性格与本性也是可以改变的，受到自身的观念所影响，很多时候不是不想改变，而是自身不想改变，缺乏面对改变时可能会遇到的陌生与不安的勇气。另外，也担心改变之后失去了对当前不满的状况的解释借口。不去改变，借口没有这个条件才不能实现这件事情，这样就能掩饰自己实现不了这件事的状况。</li><li>自卑感与自卑情结。自卑感是一个很正常的感受，每个人都会有，健康的自卑感应该来自当前的自己与理想中自己的落差，而不应该来自与他人的对比。通过健康的自卑感，我们可以找到自己努力成为更好的自己的方向 。至于自卑情结，则是一种不健康的状态，由不健康的，过度的自卑感来形成。带有自卑情结的人，往往会将生活遇到的问题，对当前状况的不满，归结于当前所拥有的自卑感。因为在某些条件上处于落后，感到自卑，所以在某些事情上面失败就有理由了，要不是那样，我就怎么样了。因为有着可以逃避的借口，带有自卑情结的人会一直处于这种自卑的状态来保护自己。另外，自卑情结还会带来：权势张越，因为自身的不自信，所以需要通过一些外在的事物/功绩来夸耀自己；弱者保护，我弱我有理，因为我弱，所以我做出了某些成绩我就是了不起，做不出来的话则是我本应如此。</li></ul><h3 id="关于竞争">关于竞争</h3><ul><li>竞争应该是在一张平面上各人沿着自己的方向按照自己的速度前进，竞争的对象应该是自己，而不是其他人。每个人的速度不一样，必然有人走在前面，有人走在后面。走在前面的未见得能够一直保持走在前面，如果选择了不当的对比对象，只能造成自身长久的失败感。另外，将他人放在竞争对手的位置上面，很难够成为真正的伙伴。竞争必然存在输赢，有时候我们不能发自内心地为他人的成功高兴，就是因为将其放在竞争对手的位置上面，因而会有他人的成功等同于自身的失败这种想法。</li><li>基于上面的原因，也没有必要与人争执，尤其是争执的程度发展到企图通过发怒来解决。发怒不只是情绪，其实也是你的一种表达方式，一种不太好的表达方式，遇到争执时，可以通过发怒来表达，但效果没有通过言语沟通交流来得好。所以遇到争执无法解决时，不妨承认错误，以免事情的讨论上升到人身的讨论，变成你对我错的二元选择。当你坚信是对的话，别人持什么样的态度都无法改变你的观点。</li></ul><h3 id="关于人生">关于人生</h3><ul><li>人生行为的两大目标：自立和与社会和谐相处。而支持这些想法的也有两个心理目标：我有能力的意识和人人都是我的伙伴的意识。这些目标可以通过直面人生课题来解决，包括工作，交友，爱。</li><li>人生的谎言。我们常常为逃避生活中遇到的事情而寻找开脱的谎言和借口。一个很典型的例子，不是因为某人的缺点而讨厌某人，而是因为讨厌某人而自然就会去发现其缺点，归根到底，实在逃避糟糕的人际关系。我讨厌某人，不愿与某人相处，我发现到他有什么缺点，因为他有这些问题，我就可以离他远点，不用相处。</li><li>否定寻求他人认同的行为和想法，我们没有必要总是想着需要满足他人的期待。每个人都只是为了自己活着，而非为了其他人活着。但在实际生活中，好多人都无法做到这一点，甚至可能会事事都想着得到他人的认同，从而被他人影响自身的行为，不得不做许多并不情愿的行为。</li><li>工作课题的分离。所谓的工作课题，为每个人各自应该要做的事情，不同人，具有不同的身份，处于不同的位置都具有不同的工作课题，我们不应该干涉他人的工作课题，也不应该被他人干涉。如何判断工作课题属于谁？谁将承担后果就由谁来处理。当我们在日常生活中陷入困境或对现状不满时，我们不妨想一想有没有进入到他人的课题中，如果有，果断抛开，进行分离。正如上面说到的让他人满意，他人接受，这不应该是你的课题，你做完了自己的工作就已经足够，他人是否接受，如何评价，会否反对，都是他人的课题，你不应该操心，操心也没有用。而如果你操心了他人的课题，选择采取额外的工作或者改变来迎合他人，则只会增加自己的不满。另外，因为工作课题的分离，我们的责任也可以随着不干涉他人的课题一并减轻。</li><li>但是，有些人却对着这种所谓的责任存有留恋，并认为这种操心他人课题的责任能够有利于他人的成长。就像家长操心孩子的成长，干涉孩子的成长的课题，以是为了孩子好的理由，为其铺排好一切道路。是选择带着不满接受父母为其铺排好的可能较大几率有着较好前程的道路，还是自由地选择自己想要的道路，这取决于个人的选择，没法给出一个确定的答案。但前者的所谓较好前程，难道不是在满足他人的认可和期待吗？尽管如此，很多人可能还是会倾向于前者，因为不需要自己做出选择，可能是因为确实迷茫不知道如何选择，更有可能是因为前者不需要自己亲自做出选择，选择都不是我做的，如果结果不好的话，我能够有埋怨的对象，“都说了不这样”。</li></ul><h3 id="关于勇气">关于勇气</h3><ul><li>被讨厌的勇气。我们不可能做到不被所有人讨厌，自由就是被别人讨厌。每个人都有寻求认可的倾向性，而从中寻求解脱就是获取自由。当否定了寻求他人的认可之后，必然会存在有人不认可你，进而产生讨厌的念头。我们对此无能为力，也无须担心。他人是否讨厌我，这是他人的课题，我操心不来，而如果为其改变了自己，则违背了工作课题分离的原则，徒增自身的麻烦。</li><li>人的一切烦恼皆来自于人际关系。即便如此，在我们的人生课题中，我们还是无法避免人际关系，尤其是我们在社会中其实均处于一个共同体当中。所谓的共同体，可以大至一个国家，也可以小至一个两人的家庭。我们应该主动参与到共同体当中，这也课题分离并不矛盾，共同体并不唯一，也不存在非加入不可的共同体。基于此，当我们在某一共同体中出现不满或者矛盾，我们可以及时离开这一个共同体，将目光转向更大的，别处的共同体。</li><li>不应该批判，也不应该表扬。因为批判和表扬很容易将自身和他人放入一种纵向的关系当中，我对你进行批判或表扬，暗含着我有这个能力，暗示着我比你高一等的感觉，我可以批判你，也可以表扬你，带有一种操纵干涉的味道在此。值得提倡的，是鼓励。鼓励，是站在横向关系的角度。大多数人并不是缺乏解决问题的能力，而是缺乏面对问题的勇气，而鼓励，正是帮助对方意识到问题的本质，帮助他人寻找面对的勇气。</li><li>每个人都会受到自我意识羁绊，不能无拘无束的活动。正如在他人的面前，我们会很小心自己的言行，生怕影响了在他人面前的印象，但是只有自己一个人独处的时候，就会将其压抑完全暴露。本质上，我们是缺乏暴露本真的自己在他人面前的勇气。为此，我们需建立共同体感觉，所谓共同体感觉，就是对自我的执着，转化为对他人的关心。建立共同体感觉，需要从下面三点做起：自我接纳，他者信赖，他者奉献。</li><li>所谓的自我接纳，正如其本身的意思，就是接纳真实的自我，意识到自己能做什么，做不到什么。这是一种肯定性的达观，对于无法改变的，淡然接受，可以改变的，勇敢地取面对它。所谓的他者信赖，即是在人际关系中需要建立无条件的信赖关系，信任遭到了背叛怎么办，还是需要保持这种无条件的信赖关系，是否背叛这个属于他人的课题，我们不应该操心，但是若果多次背叛你，使你不愿与其继续相处，可以及时断绝关系，进行分离。他者奉献，则是在向作为伙伴的他人奉献的过程中找到自己的价值，区别于寻求他人的认同，我们所做的事情是否有价值，不是由他人来评价的，而是由自己的内心来决定。这里要将贡献和作用区分开来，你做出的贡献，判断其是否具有作用，这是他人的课题，我们只需将目光集中在自己的贡献即可。我做了某些事，我觉得自己对他人，对共同体都是有奉献的就可以了。</li><li>犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。”如果我们总是将目光只集中在事物的部分来决定其总体，我们则无法获得人生的和谐。另外，只将目光集中在人生的特定侧面，也是如此，例如工作狂。</li></ul><h3 id="关于幸福">关于幸福</h3><ul><li>相比于设定一个远大目标，然后当下一直为其进行铺排和准备，我们更应该活在当下，活在此时此刻。人生不应该是一条线，并不是设定一个个的目标点，就能将自身和人生中的一个个阶段，一个个目标点连接起来的。如果只为了所谓的远大目标，我们在目标达成前所做的一切都只是在忍受获得成功的痛苦，这样是不理智的，万一失败了，到达不了终点呢？当前的忍受皆是白费？我们应该将人生看成是一个个不连续的点，每一个不连续的点都是当下，只有集中于当下，专注于此时此刻所做的事情，不考虑过去与将来，我们才能够获得长久的幸福感。正如登山，从踏出的第一步就开始了个人的旅途，如果我们只是一心想着登到山顶，那么途中的一切乐趣就会丢失，还不如直接坐缆车到山顶。</li><li>专注于此时此刻，不考虑过去与将来，我们能够很自由地活在当下，享受当下，但是，我们可能会感到迷茫，如何选择人生的方向呢，也就是下一个此时此刻怎么选择？答案是他者奉献。无论你过着怎样的刹那，即使有人讨厌你，只要没有迷失“他者贡献”这颗引导之星，那么你就不会迷失，而且做什么都可以。即使被讨厌自己的人讨厌着也可以自由地生活。而且，我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26369699/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《被讨厌的勇气》&lt;/a&gt;通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。&lt;/p&gt;
&lt;p&gt;这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="心理学" scheme="http://scottyeung.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="幸福" scheme="http://scottyeung.top/tags/%E5%B9%B8%E7%A6%8F/"/>
    
      <category term="阿德勒" scheme="http://scottyeung.top/tags/%E9%98%BF%E5%BE%B7%E5%8B%92/"/>
    
      <category term="人生" scheme="http://scottyeung.top/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Some Notes About SQLAlchemy</title>
    <link href="http://scottyeung.top/2019/Some-notes-About-Sqlalchemy/"/>
    <id>http://scottyeung.top/2019/Some-notes-About-Sqlalchemy/</id>
    <published>2019-12-07T02:24:35.000Z</published>
    <updated>2019-12-07T04:00:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。</p><p>SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求： - 提供对数据库的常用操作：增删改查 - 提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据</p><a id="more"></a><h2 id="数据库连接">数据库连接</h2><p>SQLalchemy不能支持操作数据库，因而需要安装额外的数据库驱动，对于不同的数据库与驱动，有着不一样的配置URI，总体格式为<code>dbms://user:pwd@host/dbname</code>。这里用的Mysql+mysqlconnector，具体的连接代码如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">sql_connection = &apos;mysql+mysqlconnector://root:pwd@localhost:3306/database&apos;</span><br><span class="line">engine = create_engine(sql_connection)</span><br><span class="line"></span><br><span class="line"># 执行sql事务需要使用会话</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line"># 结束前需要关闭session</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><h2 id="结构定义">结构定义</h2><p>在SQLalchemy中，ORM通过定义对象进行数据库model的绑定。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relation, sessionmaker</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"> </span><br><span class="line">class Movie(Base):</span><br><span class="line">    __tablename__ = &apos;movies&apos;</span><br><span class="line"> </span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    title = Column(String(255), nullable=False)</span><br><span class="line">    year = Column(Integer)</span><br><span class="line">    directed_by = Column(Integer)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    def __init__(self, title=None, year=None):</span><br><span class="line">        self.title = title</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure></p><ul><li>ORM的model类通过继承declarative_base进行定义，通过<code>__tablename__</code>绑定到对应的table</li><li>每一个Column属性为表中的一列，需要设置类型，类型必须要与数据库中列的类型对应，常用类型有Integer，Float， String（对应varchar），Text</li><li>必须设置一个属性/列为<code>primary_key</code></li><li>可以通过<code>Base.metadata.create_all(engine)</code>创建table</li></ul><h2 id="数据操作">数据操作</h2><p>数据使用ORM进行操作，操作的基本单位为对象（也可以直接使用sql语句，但对于常用操作来说没有必要）。除查询外，对数据库有修改的操作都需要commit事务</p><h3 id="插入">插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 = Movie(&quot;Star Trek&quot;, 2009)</span><br><span class="line">session.add(m1)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><ol type="1"><li>创建待插入的对象，添加相应的数据属性</li><li>添加进session中</li><li>提交session，提交事务</li></ol><h3 id="查询">查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movies = session.query(Movie).all() # 获取所有数据</span><br><span class="line">movie = session.query(Movie).get(movie_id) # 获取单个记录</span><br><span class="line">filter_movie = session.query(Movie).filter(Movie.id == 1).one()</span><br></pre></td></tr></table></figure><ul><li>查询中query的参数为查询的table/返回的对象</li><li>filter等于where语句，可以对查询结果进行进一步筛选，one返回唯一行，all则返回所有行</li></ul><h3 id="更新">更新</h3><p>查询出来的数据，修改属性后重新提交事务即可。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">movie.year = 1999</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="删除">删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">session.delete()</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><h2 id="some-problems">some problems</h2><h3 id="大批量数据插入">大批量数据插入</h3><p>在使用的过程中，遇到一次需要插入三十多万条数据到数据库的情况。在此之前，我一直都是插完数据再一起commit的（几千/几百条），因为每次commit需要写入数据库，会比较慢（磁盘IO制约）。 但这次数量过多的话，提交的时候出现错误，提示mysql的连接丢失。估计是写入的时间太多，时间太长超出了其限制，进而断开了连接。于是我选择批量commit，在添加一定数量数据后提交一次（5000/1000/500/100/10），但是没有成功，插入一定量的记录后，提示某一条插入的记录的某一列过长（尽管我那一列是不限长度的Text），显然有问题。 上网搜索批量数据插入的方法，但内容基本都是千篇一律，全部都是转载/翻译StackOverflow上的一篇<a href="https://stackoverflow.com/questions/3659142/bulk-insert-with-sqlalchemy-orm" target="_blank" rel="noopener">回答</a>。给出了两种方法 - bulk_save_objects(objects) - add_all()</p><p>都没有效果，最终还是采取了逐条添加并提交的方法，虽然慢了点，但是能work。</p><p>写这件事只是为了吐槽一下现在用Google搜索一些具体的技术问题是，内容严重同质化的现象，大家都抄来抄去，转来转去。像这一次的搜索，最开始的source是在StackOverflow上的提问，然后有网站翻译成了中文并发布（甚至初创，然后就流传于各个中文网站了，一搜，全是这些内容相同的网页，属实恶心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。&lt;/p&gt;
&lt;p&gt;SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求： - 提供对数据库的常用操作：增删改查 - 提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://scottyeung.top/categories/Mysql/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="Mysql" scheme="http://scottyeung.top/tags/Mysql/"/>
    
      <category term="sql" scheme="http://scottyeung.top/tags/sql/"/>
    
      <category term="生产力" scheme="http://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="SQLAlchemy" scheme="http://scottyeung.top/tags/SQLAlchemy/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Automate the Boring Stuff with Python</title>
    <link href="http://scottyeung.top/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/"/>
    <id>http://scottyeung.top/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/</id>
    <published>2019-11-04T08:15:25.000Z</published>
    <updated>2019-11-12T14:48:29.983Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://automatetheboringstuff.com/#toc" target="_blank" rel="noopener">本书</a>是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。</p><p>作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。</p><a id="more"></a><p>本书结构分为三部分： 1. 开头首先解释了为什么可以用编程提高效率以及为什么选择Python 2. Python的学习 3. Python在日常生活/工作的具体使用</p><p>鉴于笔者已经学习过Python，故直接跳过前两部分，进行阅读记录。</p><h2 id="读写文件">读写文件</h2><h3 id="文件">文件</h3><ul><li>程序运行时，数据可以存储变量中，但若想持久地存储数据，则需存储在文件中</li><li>文件的表示由路径+文件名组成</li><li>Windows系统路径使用而Linux/Mac使用/，为确保代码能统一运行，可使用<code>os.path.join</code>进行连接路径</li><li><code>os.path.getsize</code>获取文件大小</li><li><code>os.listdir</code>获取文件夹内容</li><li>文件按内容可分为文本文件和二进制文件</li></ul><h3 id="读写">读写</h3><ul><li>过程<ol type="1"><li><code>open(path, mode='r')</code>打开文件返回<code>File</code>对象</li><li>通过<code>read</code>或<code>write</code>对文件对象进行读写</li><li><code>close</code>关闭文件对象</li></ol></li><li>文件打开分为读(r)，写(w)，追加(a)</li><li>read以字符串形式返回整个文件内容，readline逐行返回</li><li>可通过<code>shelve</code>模块进行变量的读取和保存</li></ul><h3 id="实例">实例</h3><h4 id="随机生成测试文件">随机生成测试文件</h4><p>地理老师打算给35个学生出一份关于美国50个州对应的城市的选择题，目标形式为35个测试题文件，35个对应的答案文件，要求是35份选择题不一样，其中题目顺序不一样，选择题选项不一样。</p><ol type="1"><li>将测试数据以<code>dict</code>的形式存储在文件中/输入代码中</li><li>创建测试文件和答案文件，并写入首部信息</li><li>随机函数打乱数据给出的州的顺序，选出对应的城市，在给出的城市数据中删去正确答案，随机选出3个作为错误答案</li><li>将3中得到的州以及选项城市写入测试文件和答案文件</li></ol><h4 id="多重剪贴板">多重剪贴板</h4><p>当需要多次进行复制粘贴时，下次的复制内容会把上一次的内容给覆盖，这样当需要重复使用复制内容时就很不方便。因此，实现多重剪贴板的功能，可以记录过往的复制内容，便于重复使用。</p><ol type="1"><li>每次运行程序时通过<code>shelve</code>读取本地的变量数据</li><li>根据输入的参数判断执行的功能</li><li>当需要记录剪贴板时，调用<code>pyperclip.paste</code>获取当前剪贴板内容，并存至变量</li><li>当需要展示历史剪贴板内容时，将存储的变量列表或单个变量转化为字符串通过<code>pyperclip.copy</code>复制进剪贴板</li></ol><h2 id="整理文件">整理文件</h2><p>批量处理文件，包括遍历，复制，重命名，移动或压缩。主要使用<code>shutil</code>模块</p><ul><li>复制：<ul><li>shutil.copy</li><li>shutil.copytree</li></ul></li><li>移动：<ul><li>shutil.move</li></ul></li><li>删除<ul><li>os.unlink</li><li>os.rmdir 空目录</li><li>os.retree 目录所有</li></ul></li><li>遍历 os.walk 返回迭代器关于 current_folder,sub_folders,files</li><li>压缩 zipfile模块</li></ul><h3 id="实例-1">实例</h3><h4 id="文件名字转换">文件名字转换</h4><p>将数千个文件的名字中的美式时间 (MM-DD-YYYY)改为欧式时间  (DD-MM-YYYY)</p><ol type="1"><li>构造正则表达式用于识别时间</li><li>遍历目录的名字 <code>os.listdir</code>，并通过正则表达式进行识别，并将其分割</li><li>若满足正则表达式，则通过shutil.move改名</li></ol><p>相关任务 - 批量文件名字添加前缀</p><h4 id="文件夹压缩">文件夹压缩</h4><p>将指定文件夹及其下所有文件和文件夹压缩</p><ol type="1"><li>寻找一可用不重复的压缩路径+文件名</li><li>创建压缩文件</li><li>遍历目录，将所有文件和文件夹写入压缩文件</li><li>关闭压缩文件</li></ol><h2 id="web爬取">WEB爬取</h2><p>设计模块 - webbrowser - open 打开网页 - request - get 获取资源 - raise_for_status 判断是否就绪 - iter_content 获取内容的迭代器 - Beautiful Soup 解析HTML文档 - select - Selenium</p><h3 id="实例-2">实例</h3><h4 id="批量打开网页">批量打开网页</h4><p>根据给出的地址批量打开Google Map的网页</p><ol type="1"><li>根据给出的地址生成URL地址</li><li>使用<code>webbrowser.open</code>打开URL地址的网页</li></ol><h4 id="搜索关键词">搜索关键词</h4><p>根据关键词进行google搜索，并将搜索结果的每一个页面打开</p><ol type="1"><li>根据关键词使用<code>request.get</code> 请求搜索结果页面</li><li>使用Beautiful Soup解析页面，找出所有搜索结果的超链接</li><li>使用<code>webbrowser.open</code>打开获取的超链接</li></ol><p>类似用途： - 打开购物页面所有商品的页面 - 打开商品的所有评价页面 - 获取搜索图片的所有结果</p><h4 id="下载网页漫画">下载网页漫画</h4><p>下载XKCD的漫画，下载完后下载上一页，直至下载完第一页后结束</p><ol type="1"><li>获取XKCD的网页，抽取漫画部分写入文件</li><li>找到上一页按钮的超链接，并获取上一页的漫画网页</li><li>重复1-2直至找不到上一页按钮</li></ol><h2 id="操作excel">操作Excel</h2><p>利用第三方模块<code>openpyxl</code>，进行excel文件的读写</p><ul><li>load_workbook</li><li>get_sheet_by_name</li><li>cell(row=1, column=2)</li><li>save</li></ul><h3 id="实例-3">实例</h3><h4 id="读取excel并统计数据">读取Excel并统计数据</h4><p>根据Excel文件的数据，进行聚类分析，分别进行聚类计数以及聚类求和。 事实上，Excel本身功能即可完成并且更加简单，故跳过。</p><h4 id="更新excel文件中指定列">更新Excel文件中指定列</h4><p>读取Excel文件，遍历每一行，如果该行为指定商品，则修改其价格</p><h2 id="操作pdf">操作PDF</h2><ul><li>打开PDF文件并提取文本</li><li>PDF文档解密——输入密码</li><li>文档加密</li><li>创建pdf文件，添加页面</li><li>pdf页面合并——添加水印</li></ul><h3 id="实例-4">实例</h3><h4 id="多个pdf文档指定页面合并">多个PDF文档指定页面合并</h4><p>选择目录下所有PDF文档的非首页按照字典序合并到一个新的PDF文档中</p><ol type="1"><li>获取当前目录所有文件名，并取出以.pdf结尾的文件名添加至数组</li><li>数组根据文件名排序</li><li>按顺序打开每一个PDF文档，每一个文档读取从第二页开始读取，添加至新文档</li><li>保存新文档</li></ol><h2 id="操作csv和json">操作CSV和JSON</h2><h3 id="csv">CSV</h3><p>通过csv模块，可以进行csv的读写。读取类似于一个二维数组，写可以通过write_row写入行。</p><h4 id="实例-5">实例</h4><p>读取目录下所有csv文件的数据，去除首部信息</p><ol type="1"><li>获取目录所有文件名，并进行遍历，非csv文件跳过</li><li>打开csv文件，读取csv数据，跳过第一行，其余的行添加进数组</li><li>将数组中的行以csv方式写入新文件</li></ol><h3 id="json">JSON</h3><p>Json为常用的一个数据格式，多用于API之间进行交互，但日常生活中用得比较少。通过json模块，可以将json格式的字符串转成dict。</p><h4 id="获取实时天气数据">获取实时天气数据</h4><p>通过网上提过的天气服务接口，获取指定地点的实时天气情况</p><ol type="1"><li>通过命令行获取地点输入</li><li>将地点作为参数向指定天气服务API发送HTTP请求</li><li>解析返回的json数据，进行输出</li></ol><h2 id="操作email">操作Email</h2><h3 id="实例-6">实例</h3><p>根据Excel表格中的会员数据情况，给其中尚未支付本月会籍费用的会员发送邮件进行提醒</p><ol type="1"><li>打开Excel文件读取会员数据，判断最后一列是否为paid，若是，则记录会员名与邮箱地址</li><li>通过模块smtplib登录邮箱，跟根据上一步记录的信息一一发送邮件</li></ol><h2 id="自动化操作鼠标和键盘">自动化操作鼠标和键盘</h2><p>通过第三方模块pyautogui实现，可进行图形界面的相关操作：</p><ul><li>控制鼠标以指定速度移动</li><li>获取鼠标位置</li><li>鼠标进行交互操作<ul><li>点击</li><li>拖动</li><li>滚动</li></ul></li><li>截屏</li><li>图像识别</li><li>键盘按下/松开 指定键/组合键</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://automatetheboringstuff.com/#toc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本书&lt;/a&gt;是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。&lt;/p&gt;
&lt;p&gt;作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="生产力" scheme="http://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="自动化" scheme="http://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="编程学习" scheme="http://scottyeung.top/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>summary of &lt;斯坦福高效睡眠法&gt;</title>
    <link href="http://scottyeung.top/2019/summary-of-%E6%96%AF%E5%9D%A6%E7%A6%8F%E9%AB%98%E6%95%88%E7%9D%A1%E7%9C%A0%E6%B3%95/"/>
    <id>http://scottyeung.top/2019/summary-of-斯坦福高效睡眠法/</id>
    <published>2019-10-28T04:06:02.000Z</published>
    <updated>2019-11-12T14:48:29.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="睡眠的质比量重要">睡眠的质比量重要</h2><h3 id="睡眠的长短">睡眠的长短</h3><ul><li>睡眠的时间长短由基因决定，过长过短均不好</li><li>睡眠时间过长也没什么用</li><li>睡眠时间过短会导致睡眠债务，会引发<ul><li>肥胖/糖尿病/高血压等等疾病</li><li>突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险</li><li>影响寿命</li></ul></li><li>睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间</li></ul><a id="more"></a><h3 id="睡眠的质量">睡眠的质量</h3><ul><li>睡眠分为REM与非REM阶段，后者为深层睡眠</li><li>睡眠的质量取决于入睡后90分钟的非REM阶段</li><li>better than nothing：马上行动改变</li></ul><h2 id="睡眠的重要性">睡眠的重要性</h2><ul><li>睡眠的作用<ol type="1"><li>让大脑和身体休息</li><li>整理记忆</li><li>调节激素平衡</li><li>提高免疫力</li><li>排出大脑废弃物</li></ol></li><li>睡眠质量的认知<ul><li>失眠不只是睡的量的问题，更是质的问题</li><li>睡眠障碍（呼吸暂停）——腹式呼吸帮助</li></ul></li></ul><h2 id="睡眠法则">睡眠法则</h2><ul><li>困了就睡</li><li>保证睡眠前90分钟的黄金时间<ul><li>尽快入睡进入深层睡眠</li><li>不被打扰</li></ul></li><li>体温开关：降低体表温度，缩小体表与体内温差</li><li>大脑开关：创造一个良好的睡眠环境，以营造一个睡眠的仪式感</li></ul><h2 id="高效睡眠法">高效睡眠法</h2><ul><li>体温开关：营造体温下降这一过程，帮助入睡，具体一般为睡前先提高温度，再自然下降<ul><li>洗澡</li><li>足浴</li><li>调节室温</li></ul></li><li>脑部开关：切换到要睡觉的状态，大脑放空<ul><li>单调</li><li>数羊</li></ul></li><li>睡眠禁区：平常睡觉时间前两小时不想睡觉<ul><li>导致睡眠时间挪前难，一般只能一小时</li><li>需要早起时也不要强行早睡</li></ul></li></ul><h2 id="清醒战略">清醒战略</h2><ul><li>清醒开关<ul><li>光：光遏制褪黑素 清醒 太阳光</li><li>体温：清醒时体温上升</li></ul></li><li>具体战略<ul><li>两个闹钟设在起床时间前后20-40分钟，避开在深度睡眠醒来</li><li>远离睡眠诱惑因素</li><li>光脚</li><li>冷水洗手</li><li>咀嚼</li><li>咖啡因</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;睡眠的质比量重要&quot;&gt;睡眠的质比量重要&lt;/h2&gt;
&lt;h3 id=&quot;睡眠的长短&quot;&gt;睡眠的长短&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;睡眠的时间长短由基因决定，过长过短均不好&lt;/li&gt;
&lt;li&gt;睡眠时间过长也没什么用&lt;/li&gt;
&lt;li&gt;睡眠时间过短会导致睡眠债务，会引发
&lt;ul&gt;
&lt;li&gt;肥胖/糖尿病/高血压等等疾病&lt;/li&gt;
&lt;li&gt;突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险&lt;/li&gt;
&lt;li&gt;影响寿命&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="睡眠" scheme="http://scottyeung.top/tags/%E7%9D%A1%E7%9C%A0/"/>
    
      <category term="读书" scheme="http://scottyeung.top/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="生活质量" scheme="http://scottyeung.top/tags/%E7%94%9F%E6%B4%BB%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何克服过于在意别人想法的心理</title>
    <link href="http://scottyeung.top/2019/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%87%E4%BA%8E%E5%9C%A8%E6%84%8F%E5%88%AB%E4%BA%BA%E6%83%B3%E6%B3%95%E7%9A%84%E5%BF%83%E7%90%86/"/>
    <id>http://scottyeung.top/2019/如何克服过于在意别人想法的心理/</id>
    <published>2019-10-23T01:24:35.000Z</published>
    <updated>2019-11-12T14:48:29.988Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。</p><a id="more"></a><h2 id="表现">表现</h2><p>过于在意他人看法的人，往往： - 会以别人的评判标准来看待自己，试图以此满足他人期待 - 别人的评价对自己情绪影响很大 - 不知道也不会表达自己的需求 - 一定程度的讨好别人的倾向</p><h2 id="原因">原因</h2><ol type="1"><li>害怕得罪别人<ul><li>害怕起冲突</li><li>害怕无法满足他人的期待</li></ul></li><li>自卑</li><li>敏感。心理承受能力差</li><li>将自己与他人对比</li><li>不能接纳自我。我们应该拥有无条件自尊，有条件的自尊只是在用一个找到的标准安慰自己<ul><li>依赖性自尊。依靠别人的评判标准</li><li>独立性自尊。按照自己的标准要求</li><li>无条件自尊。无条件完全接纳和尊重自己</li></ul></li><li>试图成为别人</li></ol><h2 id="解决">解决</h2><ol type="1"><li><p>别人没那么在乎你。 过于在意别人的想法本质上是自己将别人的想法看得太重要，把别人想法的后果看得太重要。因此，我们需要意识到，并没有多少人再关注你，对你有什么看法。不妨换位思考，看看你对他人是否有想法，有想法又能维持多久，他人对你的这个想法又有什么影响。他人的想法是没有任何实质性的影响，即使有，也是因为自己在意而产生影响。所以，我们需要<strong>不在意他人的看法</strong>，而一个重要的前提是：能够客观地分析自己的行为，有自己正确的看法。</p></li><li><p>明确自己才是最重要的。 活着本身是为了自己，如果不能够为了自己而活，那么你的一生相当于白过。所以，为了自己而活，我们完全有权利自私，完全可以把自己放在首位。</p></li><li><p>将自己的需求放在第一位，不必为了成全别人委屈自己。 接上上一条，因为自己是最重要的，顺带自己的需求也是最重要的。很多时候我们会因为外在的很多因素而受到制约，默默忍受。例如有些时候尽管很生气，也不敢表达出来，害怕伤害到别人，伤害到两者之间的关系，只能自己生闷气。但这种制约你行为的枷锁其实是无理的，别人不遵守你遵守，只能是自己吃亏。</p></li><li><p>不要害怕得罪别人。 不要总是充当老好人的角色，一直和和气气顺从别人，害怕得罪别人。要懂得接受这个事实，不会刻意去得罪别人，但也不怕得罪别人，即使无意得罪了别人，也不会担惊受怕，是我错，便承担，无错则置之不理，甚至反抗。</p></li><li><p>放弃成为更好的人这种幻想。 我们不必被世俗的要求所约束，好的，坏的都不是重要的，最重要的是，你想要的。 &gt; 整个社会，整个人类世界都在推崇和鼓励你要去努力，要变得更好。 于是你开始对自己不满意，你开始讨厌自己，你开始强烈的不能接纳自己。 于是你开始自我否定，开始去追逐社会规定的那些优秀的定义，开始试图去迎合别人的看法，你因此变得很焦虑，你被对自己的不满和自己驱使着不断地向前走，你以为只要达成那些目标你就能轻松了，你就到达终点了，你就圆满了。 但是这一刻却始终不能到来，而你却一直被一种焦虑感控制和驱使着，这样你变得越来越着急，你觉得必须尽快到达那个终点，只有到达那个终点，只有变得更优秀了你才能不再这么焦虑，于是这种着急和焦虑会令你变得越来越浮躁，你会发现你离那些目标越来越远。 而有那么一些人即便是侥幸到达了他所自以为的那个终点，但到达的那一刻他却发现自己好像并没有体会到想象中的那种喜悦和满足，他也并没有放轻松，焦虑与痛苦始终还是如影随形。而他这个时候所体会到的很可能只是一种无边的空虚。</p></li></ol><h2 id="行动">行动</h2><ol type="1"><li><p>记录他人的想法，并且采取相应的行动。 既然在意他人的想法，不妨记录下来，并且逆着他的想法来做，而不是停止做这些事。让自己意识到，他的想法不能改变你的行为。你不想做某件事的理由只有两个：不想做；完成不了。</p></li><li><p>尝试与他人起冲突，并且坚持自己的决定，不被说服。</p></li><li>尝试表达自己的需求<ul><li>自己想要什么/想做什么</li><li>自己的情感</li><li>拒绝别人</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.top/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="心态" scheme="http://scottyeung.top/tags/%E5%BF%83%E6%80%81/"/>
    
      <category term="心理学" scheme="http://scottyeung.top/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="overcome" scheme="http://scottyeung.top/tags/overcome/"/>
    
      <category term="他人评价" scheme="http://scottyeung.top/tags/%E4%BB%96%E4%BA%BA%E8%AF%84%E4%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>组会谈话启示录（一）</title>
    <link href="http://scottyeung.top/2019/%E7%BB%84%E4%BC%9A%E8%B0%88%E8%AF%9D%E5%90%AF%E7%A4%BA%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://scottyeung.top/2019/组会谈话启示录（一）/</id>
    <published>2019-10-16T07:50:35.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。</p><a id="more"></a><h2 id="about-empirical-study">About Empirical Study</h2><ul><li>所谓的empirical study，其实就是对收集到的数据进行分析并report，关键是提出Research Question，类似于调查报告</li><li>基本流程为进行问题定义，范围局限，收集数据，分析数据，根据分析结果初步得出RQ/规律/特征，根据RQ重新修改/优化数据收集方式，report并回答RQ</li><li>非常适合新手进行科研入门，可通过此熟悉科研的流程</li><li>即使数据分析没有好的结果，如无规律/相关性，也可如实report成文</li><li>empirical study虽然简单，但是很重要<ul><li>科研入门</li><li>对assumption进行验证</li><li>后续的method/improvement需基于此</li><li>通过此进行数据收集</li></ul></li><li>虽然重要，但不能止于此<ul><li>实质性的东西？（report有什么用？</li><li>套路类似/方法雷同，难度递减</li></ul></li><li>how to start？在确定一个方向之后，拿出一张纸，依次写下研究的对象，定义，范围，数据收集/分析的方法/数据集，<strong>RQ</strong></li></ul><h2 id="about-research">About Research</h2><ul><li>国外的PhD培养方案<ol type="1"><li>刚开始写一篇长篇的survey，借此了解当前该领域的研究背景/问题/方向</li><li>进行empirical study，收集数据，进行分析</li><li>利用前面的积累（数据，知识），进行creative的工作，如method/solution/improvement的提出或修改</li></ol></li><li>国内的现状则是大多数热衷于在3上面，一来就进行method上面的工作</li><li>国内博士的毕业情况还是要较好的，一般都能毕业（当然这个完全取决于导师<del>是否恶心</del></li></ul><hr><p>最后还是想吹一波现在的导师，真的感觉有一个好导师真是太重要了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://scottyeung.top/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="科研" scheme="http://scottyeung.top/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="paper" scheme="http://scottyeung.top/tags/paper/"/>
    
      <category term="经验" scheme="http://scottyeung.top/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Ultralearning</title>
    <link href="http://scottyeung.top/2019/Summary-of-Ultralearning/"/>
    <id>http://scottyeung.top/2019/Summary-of-Ultralearning/</id>
    <published>2019-10-15T12:51:31.000Z</published>
    <updated>2020-01-14T06:44:33.276Z</updated>
    
    <content type="html"><![CDATA[<p>本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。</p><h2 id="定义">定义</h2><p>什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：</p><blockquote><p>A <strong>strategy</strong> for acquiring skills and knowneledge that is both <strong>self-directed</strong> and <strong>intense</strong></p></blockquote><ul><li>strategy: 它是一种学习的策略（just a strategy而非必须</li><li>self-directed：自我导向性（自我安排/计划</li><li>intense：强度高的</li></ul><p>总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念</p><a id="more"></a><h2 id="principle">Principle</h2><p>纵观博主所遇到的各个ultralearner，是什么使他们在学习上取得如此成功呢？作者通过众多例子归纳出了具有指导作用的9条Principle，这也是全书的精华所在，解释了ultralearning所关联的重要性因素。</p><h3 id="meta-learning">1 meta-learning</h3><p>从词根上来说，meta-可理解为元，meta-learning即元学习，类比于数据库中的mete-data，meta-data为描述数据的数据，meta-learning即为学习如何学习。此外，在书中的meta-learning还具有pre-learning的意思，即进行学习前进行的总体安排设计。</p><p>具体内容包括： - 如何高效地进行学习：学习能力的培养 - 分析/搜索/计划 - 这个是最为总体也是最重要的内容，通用于所有项目 - 所学知识的结构：组成/关系/规律 - 学习计划的设计/安排/执行 - 过往学习经历吸取经验</p><p>针对具体的项目，meta-learning可以通过三个步骤开启 1. why？ 仔细考虑为什么要学习这些内容？可考虑所学的目标是否符合下列因素之一 - 利益/目标。所学的内容能给自身带来利益，如学习某技能能给自身带来提升机会/工资提升；或是能帮助自己达到某个目标，如通过考试/取得学位 - 兴趣爱好 2. what？ 学习内容如何选择 - benchmarking。选择一个相近的基准作为自己的基准内容。如想进行CS相关的学习，可以找某些大学的CS学位的培养方案，选择一样的课程进行学习。这些内容可以来自网上/学校/专家/同辈 - emphasize。选择感兴趣/重要的部分进行强化，增加比重 - exclusive。相对不重要/不感兴趣的部分可以排除。 3. how？ 进行学习计划的设计，主要考虑以下因素： - 学习内容选择。这里的内容指的是学习资源 - 目标。要学到一个什么程度 - 时间安排。</p><h3 id="focus">2 Focus</h3><p>专注，作为一种非常高效的状态，无论是在学习还是工作中，都是一个非常有用的工具。本章节主要从三个方面来讲专注：</p><ol type="1"><li>如何进入专注的状态？我们需要避免拖延。拖延主要来自于对即将开始需要专注事情的困难或带来的不适的恐惧和厌恶。因此，我们可以通过从事情的easy-part入手，到进入状态后再逐渐切换到困难部分。另外，我们可用采用5分钟原则，根据5分钟原则，无论事情多么困难，在5分钟之内都不会感到想要放弃，在5分钟之后，在通过减轻程度/切换目标来减缓不适感。</li><li>如何保持专注状态？<ul><li>进入[flow状态](https://en.wikipedia.org/wiki/Flow_(psychology)（但不必强求</li><li>避免干扰。<ul><li>环境/任务/mind</li><li>接受杂念，任其发展，观其起落</li></ul></li><li>时间。长度足以进入状态，但不能过度致使疲劳而低效</li></ul></li><li>如何优化？保持正确/creative while stuck</li></ol><p>除了把专注当作一个高效率的工具以外，我们也应当将其当作一种能力来锻炼。这种能力，最好是通过在日常的使用中进行锻炼，习惯专注，尽量专注。当无法专注时，不妨思考一下所处的状况；当无法进入专注时，可以尝试始于微处，从细微的地方入手开始。</p><h3 id="directness">3 Directness</h3><p>在定义中提到，ultralearning的其中一个特点，就是self-directed，所以很自然地，directness也是一个重要的指导原则。这个原则指导我们，学习需要有明确的导向性，学习的内容最好就是直接指向所需的目标。通俗来讲，就是learn-by-doing。若所学的是一门技能，那便直接上手尝试；若所学是一门用于交流的语言，则直接与他人交谈；而若目标是通过一门考试，则练习题/真题无疑是最好的工具。</p><p>为什么需要直接练习呢？最主要的原因是知识的迁移问题。通常来讲，不同的学习内容具有不用的应用上下文场景，这导致了知识在使用的过程中难以迁移，同一个知识点，在一个场景可能适用，但换一个场景，可能就毫无用处了。这也可以说是知识的局限性。因此，我们最好就是在一开始就面向目标学习。</p><p>这个指导原则说来简单，相信很多人都知道，并且觉得诧异：难道还会有人不是直接学习所需的目标内容吗？确实有。原因有二。一是间接学习大多更为简单，举个例子，像学习外语，本身的目的是为了和他人交流，那最直接的目标不应该是直接用外语和他人交流吗？但事实上，最多人选择的学习外语方法是背单词。原因无他，相比于用外语与他人交流所产生的不适感中，更多人愿意呆在背单词的舒适区中。二则是某些内容难以直接练习，或者找到练习的机会。如同外科医生对于手术的练习，他们基本都不能够通过实际的手术进行练习（这也是不被允许的），缺乏实际的练习机会，只能通过旁观和被指点的方式积累经验。</p><p>面对以上情况，书中给出了几个方法。 1. 基于项目进行学习。拿程序员为例，以做一个程序项目为目标，学一部分，做一部分。 2. 构造沉浸式环境。语言学习/社区圈子交流 3. 模拟。 4. overkill。到达极端/超出要求。</p><h3 id="drill">4 Drill</h3><p>钻研。该原则指导我们在学习时应该有所侧重，侧重在明显影响学习速率的地方，例如技能的瓶颈区，最重要的地方，最困难的地方。当克服了这些部分，总体能有很大的提升。这个也算是一个比较显而易见的原则，我们的认知能力往往有所局限，无法兼顾所有部分，因而需要有所侧重地学习。钻研步骤可分成两步：首先需要寻找值得钻研的部分，我们可以通过分解与实验的方法找出最为重要/最为影响速率的部分；接着就是设计钻研的方案，有以下5个方法：</p><ol type="1"><li>时间片段练习。当所学习的内容能够按照时间划分成一个个片段，如某些技能（篮球的上篮动作），划分后重点练习某些片段。</li><li>认知资源偏重。如语言学习侧重在听说读写某一个方面。</li><li>复制。当只想练习某内容的其中一部分而另外部分仍需要完成时，可以复制他人的其它部分，自己只亲自动手，完成钻研部分。</li><li>放大镜。放大想重点钻研的部分的比重，增大投入的时间/精力。</li><li>前置学习。钻研部分的前置部分也好好学习。</li></ol><p>这个原则也与上一个原则——Directness对应上了，对于学习内容选择，我们先采用Directness选择了内容的总体，再进行分解，选择Drill部分，进行钻研，最后再组合起来。</p><h3 id="retrieval">5 Retrieval</h3><p>对于复习来说，相对于被动的阅读进行复习，抛开书本进行主动的回忆效果要好上很多。通过主动的回忆，我们可以对自己进行知识的测试，并且加深对所学知识的记忆和印象。大概的解释有三个：</p><ol type="1"><li>知识迁移。</li><li>反馈。</li><li>JOL(Judgement of Learning)。人们对自身学习情况难以正确地感知，判断自己学得怎么样了。</li></ol><p>至于如何练习这种主动的复习方法，书中给出以下途径： - 记忆卡片。 - 自由回忆。 - 以提问形式。 - 以挑战形式</p><p>另外，书本还给出了若干相关的实验数据，告知我们主动回忆效果的一些因素，分别是：开始时间，不需要准备好才开始，时间太晚，知识容易忘却，时间太短，不如被动方法；难度，越难的内容，效果比被动方法更好</p><h3 id="feedback">6 Feedback</h3><p>学习过程中，需要适当地接受反馈。尽管接收反馈有时会让人感到不安与恐惧，但好的反馈能够给我们提供许多信息，包括表现评价，问题所在，改进建议，这些信息能够帮助我们更好地改进下一步的学习计划。</p><p>什么是好的反馈？ 1. 能够提供有用的信息 2. 正确的信息 3. 能够被正确地接收，并能引起回应 4. 有促进作用</p><p>反馈的种类 1. 结果型反馈。只提供一个整体的结果，如成绩/评分 2. 信息型反馈。提供了问题的定位 3. 校正型反馈。提供了修改建议</p><p>如何合理接收反馈/提高反馈的质量？ 1. 忽略噪声 2. 使结果不可预测（可通过提高难度实现 3. 除了学习内容本身外，接受meta-learning的反馈（计划，日程安排，资源选择 4. 营造一个高强度或沉浸式的环境</p><h3 id="retention">7 Retention</h3><p>记忆在学习中也是一个很重要的部分，知识概念需要记忆，技能步骤也需要记忆，然而保持长久良好的记忆不是一个容易的事，原因在于每个人都无法避免的因素——遗忘。</p><p>遗忘主要有三个原因 1. 时间侵蚀记忆。时间越久，记忆越难以保存 2. 记忆间干扰。新增记忆取代/冲突/混淆了旧记忆 3. 记忆不可访问。虽然内容还记得，但找不到触发记忆的路径/因素</p><p>因此，针对遗忘的原因，可以通过一些技巧来减少遗忘 - 间距记忆。通过划分时间段和知识进行记忆，每次记忆部分，并时常进行重复。日常使用单词卡为一个典型的例子 - 步骤记忆。相对于纸面上的知识，需要实际动手的技能更难以忘却 - over-learning。学多一点，学深一点 - 记忆术。通过专门的记忆方法进行记忆，如关键词法，联想法。但具有一定局限性，如适用范围较窄，回忆较费力</p><h3 id="intuition">8 Intuition</h3><p>通过学习建立相关的直觉。所谓的直觉，可以理解为对于所遇到问题，能进行自动归纳分类，遇到新的问题时，能够自发地对问题进行分解/抓取核心/组合/联系，并且得出问题解决的范式。其中，对于概念，我们需要理解；对于问题，我们需要大量积累，并通过练习，总结，得出通用的解决模式。</p><p>帮助建立学习中的直觉方法有： 1. 增加难度。难度较大时更易于钻研。 2. 通过证明来理解概念。 3. 具体例子帮助理解与记忆。 4. 多提问。dump问题也不应该避开。</p><p>另外，我们还可以通过费曼技巧，帮助我们更好地理解/掌握。费曼技巧的核心，在于迫使自己以解释/教授的方式，进行知识的加工输出，一方面可以帮助自己更好地学习，另一方面也可检测自身的学习情况。具体的步骤为：</p><ol type="1"><li>选择一个概念/问题</li><li>对于概念，尝试以通俗的语言像一个没有基础的人讲解，并能够使其明白</li><li>对于问题，独立形成一个可行的解决方法</li></ol><h3 id="experimentation">9 Experimentation</h3><p>多做试验，ultralearning的过程是一个探索的过程，永远没有一个完全正确的方案，只有只为适合自己当前的方案，所以必须靠我们通过试验进行探索，验证哪个更好，更适合。具体试验的内容包括：资源，技巧，风格，已经水平层次。在学习的过程中，我们也需要一直保持着这种实验的心态，带着一种可成长的思维模式，而非一成不变的定式。</p><p>以下为一些在试验上面有所帮助的技巧： - copy and create。最开始可以照搬他人的学习方案，并且根据自身情况适度修改 - 对比。不同方法/资源/条件/技巧的比较 - 添加新约束 - 混合 - 极端</p><h2 id="how-to-start-a-ultralearning-project">How to Start a Ultralearning Project</h2><ol type="1"><li>Research 搜集相关信息进行meta-learning<ul><li>将要学的目标领域及其范围</li><li>将要使用的资源</li><li>他人成功学习的方法规范标准借鉴</li><li>直接练习的活动</li><li>备份的学习资源及钻研部分</li></ul></li><li>计划时间 取决于自身时间安排/所学的预期程度/空闲时间等因素<ul><li>计划投入多少时间</li><li>计划投入什么时候的时间</li></ul></li><li>执行计划 在执行计划时时常用上述的指导原则向自己提问是否符合，并进行调整/优化</li><li>检查结果 分析计划及其结果，吸取经验</li><li>维持学习结果/进一步学习 为了不至于遗弃学习成果<ul><li>定期复习</li><li>重新学习</li><li>进一步学习</li></ul></li></ol><h2 id="ultralearnner的培养">ultralearnner的培养</h2><p>本部分通过介绍波尔加三姐妹的例子来说明如何培养ultralearner。 因为暂时没有人要培养的缘故，所以没什么兴趣，遂只是简单地略读摘录了相关重点记录保存。</p><h3 id="raise">Raise</h3><ol type="1"><li>早开始。越早开始越好，儿童时大脑功能更好更适宜学习。</li><li>专注。可以有多种学习内容，但需有一个侧重点，并专注于侧重点。</li><li>寓教于玩。将学习/练习转化成游戏，增添兴趣与持久性。</li><li>正向强化。通过胜利、鼓励等方式给予正向强化。</li><li>拒绝强迫。强迫学习无用，需要引导进行学习。</li></ol><h3 id="suggestion">Suggestion</h3><ul><li>Inspiring Goal</li><li>Be Careful with competition</li><li>Make Learning a Priority</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;定义&lt;/h2&gt;
&lt;p&gt;什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;strategy&lt;/strong&gt; for acquiring skills and knowneledge that is both &lt;strong&gt;self-directed&lt;/strong&gt; and &lt;strong&gt;intense&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;strategy: 它是一种学习的策略（just a strategy而非必须&lt;/li&gt;
&lt;li&gt;self-directed：自我导向性（自我安排/计划&lt;/li&gt;
&lt;li&gt;intense：强度高的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="学习" scheme="http://scottyeung.top/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="meta-learning" scheme="http://scottyeung.top/tags/meta-learning/"/>
    
      <category term="ultralearning" scheme="http://scottyeung.top/tags/ultralearning/"/>
    
      <category term="improvement" scheme="http://scottyeung.top/tags/improvement/"/>
    
      <category term="方法论" scheme="http://scottyeung.top/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="Scott H Young" scheme="http://scottyeung.top/tags/Scott-H-Young/"/>
    
  </entry>
  
  <entry>
    <title>保研之路</title>
    <link href="http://scottyeung.top/2019/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <id>http://scottyeung.top/2019/保研之路/</id>
    <published>2019-10-01T08:38:20.000Z</published>
    <updated>2020-01-14T07:23:40.792Z</updated>
    
    <content type="html"><![CDATA[<p>在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。</p><a id="more"></a><figure><img src="/2019/保研之路/p1.JPG" alt="来自深夜的拟录取通知"><figcaption>来自深夜的拟录取通知</figcaption></figure><h2 id="开始阶段">开始阶段</h2><p>最初诞生保研的想法是在大二上学期，那个时候我的一个同高中的直系学长刚好要保研到中科院软件所，在和他交谈时，我第一次接触到了保研这个概念，在此之前，我一直都是抱着早点跑去实习搬砖赚钱的想法的。后来我看到了学院的推免名单和细则出来后，我看好像主要还是看GPA，那些加分都比较无关紧要（在国软的细则里，一个奖项可能就加零点零零几或者零点几，还要在乘以一个百分之十，真的算是无关紧要）。结合我当时的绩点，以及刚进行的奖学金评比看到的成绩排名，觉得还是挺稳的，当时甚至还会时不时地幻想保研到哪个学校。不过还是没有下定很大的决心，内心还是想着就业的。 在这种背景下，似乎保研也不需要付出额外的力气来准备，继续保持当时的状态，继续好好学习，保持绩点就行了，同时，根据细则的要求，只看必修课的绩点，我还可以集中精力在必修课，可以减少在一些选修课的投入精力和时间。</p><h2 id="突生变化">突生变化</h2><p>在大二下学期的时候，发生了一件挺突然的事情：我们学院（国际软件学院）和计算机学院合并了。在上学期的时候部分老师就在有意无意的放出风声，但是就是没有人给出一个确定的说法，我们也只是当一个谣言对待，然后最后就真合并了，而且最后也没有给出一个官方的说法。每次提起这件事，我的内心其实都有点不爽，不过结合在计院待的这一年来说，计院的行政也就是这样，无从吐槽。 合并了对保研有什么影响呢？首先推免细则变了，可能会按照计院的来执行；其次推免的名额可能会有变化；最后，换了一批行政人员，很可能使使事情变麻烦。当时我还挺天真的，心里想着改革不会也不应该影响到当前的学生。现在回看，当真是naive，<del>学校改革哪管学生死活</del>。抱着这种想法，我对保研的准备还是没什么变化，好好学习，好好准备必修课的考试，继续保持高绩点。 同时，在这一年了为了锻炼代码能力，尝试加入实验室/找老师做项目，但因为自身原因或老师原因，两次都无疾而终，甚至让我对实验室留下了一种不好的印象，对实验室有所抗拒，这导致了我在暑期实训时没有找老师进实验室，而选择跟学校实训。回顾这几次过程，大致可得出几个教训： 1. 机会是需要靠自己主动争取的。上面提到的几次机会都是我偶然看到的消息才去找的，这导致了可选择的选项不多，并且quit了之后就无事可做。 2. 驱使你做选择的因素不应该是有无机会，更应该看机会是否适合，是否好。 3. 好老师/好实验室的影响很大，同理如果不好，影响也很大。</p><h2 id="关键阶段">关键阶段</h2><p>进入大三之后，距离保研的夏令营就只剩不到一年时间，上学期可谓是关键阶段。在上学期，我把能修的课都修满了，提前就修完了专选课和公选课（但到了下学期还是有点担心部分学分而再修了额外的课）。那段时间可以说是最忙的时候了，几乎是满课，有时真的下午下课后吃完饭顶不住，回来需要睡上一觉，晚上再去上课。另外，为了丰富科研经历，我主动发了邮件给老师说要进实验室，那段经历也是挺可怕的，在此期间，我得了组会恐惧症，每次组会开始前我内心都很焦虑，一方面没做什么，而另一方面又要想怎么回复，导致每次组会结束后，我几乎都会去大吃大喝，缓解压力，最终也没有任何产出/收获。 另外，15级新的保研细则也出了，成绩计算还是只算必修课，但是变成了相对赋分，而加分也是，且增加了很多的加分项（如班干部任职，CCF认证等）。看到这个新的细则，内心有点慌，因为还没有任何加分，而在相对赋分的情况下，可以拉很多分（如绩点3.6+凭借加分第一名，3.5+第二名），但另一方面，保研名额似乎也变多了，最低裸绩点3.4都保上了。 最终，在大三上学期，除了把课程几乎修完以外，几乎没有任何收获。绩点也因为nc的暑期实训拉低了0.1，科研方面也没有任何产出，且没有后续了。</p><h2 id="最后冲刺">最后冲刺</h2><p>到了大三下，课程基本不多，一周其实就两三天课，可谓是全力备战保研的时候了。在这个学期我因为担忧没有保研加分拿不到推免资格（其实是多余的焦虑），所以选择刷点加分。我选择的是CCF和全国大学生英语竞赛。前者我第一次近乎裸考就拿了270分，而300分就可以有加分。后者则是获奖比例高达80%。然而，前者出乎意料地翻车(<a href="http://scottyeung.club/2019/CCF-201903/" target="_blank" rel="noopener">CCF-201903</a>)，后者则是在准备的时候就觉得自己已经没有希望了（虽然比例高，但基数小，参加的人都太厉害了），最终也没有拿到任何加分。 除了准备加分，我还在准备专业课知识的复习。专业课知识大体分为两部分，一部分是比较硬的，看重能力的，如数学，算法，这些需要的时间比较长，不太能速成；另一部分则是偏概念，偏背诵的。这个学期开始，我就在学堂在线刷数据结构和线性代数，并在五月底前完成。进入五月，开始收集各个学校的夏令营消息并准备相应的材料。六月份确定参加的夏令营后则根据网上查询到的信息进行针对性的准备与学习，最终只参加了本校和南大计科的夏令营，北航和南大软院也进了，拒了，而七月中的时候收到了软件所软件中心的面试通知，也没去。本校夏令营没做什么准备就拿到了比较靠前的优秀营员名额，而南大夏令营相关情况<a href="http://scottyeung.club/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/" target="_blank" rel="noopener">可点此查看</a>，开放日结束过几天就被老师告知考核通过，可录学硕。</p><h2 id="最终结果">最终结果</h2><p>开放日结束后，还需要回学校搬砖，做一个微信小程序，不知道什么时候能走。但因为手里已经拿到一个比较满意的offer，内心也已经放轻松了，就没有做后续的准备，包括软件所的考核以及九推的准备。唯一有点烦的，就是这个实训不知道什么时候结束，组员都不想做，但是又还没出分，不敢造次，担心影响到GPA。最终这个工作一直持续到开学，幸好给分还行。 开学第一周周五就进行推免申请工作，最终没有任何加分，GPA 3.85+，排名11，然后今年形势也非常有趣，科研加分最高也才13分，导致3分加分就大于0.1绩点，就等于当一年班干部就涨了0.1绩点，反正我也不准备九推，其实与我无关。我最终的综排18，也算还行，然后今年的名额暴涨，最低好像裸绩点3.4+也保上研了。所以前面的焦虑好像是多余的？</p><h2 id="经验教训">经验教训</h2><p>前面说了如此多无聊的流水账，下面就说一点有用的干货弥补一下吧。 - 成绩很重要。某个学长说过，成绩决定下限，从我本人的申请情况以及推免名额的获取情况来看，的确如此。部分学校筛人直接就根据排名筛掉，没有成绩直接就没有后续，除非你其它方面（科研/竞赛）特别强，我去体检的时候碰到一个弘毅班的老哥就说他一开始就因为排名被南大计科筛了。 - 科研/竞赛要有但不用多。有奖项或论文产出固然是好，但没有也不要紧，因为有的只是少数人，但相关的经历还是需要有的，这在面试中可是一个回答利器，一方面可能面试官会直接发问，另一方面，也可以通过这些经历展示你的相关技能，研究能力和研究兴趣。这些经历可以通过进入实验室获得。 - 尽早研究推免细则，寻找加分机会。很多的加分其实获得难度是很低的，如软考，CCF或是当班干部，这些不仅难度不高，而且需要时间也不长，另外，参加竞赛或者大创，这就需要早一点准备了，但其实也不算难。像大创，找对老师指导就保底一个校级大创了。 - 做好信息收集。信息收集非常重要，保研不同于高考，每个人考完根据分数排名投志愿就录取了。信息的收集影响到你学校院系的选择，考核内容的准备，实验室导师的选择。 - 做好自身实力定位，不妄自菲薄。所谓的实力定位，主要是看自己的成绩，看自己在哪一档，然后根据此可以选择同档次学校或高一档的学校。要记住机会总是有可能有的，不妨海投试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。&lt;/p&gt;
    
    </summary>
    
      <category term="保研经验" scheme="http://scottyeung.top/categories/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="流水账" scheme="http://scottyeung.top/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>云计算与软件工程</title>
    <link href="http://scottyeung.top/2019/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://scottyeung.top/2019/云计算与软件工程/</id>
    <published>2019-08-08T04:23:26.000Z</published>
    <updated>2019-11-12T14:48:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>想找点云计算的网课来看看，无意中发现了这个不错的mooc：<a href="http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about" target="_blank" rel="noopener">CS169.1X 云计算与软件工程</a>。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。</p><a id="more"></a><p>如课程所讲，软件工程是一个需要终身学习的概念，这其实更应该是一个程序员的核心技能，但往往我们都对此忽视，往往注重于单一的技能的术，而忽视最根本的道，即使是软件工程专业课，也只是沦为简单的概念背诵。希望可以通过这个课程，这个笔记，时刻提醒自己勿忘核心。</p><h2 id="软件工程概论">软件工程概论</h2><ul><li>SaaS: 软件即服务<ul><li>无需担心安装/环境配置</li><li>无需担心数据丢失</li><li>易于协作同样数据</li><li>中心化数据</li><li>统一硬件系统环境：兼容性</li><li>易于更新：中心化</li></ul></li><li>SOA：面向服务架构<ul><li>系统由能提供服务的独立模块组成，每个模块通过接口提供服务，模块间通过接口进行通信</li><li>设计时最先设计接口</li></ul></li><li>SaaS‘s Demand On infrastructure<ol type="1"><li>Communication: 服务可交互</li><li>Scalability：可扩展性（增加规模服务<ul><li>集群</li></ul></li><li>Dependability：可靠性</li></ol></li><li>软件质量<ul><li>遗留代码：遗留的功能可用的代码，质量差 不算失败</li><li>质量标准：可用/易于开发调试修改</li><li>测试<ul><li>检验与确认：do the thing right and do the right thing</li><li>黑盒测试与白盒测试</li><li>单元/模块/集成/系统测试</li><li>回归测试：测试修改部分</li><li>测试覆盖率：覆盖率高不等于测试好</li></ul></li></ul></li><li>生产力因素<ul><li>代码简洁<ul><li>代码简短易于阅读</li><li>抽象等级高：高级语言</li></ul></li><li>代码合成<ul><li>code by example</li></ul></li><li>复用<ul><li>复用函数</li><li>标准库</li><li>对象/类</li><li>设计模式</li></ul></li><li>自动化工具</li></ul></li></ul><h2 id="开发过程">开发过程</h2><ul><li><p>plan-and-document</p><ul><li>模型<ul><li>瀑布模型</li><li>螺旋模型</li><li>RUP</li></ul></li><li>问题：<ul><li>需要强大的PM</li><li>沟通成本</li><li>文档驱动</li></ul></li></ul></li><li>敏捷开发<ul><li>四大宣言：个体协作/能用的软件/客户沟通/拥抱变化</li><li>极端编程：如果某个事是好的，则做到极致/最大化</li><li>测试驱动开发</li><li>行为驱动设计</li><li>Scrum开发<ul><li>team size</li><li>role：master PO</li><li>3个问题</li><li>解决冲突</li></ul></li></ul></li><li>结对编程<ul><li>driver</li><li>observer</li></ul></li></ul><h2 id="ruby">Ruby</h2><p>课程的核心内容为利用Rails on Ruby搭建SaaS服务，所以Ruby也是一个重点。因为个人而言，编程语言最好的学习方法还是动手去做，因而就没有记录笔记了。下面为一些可能会用到的链接和个人的一些见解。</p><h3 id="语言特点">语言特点</h3><p>列举比较特别印象深刻的或者是其它没有的 - 究极面向对象：一切变量皆对象，一切函数皆方法 - 诗歌式编程：因为调用均方法=&gt;可省略括号=&gt;像语句一样 - 字符串/正则良好支持 - 元编程与反射： - 元编程：编写代码的代码 - 反射：运行时动态获取对象属性方法 - <code>method_missing</code>当方法在类中未定义时，进入该方法 - 函数式编程 - duck-typing: 能响应相同方法的被视作相同的类 - Module：为实现特定方法的实例提供相应的方法</p><h3 id="相关链接">相关链接</h3><ul><li><p><a href="https://www.runoob.com/ruby/ruby-tutorial.html" target="_blank" rel="noopener">Ruby学习 菜鸟教程</a></p></li><li><p>课程编程作业</p><ol start="0" type="1"><li><a href>环境配置（待填坑</a> : 大坑！<ul><li>官方建议使用云端cloud9框架的IDE服务已被收归AWS并且停止原服务，使用还得绑定信用卡</li><li>本地自行搭建的cloud9服务也无法按照官方仓库wiki配置方法进行配置</li><li>文档没有写清楚最重要的Ruby版本要求以及相关package的</li></ul></li><li><a href="https://github.com/yeung66/hw-ruby-intro" target="_blank" rel="noopener">hw-ruby-intro</a></li></ol></li></ul><h2 id="bdd和tdd">BDD和TDD</h2><h3 id="bdd行为驱动设计">BDD：行为驱动设计</h3><ul><li>User Story：<ul><li>As role</li><li>to do what</li><li>So that achieve</li></ul></li><li>评价准则：SMART<ul><li>Specific &amp; Measurable：场景具体且易于测量/评价</li><li>Achievable：1轮迭代可实现</li><li>Relevant：具有实现价值</li><li>Timeboxed：具有时间界限</li></ul></li><li>流程：与用户交互生产user story card，并将其添加到待办项。根据优先级与难度选取用户故事进行实现</li><li>任务点数评价用户故事的难度，通常投票决定</li><li>使用Tracker可以追踪用户故事完成情况及开发速率</li></ul><h3 id="tdd-测试驱动开发">TDD： 测试驱动开发</h3><ul><li>FIRST原则：针对单元测试<ul><li>Fast</li><li>Independent</li><li>Repeatable</li><li>Self-Checking</li><li>Timely</li></ul></li><li>RSpec</li></ul><h2 id="saas应用结构">SaaS应用结构</h2><ul><li>C/S结构</li><li>3层结构<ul><li>Web Server</li><li>App Server</li><li>Database<ul><li>ActiveRecord：model自己知道如何CRUD</li><li>DataMapper：通过mapper进行对象与数据库记录的映射</li></ul></li></ul></li><li>MVC<ul><li>view： template view | transform view</li><li>陷阱：fat controller/view</li></ul></li><li>RESTful</li></ul><h2 id="rails">Rails</h2><ul><li>MVC<ul><li>Model：ActionRecord</li><li>Controller：通过router转发到控制器</li><li>View：haml</li></ul></li><li>约定优于配置：符合约定不需配置文件，仅在不符合约定时配置文件</li><li>调试：RASP<ul><li>print</li><li>log</li><li>interactive</li></ul></li></ul><h2 id="敏捷开发">敏捷开发</h2><h3 id="质量度量">质量度量</h3><ul><li>Code Smells</li><li>SOFA原则<ul><li>Short</li><li>One：代码只做一件事</li><li>Few Arguments</li><li>Abstract：抽象在同一等级</li><li>Reek工具可分析</li></ul></li><li>ABC评分：变量，分支，条件数量<ul><li>通过flog评分，超过20有问题</li></ul></li><li>通过路径数量评分</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想找点云计算的网课来看看，无意中发现了这个不错的mooc：&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS169.1X 云计算与软件工程&lt;/a&gt;。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。&lt;/p&gt;
    
    </summary>
    
      <category term="课程笔记" scheme="http://scottyeung.top/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件工程" scheme="http://scottyeung.top/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="云计算" scheme="http://scottyeung.top/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>记2019南京大学计算机系开放日</title>
    <link href="http://scottyeung.top/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    <id>http://scottyeung.top/2019/记2019南京大学计算机系夏令营/</id>
    <published>2019-07-26T02:45:34.000Z</published>
    <updated>2020-01-14T07:30:13.148Z</updated>
    
    <content type="html"><![CDATA[<p>因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。</p><a id="more"></a><h1 id="前期准备">前期准备</h1><p>因为早早抱着保研的想法，在学期中段就有这复习专业课的计划了，大致复习了如下内容： - 数据结构（非常重要 - 离散数学 - 线性代数 - 概率论 - 操作系统 - 计组</p><p>对于南大计算机系夏令营的准备，其实开始得比较晚，因为之前海投了挺多夏令营，而计算机系的开放日时间刚好夹在一堆夏令营之间，时间相冲，一开始是抱着放弃南大计算机系的夏令营的想法，然而其它夏令营要么没进，要么出得很晚，最终还是选择了南大计科。</p><p>南大的准备主要还是准备算法方面的机试，在六月份的时候把刘汝佳的<a href="https://book.douban.com/subject/25902102/" target="_blank" rel="noopener">紫书</a>过了一遍，并且在voj上把部分的题刷了一下（时间太短刷的其实不多），题单可以<a href="https://vjudge.net/article/45" target="_blank" rel="noopener">看此</a>。另外，在看完书后，每天都上voj找一两道题练练手感，主要是dp和dfs的题。根据往年的题目来看，题目难度大概在LeetCode中等，当然也有直接POJ的原题，如果时间充足找个题单把POJ刷刷还是不错的。</p><p>面试的准备，则是参营前几天随便准备了自我介绍，项目经历，兴趣爱好等面试常问话题，当时时间紧，其实都还没准备完，还想着机试完后再准备。</p><h1 id="流程">流程</h1><p>开放日活动共三天 1. 上午报到，下午机试 2. 面试。分成上下午两批，每批大概十个组，每组十多人 3. 介绍参观+与老师交流</p><p>其实就主要三个活动：机试，面试，找导师签字。</p><h2 id="机试">机试</h2><p>机试的形式是OJ形式，两个小时，三道题，三百分，每道题十个测试样例，每个十分。<strong>机试非常重要！</strong> 这个在我从网上看到任何一个博客/经验帖里都这样说，甚至还有说面试只是走一个过场。<del>我联系的导师也是这样对我说的，面试给的分都差不多，而机试可能拉上百分。</del></p><p>可选择语言为C/C++ ， Java，提供的ide有Visual Studio和Eclipse。</p><h3 id="第一道题">第一道题</h3><p>给一个不超过m(m&lt;=100)位的整数，从中移除k(k&lt;=m)位，使得剩下的整数最小。</p><p>当时的思路是每次移除最大的数字，然后有60分，但这个在后来做完其它题目回来重新想的时候已经发现有问题了，如对于<code>1032</code>，去掉3后显然没有去掉1小。当时考虑用dp重写，<code>dp(i,j)=min(10*dp(i-1,j)+num[i],dp(i-1,j-1))</code>,但没时间调试了。</p><p>现在搜索看到一个贪心的方法：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符。具体链接为<a href="https://blog.csdn.net/C20190413/article/details/77368590" target="_blank" rel="noopener">C++贪心算法之最小新整数</a></p><h3 id="第二道题">第二道题</h3><p>B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，有多少种排队方式</p><p>直接就DFS了，<code>dfs(b,g,k)</code> - 当<code>b==B&amp;&amp;g==G</code>时，成功，计数 - 当<code>b&gt;B||g&gt;G||k&gt;K</code>时，失败，返回 - 否则两种递归 - <code>dfs(b+1,g,k+1)</code> - <code>dfs(b,g+1,0)</code></p><p>最后超时，70分。当时已经很满意了，直接跳过放弃优化。</p><h3 id="第三道题">第三道题</h3><p>给出一个二叉树的前序遍历序列和后序遍历序列，问可能的二叉树有多少种</p><p>也是dfs解决<code>dfs(preorder,postorder)</code>，直接AC了 - 如果是叶子，返回1 - 找子树 - 如果有两个子树，则返回子树的dfs乘积 - 如果只有一个子树，则返回2*子树的dfs</p><h2 id="面试">面试</h2><p>因为机试考得比较不错，加上前一晚准备时差不多是跟同房的同学吹了一晚水，面试准备得比较一般，晚上看了看英文wiki准备一下计算机学科相关话题，以及完善一下自我介绍与项目经历。</p><p>面试当天，探听到每个人的面试的形式基本一样，基本是自我介绍+专业/算法/项目问题+性格测试，而内容与难度则根据不同的组别可以有很大的差别，但感觉总体面试都不会为难学生，不会的问题老实说不会，也不会继续追问。本人的面试内容如下：</p><ul><li>中文自我介绍，没说时间</li><li>专业问题<ul><li>数据挖掘是统计还是概率</li><li>买桃问题：一个桃多少钱，三个桃核换一个桃，给定钱能有多少桃</li><li>立方体不借助工具怎么倒出一半水</li><li>最小生成树算法</li><li>单链表怎样在常数空间复杂度查有没有环</li></ul></li><li>项目相关<ul><li>聚类算法的结果是什么（第一个问题就踩雷，然后就没有后续了</li></ul></li><li>英语提问<ul><li>大学期间最感兴趣/擅长的课程</li></ul></li><li>性格相关<ul><li>喜欢跟什么样的人相处</li><li>遇到不好相处的人怎么办</li><li>遇到压力/挫折怎么办</li></ul></li></ul><p>面试时间规定是在十分钟内，但是这个基本都是由面试的老师来控制，我面试的时候没吃午餐+等了太久+有点紧张，我觉得发挥得挺一般的，有些能答出来的题都没答出来（那个单链表的题我还在LeetCode刷过，也没答出来，勉强给了个线性空间复杂度的解法），实在可惜。不过好像从最后的结果来看好像影响也不大？</p><h2 id="导师">导师</h2><p>在挺早的时候，我院的一个老师帮忙宣传一个实验室时，我就发了简历给我联系的导师的实验室，然后在参加开放日之前几天，我又发了一封邮件联系，沟通得也不错。面试之后就找他聊一聊，顺带签字了。联系导师其实也不算难，我觉得不提前联系其实也是没什么问题，除去那些很热门的实验室和导师外，导师都还是很乐意为你签字。跟我一起去的同学，面试当天才联系导师签字，一气呵成。</p><h2 id="其它">其它</h2><ul><li>住：本次学生的住宿分成两批，一个是就在计算机系楼旁的国际会议中心，另一个是步行三十分钟左右的中公汇悦酒店。两者规格差不多，远的就麻烦一点，有行李可以坐公车。</li><li>食：看往年的帖子都说是发饭卡，还可以到超市买东西，而今年则只有指定饭堂的五张饭票，每张饭票当15元使用，只能单次使用，有点麻烦。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。&lt;/p&gt;
    
    </summary>
    
      <category term="保研" scheme="http://scottyeung.top/categories/%E4%BF%9D%E7%A0%94/"/>
    
    
      <category term="南京大学" scheme="http://scottyeung.top/tags/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="计算机系" scheme="http://scottyeung.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB/"/>
    
      <category term="夏令营" scheme="http://scottyeung.top/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
      <category term="开放日" scheme="http://scottyeung.top/tags/%E5%BC%80%E6%94%BE%E6%97%A5/"/>
    
      <category term="算法" scheme="http://scottyeung.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>枚举排列</title>
    <link href="http://scottyeung.top/2019/%E6%9E%9A%E4%B8%BE%E6%8E%92%E5%88%97/"/>
    <id>http://scottyeung.top/2019/枚举排列/</id>
    <published>2019-07-03T02:21:44.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>如何按字典序从小到大输出前n个数的所有排列？</p><a id="more"></a><h2 id="递归调用">递归调用</h2><p>将数字分成两部分： - 已确定前缀序列 - 待定元素</p><p>每次移除一个待定元素添加到前缀序列末尾，进行下一次递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* A, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//尝试在A[cur]中填各种整数i</span></span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        <span class="keyword">if</span>(A[j] == i) ok = <span class="number">0</span>; <span class="comment">//如果i已经在A[0]~A[cur-1]出现过，则不能再选</span></span><br><span class="line">        <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">            A[cur] = i;</span><br><span class="line">            print_permutation(n, A, cur+<span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接生成">直接生成</h2><p>该方法直接获取到排列序列 1. 将元素排序，记录初始序列。 2. 将当前首元素记录。 3. 每次将记录的元素右移1位（交换位置），生成一个排列 4. 直到元素移到最右边，回到步骤2 5. 当出现了初始序列时，排列生成完毕</p><p>具体代码可以参照std标准库里面的方法<code>next_permutation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; //包含next_permutation</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">        sort(p, p+n); <span class="comment">//排序，得到p的最小排列</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]); <span class="comment">//输出排列p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(next_permutation(p, p+n)); <span class="comment">//求下一个排列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何按字典序从小到大输出前n个数的所有排列？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="排列组合" scheme="http://scottyeung.top/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://scottyeung.top/2019/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://scottyeung.top/2019/并查集/</id>
    <published>2019-06-19T03:59:22.000Z</published>
    <updated>2019-11-12T14:48:29.989Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p><p>有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作: - Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 - Union：将两个子集合并成同一个集合。</p><a id="more"></a><h2 id="思路">思路</h2><p>开数组记录每个元素的从属情况，find操作返回元素从属情况，union操作修改其中一个元素的从属情况，将其合并</p><h2 id="代码">代码</h2><h3 id="最简单模板">最简单模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i&lt;<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++) <span class="built_in">set</span>[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="built_in">set</span>[x]?x:<span class="built_in">set</span>[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的情况下没有任何优化，易退化成链状查询，查询复杂度到达<span class="math inline">\(O(n)\)</span></p><h3 id="优化模板">优化模板</h3><p>添加路径压缩，减少查询时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//使用递归写find函数，同时有路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">set</span>[a]!=a)<span class="comment">///循环方法查找前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="built_in">set</span>[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=x,j;</span><br><span class="line">    <span class="keyword">while</span>(i!=a)<span class="comment">///路径压缩,修改历经的前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="built_in">set</span>[i];<span class="comment">///记录x的前导结点</span></span><br><span class="line">        <span class="built_in">set</span>[i]=a;<span class="comment">///将i的前导结点设置为r的根节点.</span></span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a=Find(x);<span class="comment">///x的根节点为a</span></span><br><span class="line">    b=Find(y);<span class="comment">///y的根节点为b</span></span><br><span class="line">    <span class="keyword">if</span>(a!=b)<span class="comment">///如果a,b不是相同的根节点，则说明ab不是连通的</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[a]=b;<span class="comment">///将a,b连接，将a的前导点设置为b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例">实例</h2><ul><li>图的连通性问题：将所有节点合并邻接节点，判断是否属于同一集合</li><li>重复数据合并/关联<ul><li><a href="https://leetcode-cn.com/problems/accounts-merge/submissions/" target="_blank" rel="noopener">Leetcode 721 Accounts Merge</a>:</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。&lt;/p&gt;
&lt;p&gt;有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作: - Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。 - Union：将两个子集合并成同一个集合。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="集合" scheme="http://scottyeung.top/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
</feed>
