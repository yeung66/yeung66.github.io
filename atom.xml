<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Scott&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.club/"/>
  <updated>2019-12-07T04:00:53.159Z</updated>
  <id>http://scottyeung.club/</id>
  
  <author>
    <name>Scott Yeung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Some Notes About SQLAlchemy</title>
    <link href="http://scottyeung.club/2019/Some-notes-About-Sqlalchemy/"/>
    <id>http://scottyeung.club/2019/Some-notes-About-Sqlalchemy/</id>
    <published>2019-12-07T02:24:35.000Z</published>
    <updated>2019-12-07T04:00:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。</p><p>SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求：</p><ul><li>提供对数据库的常用操作：增删改查</li><li>提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据</li></ul><a id="more"></a><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>SQLalchemy不能支持操作数据库，因而需要安装额外的数据库驱动，对于不同的数据库与驱动，有着不一样的配置URI，总体格式为<code>dbms://user:pwd@host/dbname</code>。这里用的Mysql+mysqlconnector，具体的连接代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">sql_connection = &apos;mysql+mysqlconnector://root:pwd@localhost:3306/database&apos;</span><br><span class="line">engine = create_engine(sql_connection)</span><br><span class="line"></span><br><span class="line"># 执行sql事务需要使用会话</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line"># 结束前需要关闭session</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>在SQLalchemy中，ORM通过定义对象进行数据库model的绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relation, sessionmaker</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"> </span><br><span class="line">class Movie(Base):</span><br><span class="line">    __tablename__ = &apos;movies&apos;</span><br><span class="line"> </span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    title = Column(String(255), nullable=False)</span><br><span class="line">    year = Column(Integer)</span><br><span class="line">    directed_by = Column(Integer)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    def __init__(self, title=None, year=None):</span><br><span class="line">        self.title = title</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure></p><ul><li>ORM的model类通过继承declarative_base进行定义，通过<code>__tablename__</code>绑定到对应的table</li><li>每一个Column属性为表中的一列，需要设置类型，类型必须要与数据库中列的类型对应，常用类型有Integer，Float， String（对应varchar），Text</li><li>必须设置一个属性/列为<code>primary_key</code></li><li>可以通过<code>Base.metadata.create_all(engine)</code>创建table</li></ul><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><p>数据使用ORM进行操作，操作的基本单位为对象（也可以直接使用sql语句，但对于常用操作来说没有必要）。除查询外，对数据库有修改的操作都需要commit事务</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 = Movie(&quot;Star Trek&quot;, 2009)</span><br><span class="line">session.add(m1)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><ol><li>创建待插入的对象，添加相应的数据属性</li><li>添加进session中</li><li>提交session，提交事务</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movies = session.query(Movie).all() # 获取所有数据</span><br><span class="line">movie = session.query(Movie).get(movie_id) # 获取单个记录</span><br><span class="line">filter_movie = session.query(Movie).filter(Movie.id == 1).one()</span><br></pre></td></tr></table></figure><ul><li>查询中query的参数为查询的table/返回的对象</li><li>filter等于where语句，可以对查询结果进行进一步筛选，one返回唯一行，all则返回所有行</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>查询出来的数据，修改属性后重新提交事务即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">movie.year = 1999</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">session.delete()</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><h2 id="some-problems"><a href="#some-problems" class="headerlink" title="some problems"></a>some problems</h2><h3 id="大批量数据插入"><a href="#大批量数据插入" class="headerlink" title="大批量数据插入"></a>大批量数据插入</h3><p>在使用的过程中，遇到一次需要插入三十多万条数据到数据库的情况。在此之前，我一直都是插完数据再一起commit的（几千/几百条），因为每次commit需要写入数据库，会比较慢（磁盘IO制约）。<br>但这次数量过多的话，提交的时候出现错误，提示mysql的连接丢失。估计是写入的时间太多，时间太长超出了其限制，进而断开了连接。于是我选择批量commit，在添加一定数量数据后提交一次（5000/1000/500/100/10），但是没有成功，插入一定量的记录后，提示某一条插入的记录的某一列过长（尽管我那一列是不限长度的Text），显然有问题。<br>上网搜索批量数据插入的方法，但内容基本都是千篇一律，全部都是转载/翻译StackOverflow上的一篇<a href="https://stackoverflow.com/questions/3659142/bulk-insert-with-sqlalchemy-orm" target="_blank" rel="noopener">回答</a>。给出了两种方法</p><ul><li>bulk_save_objects(objects)</li><li>add_all()</li></ul><p>都没有效果，最终还是采取了逐条添加并提交的方法，虽然慢了点，但是能work。</p><p>写这件事只是为了吐槽一下现在用Google搜索一些具体的技术问题是，内容严重同质化的现象，大家都抄来抄去，转来转去。像这一次的搜索，最开始的source是在StackOverflow上的提问，然后有网站翻译成了中文并发布（甚至初创，然后就流传于各个中文网站了，一搜，全是这些内容相同的网页，属实恶心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。&lt;/p&gt;
&lt;p&gt;SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供对数据库的常用操作：增删改查&lt;/li&gt;
&lt;li&gt;提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://scottyeung.club/categories/Mysql/"/>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="sql" scheme="http://scottyeung.club/tags/sql/"/>
    
      <category term="Mysql" scheme="http://scottyeung.club/tags/Mysql/"/>
    
      <category term="生产力" scheme="http://scottyeung.club/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="SQLAlchemy" scheme="http://scottyeung.club/tags/SQLAlchemy/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Automate the Boring Stuff with Python</title>
    <link href="http://scottyeung.club/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/"/>
    <id>http://scottyeung.club/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/</id>
    <published>2019-11-04T08:15:25.000Z</published>
    <updated>2019-11-12T14:48:29.983Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://automatetheboringstuff.com/#toc" target="_blank" rel="noopener">本书</a>是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。</p><p>作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。</p><a id="more"></a><p>本书结构分为三部分：</p><ol><li>开头首先解释了为什么可以用编程提高效率以及为什么选择Python</li><li>Python的学习</li><li>Python在日常生活/工作的具体使用</li></ol><p>鉴于笔者已经学习过Python，故直接跳过前两部分，进行阅读记录。</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>程序运行时，数据可以存储变量中，但若想持久地存储数据，则需存储在文件中</li><li>文件的表示由路径+文件名组成</li><li>Windows系统路径使用\进行分隔 而Linux/Mac使用/，为确保代码能统一运行，可使用<code>os.path.join</code>进行连接路径</li><li><code>os.path.getsize</code>获取文件大小</li><li><code>os.listdir</code>获取文件夹内容</li><li>文件按内容可分为文本文件和二进制文件</li></ul><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><ul><li>过程<ol><li><code>open(path, mode=&#39;r&#39;)</code>打开文件返回<code>File</code>对象</li><li>通过<code>read</code>或<code>write</code>对文件对象进行读写</li><li><code>close</code>关闭文件对象</li></ol></li><li>文件打开分为读(r)，写(w)，追加(a)</li><li>read以字符串形式返回整个文件内容，readline逐行返回</li><li>可通过<code>shelve</code>模块进行变量的读取和保存</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="随机生成测试文件"><a href="#随机生成测试文件" class="headerlink" title="随机生成测试文件"></a>随机生成测试文件</h4><p>地理老师打算给35个学生出一份关于美国50个州对应的城市的选择题，目标形式为35个测试题文件，35个对应的答案文件，要求是35份选择题不一样，其中题目顺序不一样，选择题选项不一样。</p><ol><li>将测试数据以<code>dict</code>的形式存储在文件中/输入代码中</li><li>创建测试文件和答案文件，并写入首部信息</li><li>随机函数打乱数据给出的州的顺序，选出对应的城市，在给出的城市数据中删去正确答案，随机选出3个作为错误答案</li><li>将3中得到的州以及选项城市写入测试文件和答案文件</li></ol><h4 id="多重剪贴板"><a href="#多重剪贴板" class="headerlink" title="多重剪贴板"></a>多重剪贴板</h4><p>当需要多次进行复制粘贴时，下次的复制内容会把上一次的内容给覆盖，这样当需要重复使用复制内容时就很不方便。因此，实现多重剪贴板的功能，可以记录过往的复制内容，便于重复使用。</p><ol><li>每次运行程序时通过<code>shelve</code>读取本地的变量数据</li><li>根据输入的参数判断执行的功能</li><li>当需要记录剪贴板时，调用<code>pyperclip.paste</code>获取当前剪贴板内容，并存至变量</li><li>当需要展示历史剪贴板内容时，将存储的变量列表或单个变量转化为字符串通过<code>pyperclip.copy</code>复制进剪贴板</li></ol><h2 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h2><p>批量处理文件，包括遍历，复制，重命名，移动或压缩。主要使用<code>shutil</code>模块</p><ul><li>复制：<ul><li>shutil.copy </li><li>shutil.copytree </li></ul></li><li>移动：<ul><li>shutil.move</li></ul></li><li>删除<ul><li>os.unlink</li><li>os.rmdir 空目录</li><li>os.retree 目录所有</li></ul></li><li>遍历 os.walk 返回迭代器关于 current_folder,sub_folders,files</li><li>压缩 zipfile模块</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="文件名字转换"><a href="#文件名字转换" class="headerlink" title="文件名字转换"></a>文件名字转换</h4><p>将数千个文件的名字中的美式时间<br>(MM-DD-YYYY)改为欧式时间<br> (DD-MM-YYYY)</p><ol><li>构造正则表达式用于识别时间</li><li>遍历目录的名字 <code>os.listdir</code>，并通过正则表达式进行识别，并将其分割</li><li>若满足正则表达式，则通过shutil.move改名</li></ol><p>相关任务</p><ul><li>批量文件名字添加前缀</li></ul><h4 id="文件夹压缩"><a href="#文件夹压缩" class="headerlink" title="文件夹压缩"></a>文件夹压缩</h4><p>将指定文件夹及其下所有文件和文件夹压缩</p><ol><li>寻找一可用不重复的压缩路径+文件名</li><li>创建压缩文件</li><li>遍历目录，将所有文件和文件夹写入压缩文件</li><li>关闭压缩文件</li></ol><h2 id="WEB爬取"><a href="#WEB爬取" class="headerlink" title="WEB爬取"></a>WEB爬取</h2><p>设计模块</p><ul><li>webbrowser<ul><li>open 打开网页</li></ul></li><li>request<ul><li>get 获取资源</li><li>raise_for_status 判断是否就绪</li><li>iter_content 获取内容的迭代器</li></ul></li><li>Beautiful Soup 解析HTML文档<ul><li>select</li></ul></li><li>Selenium</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="批量打开网页"><a href="#批量打开网页" class="headerlink" title="批量打开网页"></a>批量打开网页</h4><p>根据给出的地址批量打开Google Map的网页</p><ol><li>根据给出的地址生成URL地址</li><li>使用<code>webbrowser.open</code>打开URL地址的网页</li></ol><h4 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h4><p>根据关键词进行google搜索，并将搜索结果的每一个页面打开</p><ol><li>根据关键词使用<code>request.get</code><br>请求搜索结果页面</li><li>使用Beautiful Soup解析页面，找出所有搜索结果的超链接</li><li>使用<code>webbrowser.open</code>打开获取的超链接</li></ol><p>类似用途：</p><ul><li>打开购物页面所有商品的页面</li><li>打开商品的所有评价页面</li><li>获取搜索图片的所有结果</li></ul><h4 id="下载网页漫画"><a href="#下载网页漫画" class="headerlink" title="下载网页漫画"></a>下载网页漫画</h4><p>下载XKCD的漫画，下载完后下载上一页，直至下载完第一页后结束</p><ol><li>获取XKCD的网页，抽取漫画部分写入文件</li><li>找到上一页按钮的超链接，并获取上一页的漫画网页</li><li>重复1-2直至找不到上一页按钮</li></ol><h2 id="操作Excel"><a href="#操作Excel" class="headerlink" title="操作Excel"></a>操作Excel</h2><p>利用第三方模块<code>openpyxl</code>，进行excel文件的读写</p><ul><li>load_workbook</li><li>get_sheet_by_name</li><li>cell(row=1, column=2)</li><li>save</li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="读取Excel并统计数据"><a href="#读取Excel并统计数据" class="headerlink" title="读取Excel并统计数据"></a>读取Excel并统计数据</h4><p>根据Excel文件的数据，进行聚类分析，分别进行聚类计数以及聚类求和。<br>事实上，Excel本身功能即可完成并且更加简单，故跳过。</p><h4 id="更新Excel文件中指定列"><a href="#更新Excel文件中指定列" class="headerlink" title="更新Excel文件中指定列"></a>更新Excel文件中指定列</h4><p>读取Excel文件，遍历每一行，如果该行为指定商品，则修改其价格</p><h2 id="操作PDF"><a href="#操作PDF" class="headerlink" title="操作PDF"></a>操作PDF</h2><ul><li>打开PDF文件并提取文本</li><li>PDF文档解密——输入密码</li><li>文档加密</li><li>创建pdf文件，添加页面</li><li>pdf页面合并——添加水印</li></ul><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><h4 id="多个PDF文档指定页面合并"><a href="#多个PDF文档指定页面合并" class="headerlink" title="多个PDF文档指定页面合并"></a>多个PDF文档指定页面合并</h4><p>选择目录下所有PDF文档的非首页按照字典序合并到一个新的PDF文档中</p><ol><li>获取当前目录所有文件名，并取出以.pdf结尾的文件名添加至数组</li><li>数组根据文件名排序</li><li>按顺序打开每一个PDF文档，每一个文档读取从第二页开始读取，添加至新文档</li><li>保存新文档</li></ol><h2 id="操作CSV和JSON"><a href="#操作CSV和JSON" class="headerlink" title="操作CSV和JSON"></a>操作CSV和JSON</h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>通过csv模块，可以进行csv的读写。读取类似于一个二维数组，写可以通过write_row写入行。</p><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p>读取目录下所有csv文件的数据，去除首部信息</p><ol><li>获取目录所有文件名，并进行遍历，非csv文件跳过</li><li>打开csv文件，读取csv数据，跳过第一行，其余的行添加进数组</li><li>将数组中的行以csv方式写入新文件</li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>Json为常用的一个数据格式，多用于API之间进行交互，但日常生活中用得比较少。通过json模块，可以将json格式的字符串转成dict。</p><h4 id="获取实时天气数据"><a href="#获取实时天气数据" class="headerlink" title="获取实时天气数据"></a>获取实时天气数据</h4><p>通过网上提过的天气服务接口，获取指定地点的实时天气情况</p><ol><li>通过命令行获取地点输入</li><li>将地点作为参数向指定天气服务API发送HTTP请求</li><li>解析返回的json数据，进行输出</li></ol><h2 id="操作Email"><a href="#操作Email" class="headerlink" title="操作Email"></a>操作Email</h2><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>根据Excel表格中的会员数据情况，给其中尚未支付本月会籍费用的会员发送邮件进行提醒</p><ol><li>打开Excel文件读取会员数据，判断最后一列是否为paid，若是，则记录会员名与邮箱地址</li><li>通过模块smtplib登录邮箱，跟根据上一步记录的信息一一发送邮件</li></ol><h2 id="自动化操作鼠标和键盘"><a href="#自动化操作鼠标和键盘" class="headerlink" title="自动化操作鼠标和键盘"></a>自动化操作鼠标和键盘</h2><p>通过第三方模块pyautogui实现，可进行图形界面的相关操作：</p><ul><li>控制鼠标以指定速度移动</li><li>获取鼠标位置</li><li>鼠标进行交互操作<ul><li>点击</li><li>拖动</li><li>滚动</li></ul></li><li>截屏</li><li>图像识别</li><li>键盘按下/松开 指定键/组合键</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://automatetheboringstuff.com/#toc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本书&lt;/a&gt;是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。&lt;/p&gt;
&lt;p&gt;作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="生产力" scheme="http://scottyeung.club/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="自动化" scheme="http://scottyeung.club/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="编程学习" scheme="http://scottyeung.club/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>summary of &lt;斯坦福高效睡眠法&gt;</title>
    <link href="http://scottyeung.club/2019/summary-of-%E6%96%AF%E5%9D%A6%E7%A6%8F%E9%AB%98%E6%95%88%E7%9D%A1%E7%9C%A0%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/summary-of-斯坦福高效睡眠法/</id>
    <published>2019-10-28T04:06:02.000Z</published>
    <updated>2019-11-12T14:48:29.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="睡眠的质比量重要"><a href="#睡眠的质比量重要" class="headerlink" title="睡眠的质比量重要"></a>睡眠的质比量重要</h2><h3 id="睡眠的长短"><a href="#睡眠的长短" class="headerlink" title="睡眠的长短"></a>睡眠的长短</h3><ul><li>睡眠的时间长短由基因决定，过长过短均不好</li><li>睡眠时间过长也没什么用</li><li>睡眠时间过短会导致睡眠债务，会引发<ul><li>肥胖/糖尿病/高血压等等疾病</li><li>突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险</li><li>影响寿命</li></ul></li><li>睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间</li></ul><a id="more"></a><h3 id="睡眠的质量"><a href="#睡眠的质量" class="headerlink" title="睡眠的质量"></a>睡眠的质量</h3><ul><li>睡眠分为REM与非REM阶段，后者为深层睡眠</li><li>睡眠的质量取决于入睡后90分钟的非REM阶段</li><li>better than nothing：马上行动改变</li></ul><h2 id="睡眠的重要性"><a href="#睡眠的重要性" class="headerlink" title="睡眠的重要性"></a>睡眠的重要性</h2><ul><li>睡眠的作用<ol><li>让大脑和身体休息</li><li>整理记忆</li><li>调节激素平衡</li><li>提高免疫力</li><li>排出大脑废弃物</li></ol></li><li>睡眠质量的认知<ul><li>失眠不只是睡的量的问题，更是质的问题</li><li>睡眠障碍（呼吸暂停）——腹式呼吸帮助</li></ul></li></ul><h2 id="睡眠法则"><a href="#睡眠法则" class="headerlink" title="睡眠法则"></a>睡眠法则</h2><ul><li>困了就睡</li><li>保证睡眠前90分钟的黄金时间<ul><li>尽快入睡进入深层睡眠</li><li>不被打扰</li></ul></li><li>体温开关：降低体表温度，缩小体表与体内温差</li><li>大脑开关：创造一个良好的睡眠环境，以营造一个睡眠的仪式感</li></ul><h2 id="高效睡眠法"><a href="#高效睡眠法" class="headerlink" title="高效睡眠法"></a>高效睡眠法</h2><ul><li>体温开关：营造体温下降这一过程，帮助入睡，具体一般为睡前先提高温度，再自然下降<ul><li>洗澡</li><li>足浴</li><li>调节室温</li></ul></li><li>脑部开关：切换到要睡觉的状态，大脑放空<ul><li>单调</li><li>数羊</li></ul></li><li>睡眠禁区：平常睡觉时间前两小时不想睡觉<ul><li>导致睡眠时间挪前难，一般只能一小时</li><li>需要早起时也不要强行早睡</li></ul></li></ul><h2 id="清醒战略"><a href="#清醒战略" class="headerlink" title="清醒战略"></a>清醒战略</h2><ul><li>清醒开关<ul><li>光：光遏制褪黑素 清醒 太阳光</li><li>体温：清醒时体温上升</li></ul></li><li>具体战略<ul><li>两个闹钟设在起床时间前后20-40分钟，避开在深度睡眠醒来</li><li>远离睡眠诱惑因素</li><li>光脚</li><li>冷水洗手</li><li>咀嚼</li><li>咖啡因</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;睡眠的质比量重要&quot;&gt;&lt;a href=&quot;#睡眠的质比量重要&quot; class=&quot;headerlink&quot; title=&quot;睡眠的质比量重要&quot;&gt;&lt;/a&gt;睡眠的质比量重要&lt;/h2&gt;&lt;h3 id=&quot;睡眠的长短&quot;&gt;&lt;a href=&quot;#睡眠的长短&quot; class=&quot;headerlink&quot; title=&quot;睡眠的长短&quot;&gt;&lt;/a&gt;睡眠的长短&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;睡眠的时间长短由基因决定，过长过短均不好&lt;/li&gt;
&lt;li&gt;睡眠时间过长也没什么用&lt;/li&gt;
&lt;li&gt;睡眠时间过短会导致睡眠债务，会引发&lt;ul&gt;
&lt;li&gt;肥胖/糖尿病/高血压等等疾病&lt;/li&gt;
&lt;li&gt;突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险&lt;/li&gt;
&lt;li&gt;影响寿命&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="睡眠" scheme="http://scottyeung.club/tags/%E7%9D%A1%E7%9C%A0/"/>
    
      <category term="读书" scheme="http://scottyeung.club/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="生活质量" scheme="http://scottyeung.club/tags/%E7%94%9F%E6%B4%BB%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何克服过于在意别人想法的心理</title>
    <link href="http://scottyeung.club/2019/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%87%E4%BA%8E%E5%9C%A8%E6%84%8F%E5%88%AB%E4%BA%BA%E6%83%B3%E6%B3%95%E7%9A%84%E5%BF%83%E7%90%86/"/>
    <id>http://scottyeung.club/2019/如何克服过于在意别人想法的心理/</id>
    <published>2019-10-23T01:24:35.000Z</published>
    <updated>2019-11-12T14:48:29.988Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。</p><a id="more"></a><h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>过于在意他人看法的人，往往：</p><ul><li>会以别人的评判标准来看待自己，试图以此满足他人期待</li><li>别人的评价对自己情绪影响很大</li><li>不知道也不会表达自己的需求</li><li>一定程度的讨好别人的倾向</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>害怕得罪别人<ul><li>害怕起冲突</li><li>害怕无法满足他人的期待</li></ul></li><li>自卑</li><li>敏感。心理承受能力差</li><li>将自己与他人对比</li><li>不能接纳自我。我们应该拥有无条件自尊，有条件的自尊只是在用一个找到的标准安慰自己<ul><li>依赖性自尊。依靠别人的评判标准</li><li>独立性自尊。按照自己的标准要求</li><li>无条件自尊。无条件完全接纳和尊重自己</li></ul></li><li>试图成为别人</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>别人没那么在乎你。<br>过于在意别人的想法本质上是自己将别人的想法看得太重要，把别人想法的后果看得太重要。因此，我们需要意识到，并没有多少人再关注你，对你有什么看法。不妨换位思考，看看你对他人是否有想法，有想法又能维持多久，他人对你的这个想法又有什么影响。他人的想法是没有任何实质性的影响，即使有，也是因为自己在意而产生影响。所以，我们需要<strong>不在意他人的看法</strong>，而一个重要的前提是：能够客观地分析自己的行为，有自己正确的看法。</p></li><li><p>明确自己才是最重要的。<br>活着本身是为了自己，如果不能够为了自己而活，那么你的一生相当于白过。所以，为了自己而活，我们完全有权利自私，完全可以把自己放在首位。</p></li><li><p>将自己的需求放在第一位，不必为了成全别人委屈自己。<br>接上上一条，因为自己是最重要的，顺带自己的需求也是最重要的。很多时候我们会因为外在的很多因素而受到制约，默默忍受。例如有些时候尽管很生气，也不敢表达出来，害怕伤害到别人，伤害到两者之间的关系，只能自己生闷气。但这种制约你行为的枷锁其实是无理的，别人不遵守你遵守，只能是自己吃亏。</p></li><li><p>不要害怕得罪别人。<br>不要总是充当老好人的角色，一直和和气气顺从别人，害怕得罪别人。要懂得接受这个事实，不会刻意去得罪别人，但也不怕得罪别人，即使无意得罪了别人，也不会担惊受怕，是我错，便承担，无错则置之不理，甚至反抗。</p></li><li><p>放弃成为更好的人这种幻想。<br>我们不必被世俗的要求所约束，好的，坏的都不是重要的，最重要的是，你想要的。</p><blockquote><p> 整个社会，整个人类世界都在推崇和鼓励你要去努力，要变得更好。<br>于是你开始对自己不满意，你开始讨厌自己，你开始强烈的不能接纳自己。<br>于是你开始自我否定，开始去追逐社会规定的那些优秀的定义，开始试图去迎合别人的看法，你因此变得很焦虑，你被对自己的不满和自己驱使着不断地向前走，你以为只要达成那些目标你就能轻松了，你就到达终点了，你就圆满了。<br>但是这一刻却始终不能到来，而你却一直被一种焦虑感控制和驱使着，这样你变得越来越着急，你觉得必须尽快到达那个终点，只有到达那个终点，只有变得更优秀了你才能不再这么焦虑，于是这种着急和焦虑会令你变得越来越浮躁，你会发现你离那些目标越来越远。<br>而有那么一些人即便是侥幸到达了他所自以为的那个终点，但到达的那一刻他却发现自己好像并没有体会到想象中的那种喜悦和满足，他也并没有放轻松，焦虑与痛苦始终还是如影随形。而他这个时候所体会到的很可能只是一种无边的空虚。</p></blockquote></li></ol><h2 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h2><ol><li><p>记录他人的想法，并且采取相应的行动。<br>既然在意他人的想法，不妨记录下来，并且逆着他的想法来做，而不是停止做这些事。让自己意识到，他的想法不能改变你的行为。你不想做某件事的理由只有两个：不想做；完成不了。</p></li><li><p>尝试与他人起冲突，并且坚持自己的决定，不被说服。</p></li><li><p>尝试表达自己的需求</p><ul><li>自己想要什么/想做什么</li><li>自己的情感</li><li>拒绝别人</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.club/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
      <category term="心态" scheme="http://scottyeung.club/tags/%E5%BF%83%E6%80%81/"/>
    
      <category term="心理学" scheme="http://scottyeung.club/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="overcome" scheme="http://scottyeung.club/tags/overcome/"/>
    
      <category term="他人评价" scheme="http://scottyeung.club/tags/%E4%BB%96%E4%BA%BA%E8%AF%84%E4%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>组会谈话启示录（一）</title>
    <link href="http://scottyeung.club/2019/%E7%BB%84%E4%BC%9A%E8%B0%88%E8%AF%9D%E5%90%AF%E7%A4%BA%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://scottyeung.club/2019/组会谈话启示录（一）/</id>
    <published>2019-10-16T07:50:35.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。</p><a id="more"></a><h2 id="About-Empirical-Study"><a href="#About-Empirical-Study" class="headerlink" title="About Empirical Study"></a>About Empirical Study</h2><ul><li>所谓的empirical study，其实就是对收集到的数据进行分析并report，关键是提出Research Question，类似于调查报告</li><li>基本流程为进行问题定义，范围局限，收集数据，分析数据，根据分析结果初步得出RQ/规律/特征，根据RQ重新修改/优化数据收集方式，report并回答RQ</li><li>非常适合新手进行科研入门，可通过此熟悉科研的流程</li><li>即使数据分析没有好的结果，如无规律/相关性，也可如实report成文</li><li>empirical study虽然简单，但是很重要<ul><li>科研入门</li><li>对assumption进行验证</li><li>后续的method/improvement需基于此</li><li>通过此进行数据收集</li></ul></li><li><p>虽然重要，但不能止于此</p><ul><li>实质性的东西？（report有什么用？</li><li>套路类似/方法雷同，难度递减</li></ul></li><li><p>how to start？在确定一个方向之后，拿出一张纸，依次写下研究的对象，定义，范围，数据收集/分析的方法/数据集，<strong>RQ</strong></p></li></ul><h2 id="About-Research"><a href="#About-Research" class="headerlink" title="About Research"></a>About Research</h2><ul><li>国外的PhD培养方案<ol><li>刚开始写一篇长篇的survey，借此了解当前该领域的研究背景/问题/方向</li><li>进行empirical study，收集数据，进行分析</li><li>利用前面的积累（数据，知识），进行creative的工作，如method/solution/improvement的提出或修改</li></ol></li><li>国内的现状则是大多数热衷于在3上面，一来就进行method上面的工作</li><li>国内博士的毕业情况还是要较好的，一般都能毕业（当然这个完全取决于导师<del>是否恶心</del></li></ul><hr><p>最后还是想吹一波现在的导师，真的感觉有一个好导师真是太重要了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://scottyeung.club/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
      <category term="科研" scheme="http://scottyeung.club/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="paper" scheme="http://scottyeung.club/tags/paper/"/>
    
      <category term="经验" scheme="http://scottyeung.club/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Ultralearning</title>
    <link href="http://scottyeung.club/2019/Summary-of-Ultralearning/"/>
    <id>http://scottyeung.club/2019/Summary-of-Ultralearning/</id>
    <published>2019-10-15T12:51:31.000Z</published>
    <updated>2019-11-12T14:48:29.983Z</updated>
    
    <content type="html"><![CDATA[<p>本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：</p><blockquote><p>A <strong>strategy</strong> for acquiring skills and knowneledge that is both <strong>self-directed</strong> and <strong>intense</strong></p></blockquote><ul><li>strategy: 它是一种学习的策略（just a strategy而非必须</li><li>self-directed：自我导向性（自我安排/计划</li><li>intense：强度高的</li></ul><p>总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念</p><a id="more"></a><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>纵观博主所遇到的各个ultralearner，是什么使他们在学习上取得如此成功呢？作者通过众多例子归纳出了具有指导作用的9条Principle，这也是全书的精华所在，解释了ultralearning所关联的重要性因素。</p><h3 id="1-meta-learning"><a href="#1-meta-learning" class="headerlink" title="1 meta-learning"></a>1 meta-learning</h3><p>从词根上来说，meta-可理解为元，meta-learning即元学习，类比于数据库中的mete-data，meta-data为描述数据的数据，meta-learning即为学习如何学习。此外，在书中的meta-learning还具有pre-learning的意思，即进行学习前进行的总体安排设计。</p><p>具体内容包括：</p><ul><li>如何高效地进行学习：学习能力的培养<ul><li>分析/搜索/计划</li><li>这个是最为总体也是最重要的内容，通用于所有项目</li></ul></li><li>所学知识的结构：组成/关系/规律</li><li>学习计划的设计/安排/执行</li><li>过往学习经历吸取经验</li></ul><p>针对具体的项目，meta-learning可以通过三个步骤开启</p><ol><li>why？ 仔细考虑为什么要学习这些内容？可考虑所学的目标是否符合下列因素之一<ul><li>利益/目标。所学的内容能给自身带来利益，如学习某技能能给自身带来提升机会/工资提升；或是能帮助自己达到某个目标，如通过考试/取得学位</li><li>兴趣爱好</li></ul></li><li>what？ 学习内容如何选择<ul><li>benchmarking。选择一个相近的基准作为自己的基准内容。如想进行CS相关的学习，可以找某些大学的CS学位的培养方案，选择一样的课程进行学习。这些内容可以来自网上/学校/专家/同辈</li><li>emphasize。选择感兴趣/重要的部分进行强化，增加比重</li><li>exclusive。相对不重要/不感兴趣的部分可以排除。</li></ul></li><li>how？ 进行学习计划的设计，主要考虑以下因素：<ul><li>学习内容选择。这里的内容指的是学习资源</li><li>目标。要学到一个什么程度</li><li>时间安排。</li></ul></li></ol><h3 id="2-Focus"><a href="#2-Focus" class="headerlink" title="2 Focus"></a>2 Focus</h3><p>专注，作为一种非常高效的状态，无论是在学习还是工作中，都是一个非常有用的工具。本章节主要从三个方面来讲专注：</p><ol><li>如何进入专注的状态？我们需要避免拖延。拖延主要来自于对即将开始需要专注事情的困难或带来的不适的恐惧和厌恶。因此，我们可以通过从事情的easy-part入手，到进入状态后再逐渐切换到困难部分。另外，我们可用采用5分钟原则，根据5分钟原则，无论事情多么困难，在5分钟之内都不会感到想要放弃，在5分钟之后，在通过减轻程度/切换目标来减缓不适感。</li><li>如何保持专注状态？<ul><li>进入<a href="https://en.wikipedia.org/wiki/Flow_(psychology" target="_blank" rel="noopener">flow状态</a>)（但不必强求</li><li>避免干扰。<ul><li>环境/任务/mind</li><li>接受杂念，任其发展，观其起落</li></ul></li><li>时间。长度足以进入状态，但不能过度致使疲劳而低效</li></ul></li><li>如何优化？保持正确/creative while stuck</li></ol><p>除了把专注当作一个高效率的工具以外，我们也应当将其当作一种能力来锻炼。这种能力，最好是通过在日常的使用中进行锻炼，习惯专注，尽量专注。当无法专注时，不妨思考一下所处的状况；当无法进入专注时，始于微处。</p><h3 id="3-Directness"><a href="#3-Directness" class="headerlink" title="3 Directness"></a>3 Directness</h3><p>在定义中提到，ultralearning的其中一个特点，就是self-directed，所以很自然地，directness也是一个重要的指导原则。这个原则指导我们，学习需要有明确的导向性，学习的内容最好就是直接指向所需的目标。通俗来讲，就是learn-by-doing。若所学的是一门技能，那便直接开做；若所学为一门用于交流的语言，则直接与他人交谈；而若所为的是一门考试，则练习题/真题无疑是最好的工具。</p><p>为什么需要直接练习呢？最主要的原因是知识的迁移问题。通常来讲，不同的学习内容具有不用的应用上下文，这导致了知识在使用的过程中难以迁移，同一个知识点，在一个背景可能适用，但换一个场景，可能就毫无用处了。这也可以说是知识的局限性。因此，我们最好就是在一开始就面向目标学习。</p><p>这个指导原则说来简单，相信很多人都知道，并且觉得诧异：难道还会有人不是直接学习所需的目标内容吗？确实有。原因有二。一是间接学习大多更为简单，举个例子，像学习外语，本身的目的是为了和他人交流，那最直接的目标不应该是直接用外语和他人交流吗？但事实上，最多人选择的学习外语方法是背单词。原因无他，相比于用外语与他人交流所产生的不适感中，更多人愿意呆在背单词的舒适区中。二则是某些内容难以直接练习，或者找到练习的机会。</p><p>面对以上情况，书中给出了几个方法。</p><ol><li>基于项目进行学习。拿程序员为例，以做一个程序项目为目标，学一部分，做一部分。</li><li>构造沉浸式环境。语言学习/社区圈子交流</li><li>模拟。</li><li>overkill。到达极端/超出要求。</li></ol><h3 id="4-Drill"><a href="#4-Drill" class="headerlink" title="4 Drill"></a>4 Drill</h3><p>钻研。该原则指导我们在学习时应该有所侧重，侧重在明显影响学习速率的地方，例如技能的瓶颈区，最重要的地方，最困难的地方。当克服了这些部分，总体能有很大的提升。这个也算是一个比较显而易见的原则，我们的认知能力往往有所局限，无法兼顾所有部分，因而需要有所侧重的学习。钻研步骤可分成两步：首先需要寻找值得钻研的部分，我们可以通过分解与实验的方法找出最为重要/最为影响速率的部分；接着就是设计钻研的方案，有以下5个方法：</p><ol><li>时间片段练习。当所学习的内容能够按照时间划分成一个个片段，如某些技能（篮球的上篮动作），划分后重点练习某些片段。</li><li>认知资源偏重。如语言学习侧重在听说读写某一个方面。</li><li>复制。当只想练习某内容的其中一部分而另外部分仍需要完成时，可以复制他人的其它部分，自己只亲自动手，完成钻研部分。</li><li>放大镜。放大想重点钻研的部分的比重，增大投入的时间/精力。</li><li>前置学习。钻研部分的前置部分也好好学习。</li></ol><p>这个原则也与上一个原则——Directness对应上了，对于学习内容选择，我们先采用Directness选择了内容的总体，再进行分解，选择Drill部分，进行钻研，最后再组合起来。</p><h3 id="5-Retrieval"><a href="#5-Retrieval" class="headerlink" title="5 Retrieval"></a>5 Retrieval</h3><p>对于复习来说，相对于被动的阅读进行复习，抛开书本进行主动的回忆效果要好上很多。通过主动的回忆，我们可以对自己进行知识的测试，并且加深对所学知识的记忆和印象。大概的解释有三个：</p><ol><li>知识迁移。</li><li>反馈。</li><li>JOL(Judgement of Learni)。人们对自身学习情况难以正确地感知，判断自己学得怎么样了。</li></ol><p>至于如何练习这种主动的复习方法，书中给出以下途径：</p><ul><li>记忆卡片。</li><li>自由回忆。</li><li>以提问形式。</li><li>以挑战形式</li></ul><p>另外，书本还给出了若干相关的实验数据，告知我们主动回忆效果的一些因素，分别是：开始时间，不需要准备好才开始，时间太晚，知识容易忘却，时间太短，不如被动方法；难度，越难的内容，效果比被动方法更好</p><h3 id="6-Feedback"><a href="#6-Feedback" class="headerlink" title="6 Feedback"></a>6 Feedback</h3><p>学习过程中，需要适当地接受反馈。尽管接收反馈有时会让人感到不安与恐惧，但好的反馈能够给我们提供许多信息，包括表现评价，问题所在，改进建议，这些信息能够帮助我们更好地改进下一步的学习计划。</p><p>什么是好的反馈？</p><ol><li>能够提供有用的信息</li><li>正确的信息</li><li>能够被正确地接收，并能引起回应</li><li>有促进作用</li></ol><p>反馈的种类</p><ol><li>结果型反馈。只提供一个整体的结果，如成绩/评分</li><li>信息型反馈。提供了问题的定位</li><li>校正型反馈。提供了修改建议</li></ol><p>如何合理接收反馈/提高反馈的质量？</p><ol><li>忽略噪声</li><li>使结果不可预测（可通过提高难度实现</li><li>除了学习内容本身外，接受meta-learning的反馈（计划，日程安排，资源选择</li><li>营造一个高强度或沉浸式的环境</li></ol><h3 id="7-Retention"><a href="#7-Retention" class="headerlink" title="7 Retention"></a>7 Retention</h3><p>记忆在学习中也是一个很重要的部分，知识概念需要记忆，技能步骤也需要记忆，然而保持长久良好的记忆不是一个容易的事，原因在于每个人都无法避免的因素——遗忘。</p><p>遗忘主要有三个原因</p><ol><li>时间侵蚀记忆。时间越久，记忆越难以保存</li><li>记忆间干扰。新增记忆取代/冲突/混淆了旧记忆</li><li>记忆不可访问。虽然内容还记得，但找不到触发记忆的路径/因素</li></ol><p>因此，针对遗忘的原因，可以通过一些技巧来减少遗忘</p><ul><li>间距记忆。通过划分时间段和知识进行记忆，每次记忆部分，并时常进行重复。日常使用单词卡为一个典型的例子</li><li>步骤记忆。相对于纸面上的知识，需要实际动手的技能更难以忘却</li><li>over-learning。学多一点，学深一点</li><li>记忆术。通过专门的记忆方法进行记忆，如关键词法，联想法。但具有一定局限性，如适用范围较窄，回忆较费力</li></ul><h3 id="8-Intuition"><a href="#8-Intuition" class="headerlink" title="8 Intuition"></a>8 Intuition</h3><p>通过学习建立相关的直觉。所谓的直觉，可以理解为对于所遇到问题，能进行自动归纳分类，遇到新的问题时，能够自发地对问题进行分解/抓取核心/组合/联系，并且得出问题解决的范式。其中，对于概念，我们需要理解；对于问题，我们需要大量积累，并通过练习，总结，得出通用的解决模式。</p><p>帮助建立学习中的直觉方法有：</p><ol><li>增加难度。难度较大时更易于钻研。</li><li>通过证明来理解概念。</li><li>具体例子帮助理解与记忆。</li><li>多提问。dump问题也不应该避开。</li></ol><p>另外，我们还可以通过费曼技巧，帮助我们更好地理解/掌握。费曼技巧的核心，在于迫使自己以解释/教授的方式，进行知识的加工输出，一方面可以帮助自己更好地学习，另一方面也可检测自身的学习情况。具体的步骤为：</p><ol><li>选择一个概念/问题</li><li>对于概念，尝试以通俗的语言像一个没有基础的人讲解，并能够使其明白</li><li>对于问题，独立形成一个可行的解决方法</li></ol><h3 id="9-Experimentation"><a href="#9-Experimentation" class="headerlink" title="9 Experimentation"></a>9 Experimentation</h3><p>多做试验，ultralearning的过程是一个探索的过程，永远没有一个完全正确的方案，只有只为适合自己当前的方案，所以必须靠我们通过试验进行探索，验证哪个更好，更适合。具体试验的内容包括：资源，技巧，风格，已经水平层次。在学习的过程中，我们也需要一直保持着这种实验的心态，带着一种可成长的思维模式，而非一成不变的定式。</p><p>以下为一些在试验上面有所帮助的技巧：</p><ul><li>copy and create。最开始可以照搬他人的学习方案，并且根据自身情况适度修改</li><li>对比。不同方法/资源/条件/技巧的比较</li><li>添加新约束</li><li>混合</li><li>极端</li></ul><h2 id="How-to-Start-a-Ultralearning-Project"><a href="#How-to-Start-a-Ultralearning-Project" class="headerlink" title="How to Start a Ultralearning Project"></a>How to Start a Ultralearning Project</h2><ol><li>Research 搜集相关信息进行meta-learning<ul><li>将要学的目标领域及其范围</li><li>将要使用的资源</li><li>他人成功学习的方法规范标准借鉴</li><li>直接练习的活动</li><li>备份的学习资源及钻研部分</li></ul></li><li>计划时间 取决于自身时间安排/所学的预期程度/空闲时间等因素<ul><li>计划投入多少时间</li><li>计划投入什么时候的时间</li></ul></li><li>执行计划 在执行计划时时常用上述的指导原则向自己提问是否符合，并进行调整/优化</li><li>检查结果 分析计划及其结果，吸取经验</li><li>维持学习结果/进一步学习 为了不至于遗弃学习成果<ul><li>定期复习</li><li>重新学习</li><li>进一步学习</li></ul></li></ol><h2 id="ultralearnner的培养"><a href="#ultralearnner的培养" class="headerlink" title="ultralearnner的培养"></a>ultralearnner的培养</h2><p>本部分通过介绍波尔加三姐妹的例子来说明如何培养ultralearner。<br>因为暂时没有人要培养的缘故，所以没什么兴趣，遂只是简单地略读摘录了相关重点记录保存。</p><h3 id="Raise"><a href="#Raise" class="headerlink" title="Raise"></a>Raise</h3><ol><li>早开始。越早开始越好，儿童时大脑功能更好更适宜学习。</li><li>专注。可以有多种学习内容，但需有一个侧重点，并专注于侧重点。</li><li>寓教于玩。将学习/练习转化成游戏，增添兴趣与持久性。</li><li>正向强化。通过胜利、鼓励等方式给予正向强化。</li><li>拒绝强迫。强迫学习无用，需要引导进行学习。</li></ol><h3 id="Suggestion"><a href="#Suggestion" class="headerlink" title="Suggestion"></a>Suggestion</h3><ul><li>Inspiring Goal</li><li>Be Careful with competition</li><li>Make Learning a Priority</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;strategy&lt;/strong&gt; for acquiring skills and knowneledge that is both &lt;strong&gt;self-directed&lt;/strong&gt; and &lt;strong&gt;intense&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;strategy: 它是一种学习的策略（just a strategy而非必须&lt;/li&gt;
&lt;li&gt;self-directed：自我导向性（自我安排/计划&lt;/li&gt;
&lt;li&gt;intense：强度高的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="学习" scheme="http://scottyeung.club/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="meta-learning" scheme="http://scottyeung.club/tags/meta-learning/"/>
    
      <category term="ultralearning" scheme="http://scottyeung.club/tags/ultralearning/"/>
    
      <category term="improvement" scheme="http://scottyeung.club/tags/improvement/"/>
    
      <category term="方法论" scheme="http://scottyeung.club/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="Scott H Young" scheme="http://scottyeung.club/tags/Scott-H-Young/"/>
    
  </entry>
  
  <entry>
    <title>保研之路</title>
    <link href="http://scottyeung.club/2019/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <id>http://scottyeung.club/2019/保研之路/</id>
    <published>2019-10-01T08:38:20.000Z</published>
    <updated>2019-11-12T14:48:29.986Z</updated>
    
    <content type="html"><![CDATA[<p>在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。</p><a id="more"></a><p><img src="/2019/保研之路/p1.JPG" alt="来自深夜的拟录取通知"></p><h2 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h2><p>最初诞生保研的想法是在大二上学期，那个时候我的一个同高中的直系学长刚好保研了去中科院软件所，在和他交谈时，我第一次接触到了保研这个概念，在此之前，我一直都是抱着早点就跑去实习搬砖的想法的。后来我看到了学院的推免名单和细则出来后，我看好像主要还是看GPA，那些加分都比较无关紧要（在国软的细则里，一个奖项可能就加零点零零几或者零点几，还要在乘以一个百分之十，真的算是无关紧要）。结合我当时的绩点，以及刚进行的奖学金评比看到的成绩排名，觉得还是挺稳的，当时甚至还时不时会幻想保研到哪个学校了。不过还是没有下定很大的决心，内心还是想着就业的。<br>在这种背景下，似乎保研准备也不需要付出额外的力气，继续保持，继续好好学习，保持绩点就行了，同时，根据细则的要求，只看必修课的绩点，我还可以集中精力在必修课，可以减少在一些选修课的投入精力和时间。</p><h2 id="突生变化"><a href="#突生变化" class="headerlink" title="突生变化"></a>突生变化</h2><p>在大二下学期的时候，发生了一件挺突然的事情：我们学院和计算机学院合并了。在上学期的时候部分老师就在有意无意的放出风声，但是就是没有人给出一个确定的说法，我们也只是当一个谣言对待，然后最后就真合并了，而且最后也没有给出一个官方的说法。每次提起这件事，我的内心其实都有点不爽，不过结合在计院待的这一年来说，计院的行政也就是这样，无从吐槽。<br>合并了对保研有什么影响呢？首先推免细则变了，会不会完全按照计院的来；其次推免的名额会不会有变化；最后，换了一批行政人员，会不会使事情变麻烦。当时我还挺天真的，心里想着改革不会也不应该影响到当前的学生。现在回看，当真是naive，<del>学校改革哪管学生死活</del>。抱着这种想法，我对保研的准备还是没什么变化，好好学习，好好准备必修课的考试，继续保持高绩点。<br>同时，在这一年了为了锻炼代码能力，尝试加入实验室/找老师做项目，但因为自身原因或老师原因，两次都无疾而终，甚至让我对实验室留下了一种不好的印象，对实验室有所抗拒，这导致了我在暑期实训时也没有找老师进实验室，而选择跟学校实训。回顾这几次过程，大致可得出几个教训：</p><ol><li>机会是需要靠自己主动争取的。上面提到的几次机会都是我偶然看到的消息才去找的，这导致了可选择的选项不多，并且quit了之后就无事可做。</li><li>驱使你做选择的因素不应该是有无机会，更应该看机会是否适合，是否好。</li><li>好老师/好实验室的影响很大，同理如果不好，影响也很大。</li></ol><h2 id="关键阶段"><a href="#关键阶段" class="headerlink" title="关键阶段"></a>关键阶段</h2><p>进入大三之后，距离保研的夏令营就只剩不到一年时间，上学期可谓是关键阶段。在上学期，我把能修的课都修满了，提前就修完了专选课和公选课（但到了下学期还是有点担心部分学分而再修了额外的课）。那段时间可以说是最忙的时候了，几乎是满课，有时真的下午下课后吃完饭顶不住，回来需要睡上一觉，再去上课。另外，为了增添一段科研经历，我主动发了邮件给老师说要进实验室，那段经历也是挺可怕的，在此期间，我得了组会恐惧症，每次组会开始前我内心都很焦虑，一方面没做什么，而另一方面又要想怎么回复，然后每次组会结束后，我几乎都会去大吃大喝，缓解压力，最终也没有任何产出/收获。<br>另外，15级新的保研细则也出了，成绩计算还是只算必修课，但是变成了相对赋分，而加分也是，且增加了很多的加分项（如班干部任职，CCF认证等）。看到这个新的细则，内心有点慌，因为还没有任何加分，而在相对赋分的情况下，可以拉很多分（如绩点3.6+凭借加分第一名，3.5+第二名），但另一方面，保研名额似乎也变多了，最低裸绩点3.4都保上了。<br>最终，在大三上学期，除了把课程几乎修完以外，几乎没有任何收获。绩点也因为nc的暑期实训拉低了0.1，科研方面也没有任何产出，且没有后续了。</p><h2 id="最后冲刺"><a href="#最后冲刺" class="headerlink" title="最后冲刺"></a>最后冲刺</h2><p>到了大三下，课程基本不多，一周其实就两三天课，可谓是全力备战保研的时候了。在这个学期我因为担忧没有科研加分，所以选择刷点加分。我选择的是CCF和全国大学生英语竞赛。前者我第一次近乎裸考就拿了270分，而300分就可以有加分。后者则是获奖比例高达80%。然而，前者出乎意料地翻车(<a href="http://scottyeung.club/2019/CCF-201903/">CCF-201903</a>)，后者则是在准备的时候就觉得自己已经没有希望了（虽然比例高，但基数小，参加的人都太厉害了），最终也没有拿到任何加分。<br>除了准备加分，我还在准备专业课知识的复习。专业课知识大体分为两部分，一部分是比较硬的，看重能力的，如数学，算法，这些需要的时间比较长，不太能速成；另一部分则是偏概念，偏背诵的。这个学期开始，我就在学堂在线刷数据结构和线性代数，并在五月底前完成。进入五月，开始收集各个学校的夏令营消息并且准备相应的材料。六月份确定参加的夏令营后则根据网上查询到的信息进行针对性的准备与学习，最终只参加了本校和南大计科的夏令营，北航和南大软院也进了，拒了，而七月中的时候收到了软件所软件中心的面试通知，也没去。本校夏令营没做什么准备就拿到了比较靠前的优秀营员名额，而南大夏令营相关情况<a href="http://scottyeung.club/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/">可点此查看</a>，开放日结束过几天就被老师告知考核通过，可录学硕。</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>开放日结束后，还需要回学校搬砖，做一个微信小程序，不知道什么时候能走。但因为手里已经拿到一个比较满意的offer，内心也已经放轻松了，就没有做后续的准备，包括软件所的考核以及九推的准备。唯一有点烦的，就是这个实训不知道什么时候结束，组员都不想做，但是又还没出分，不敢造次，担心影响到GPA。最终这个工作一直持续到开学，幸好给分还行。<br>开学第一周周五就进行推免申请工作，最终没有任何加分，GPA 3.85+，排名11，然后今年形势也非常有趣，科研加分最高也才13分，导致3分加分就大于0.1绩点，就等于当一年班干部就涨了0.1绩点，反正我也不准备九推，其实与我无关。我最终的综排18，也算还行，然后今年的名额暴涨，最低好像裸绩点3.4+也保上研了。所以前面的焦虑好像是多余的？</p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>前面说了如此多无聊的流水账，下面就说一点有用的干货弥补一下吧。</p><ul><li>成绩很重要。某个学长说过，成绩决定下限，从我本人的申请情况以及推免名额的获取情况来看，的确如此。部分学校筛入直接就根据排名筛掉，没有成绩直接就没有后续，除非你其它方面（科研/竞赛）特别强。</li><li>科研/竞赛要有但不用多。有奖项或论文产出固然是好，但没有也不要紧，因为有的只是少数人，但相关的经历还是需要有的，这在面试中可是一个回答利器，一方面可能面试官会直接发问，另一方面，也可以通过这些经历展示你的相关技能，研究能力和研究兴趣。这些经历可以通过进入实验室获得。</li><li>尽早研究推免细则，寻找加分机会。很多的加分其实获得难度是很低的，如软考，CCF或是当班干部，这些不仅难度不高，而且需要时间也不长，另外，参加竞赛或者大创，这就需要早一点准备了，但其实也不算难。像大创，找对老师指导就保底一个校级大创了。</li><li>做好信息收集。信息收集非常重要，保研不同于高考，每个人考完比分数就录取了。信息的收集影响到你学校院系的选择报名，考核内容的准备，实验室导师的选择。</li><li>做好自身实力定位，不妄自菲薄。所谓的实力定位，主要是看自己的成绩，看自己在哪一档，然后根据此可以选择同档次学校或高一档的学校。要记住机会总是有可能有的，不妨海投试试。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。&lt;/p&gt;
    
    </summary>
    
      <category term="保研经验" scheme="http://scottyeung.club/categories/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="流水账" scheme="http://scottyeung.club/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>云计算与软件工程</title>
    <link href="http://scottyeung.club/2019/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://scottyeung.club/2019/云计算与软件工程/</id>
    <published>2019-08-08T04:23:26.000Z</published>
    <updated>2019-11-12T14:48:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>想找点云计算的网课来看看，无意中发现了这个不错的mooc：<a href="http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about" target="_blank" rel="noopener">CS169.1X 云计算与软件工程</a>。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。</p><a id="more"></a><p>如课程所讲，软件工程是一个需要终身学习的概念，这其实更应该是一个程序员的核心技能，但往往我们都对此忽视，往往注重于单一的技能的术，而忽视最根本的道，即使是软件工程专业课，也只是沦为简单的概念背诵。希望可以通过这个课程，这个笔记，时刻提醒自己勿忘核心。</p><h2 id="软件工程概论"><a href="#软件工程概论" class="headerlink" title="软件工程概论"></a>软件工程概论</h2><ul><li><p>SaaS: 软件即服务</p><ul><li>无需担心安装/环境配置</li><li>无需担心数据丢失</li><li>易于协作同样数据</li><li>中心化数据</li><li>统一硬件系统环境：兼容性</li><li>易于更新：中心化</li></ul></li><li><p>SOA：面向服务架构</p><ul><li>系统由能提供服务的独立模块组成，每个模块通过接口提供服务，模块间通过接口进行通信</li><li>设计时最先设计接口</li></ul></li><li><p>SaaS‘s Demand On infrastructure</p><ol><li>Communication: 服务可交互</li><li>Scalability：可扩展性（增加规模服务<ul><li>集群</li></ul></li><li>Dependability：可靠性</li></ol></li><li><p>软件质量</p><ul><li>遗留代码：遗留的功能可用的代码，质量差 不算失败</li><li>质量标准：可用/易于开发调试修改</li><li>测试<ul><li>检验与确认：do the thing right and do the right thing</li><li>黑盒测试与白盒测试</li><li>单元/模块/集成/系统测试</li><li>回归测试：测试修改部分</li><li>测试覆盖率：覆盖率高不等于测试好</li></ul></li></ul></li><li><p>生产力因素</p><ul><li>代码简洁<ul><li>代码简短易于阅读</li><li>抽象等级高：高级语言</li></ul></li><li>代码合成<ul><li>code by example</li></ul></li><li>复用<ul><li>复用函数</li><li>标准库</li><li>对象/类</li><li>设计模式</li></ul></li><li>自动化工具</li></ul></li></ul><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><ul><li><p>plan-and-document</p><ul><li><p>模型</p><ul><li>瀑布模型</li><li>螺旋模型</li><li>RUP</li></ul></li><li><p>问题：</p><ul><li>需要强大的PM</li><li>沟通成本</li><li>文档驱动</li></ul></li></ul></li><li><p>敏捷开发</p><ul><li>四大宣言：个体协作/能用的软件/客户沟通/拥抱变化</li><li>极端编程：如果某个事是好的，则做到极致/最大化</li><li>测试驱动开发</li><li>行为驱动设计</li><li>Scrum开发<ul><li>team size</li><li>role：master PO</li><li>3个问题</li><li>解决冲突</li></ul></li></ul></li><li><p>结对编程</p><ul><li>driver</li><li>observer</li></ul></li></ul><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>课程的核心内容为利用Rails on Ruby搭建SaaS服务，所以Ruby也是一个重点。因为个人而言，编程语言最好的学习方法还是动手去做，因而就没有记录笔记了。下面为一些可能会用到的链接和个人的一些见解。</p><h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>列举比较特别印象深刻的或者是其它没有的</p><ul><li>究极面向对象：一切变量皆对象，一切函数皆方法</li><li>诗歌式编程：因为调用均方法=&gt;可省略括号=&gt;像语句一样</li><li>字符串/正则良好支持</li><li>元编程与反射：<ul><li>元编程：编写代码的代码</li><li>反射：运行时动态获取对象属性方法</li><li><code>method_missing</code>当方法在类中未定义时，进入该方法</li></ul></li><li>函数式编程</li><li>duck-typing:  能响应相同方法的被视作相同的类<ul><li>Module：为实现特定方法的实例提供相应的方法</li></ul></li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><p><a href="https://www.runoob.com/ruby/ruby-tutorial.html" target="_blank" rel="noopener">Ruby学习 菜鸟教程</a></p></li><li><p>课程编程作业</p><ol start="0"><li><p><a href>环境配置（待填坑</a> : 大坑！</p><ul><li>官方建议使用云端cloud9框架的IDE服务已被收归AWS并且停止原服务，使用还得绑定信用卡 </li><li>本地自行搭建的cloud9服务也无法按照官方仓库wiki配置方法进行配置</li><li>文档没有写清楚最重要的Ruby版本要求以及相关package的</li></ul></li><li><p><a href="https://github.com/yeung66/hw-ruby-intro" target="_blank" rel="noopener">hw-ruby-intro</a></p></li></ol></li></ul><h2 id="BDD和TDD"><a href="#BDD和TDD" class="headerlink" title="BDD和TDD"></a>BDD和TDD</h2><h3 id="BDD：行为驱动设计"><a href="#BDD：行为驱动设计" class="headerlink" title="BDD：行为驱动设计"></a>BDD：行为驱动设计</h3><ul><li>User Story：<ul><li>As role</li><li>to do what</li><li>So that achieve</li></ul></li><li>评价准则：SMART<ul><li>Specific &amp; Measurable：场景具体且易于测量/评价</li><li>Achievable：1轮迭代可实现</li><li>Relevant：具有实现价值</li><li>Timeboxed：具有时间界限</li></ul></li><li>流程：与用户交互生产user story card，并将其添加到待办项。根据优先级与难度选取用户故事进行实现</li><li>任务点数评价用户故事的难度，通常投票决定</li><li>使用Tracker可以追踪用户故事完成情况及开发速率</li></ul><h3 id="TDD：-测试驱动开发"><a href="#TDD：-测试驱动开发" class="headerlink" title="TDD： 测试驱动开发"></a>TDD： 测试驱动开发</h3><ul><li>FIRST原则：针对单元测试<ul><li>Fast</li><li>Independent</li><li>Repeatable</li><li>Self-Checking</li><li>Timely</li></ul></li><li>RSpec</li></ul><h2 id="SaaS应用结构"><a href="#SaaS应用结构" class="headerlink" title="SaaS应用结构"></a>SaaS应用结构</h2><ul><li>C/S结构</li><li>3层结构<ul><li>Web Server</li><li>App Server</li><li>Database<ul><li>ActiveRecord：model自己知道如何CRUD</li><li>DataMapper：通过mapper进行对象与数据库记录的映射</li></ul></li></ul></li><li>MVC<ul><li>view： template view | transform view</li><li>陷阱：fat controller/view</li></ul></li><li>RESTful</li></ul><h2 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h2><ul><li>MVC<ul><li>Model：ActionRecord</li><li>Controller：通过router转发到控制器</li><li>View：haml</li></ul></li><li>约定优于配置：符合约定不需配置文件，仅在不符合约定时配置文件</li><li>调试：RASP<ul><li>print</li><li>log</li><li>interactive</li></ul></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><h3 id="质量度量"><a href="#质量度量" class="headerlink" title="质量度量"></a>质量度量</h3><ul><li>Code Smells</li><li>SOFA原则<ul><li>Short</li><li>One：代码只做一件事</li><li>Few Arguments</li><li>Abstract：抽象在同一等级</li><li>Reek工具可分析</li></ul></li><li>ABC评分：变量，分支，条件数量<ul><li>通过flog评分，超过20有问题</li></ul></li><li>通过路径数量评分</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想找点云计算的网课来看看，无意中发现了这个不错的mooc：&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS169.1X 云计算与软件工程&lt;/a&gt;。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。&lt;/p&gt;
    
    </summary>
    
      <category term="课程笔记" scheme="http://scottyeung.club/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件工程" scheme="http://scottyeung.club/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="云计算" scheme="http://scottyeung.club/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>记2019南京大学计算机系开放日</title>
    <link href="http://scottyeung.club/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    <id>http://scottyeung.club/2019/记2019南京大学计算机系夏令营/</id>
    <published>2019-07-26T02:45:34.000Z</published>
    <updated>2019-11-12T14:48:29.992Z</updated>
    
    <content type="html"><![CDATA[<p>因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>因为早早抱着保研的想法，在学期中段就有这复习专业课的计划了，大致复习了如下内容：</p><ul><li>数据结构（非常重要</li><li>离散数学</li><li>线性代数</li><li>概率论</li><li>操作系统</li><li>计组</li></ul><p>对于南大计算机系夏令营的准备，其实开始得比较晚，因为其实海投了挺多夏令营，而计算机系的开放日时间刚好夹在一堆夏令营之间，时间相冲，一开始是抱着放弃南大计算机系的夏令营的，然而其它夏令营要么没进，要么出得很晚，最终还是选择了南大。</p><p>南大的准备主要还是准备算法方面的机试，在六月份的时候把刘汝佳的<a href="https://book.douban.com/subject/25902102/" target="_blank" rel="noopener">紫书</a>过了一遍，并且在voj上把部分的题刷了一下（时间太短刷的其实不多），题单可以<a href="https://vjudge.net/article/45" target="_blank" rel="noopener">看此</a>。另外，在看完书后，每天都上voj找一两道题练练手感，主要是dp和dfs的题。根据往年的题目来看，题目难度大概在LeetCode中等，当然也有直接POJ的原题，如果时间充足找个题单把POJ刷刷还是不错的。</p><p>面试的准备，则是参营前几天随便准备了自我介绍，项目经历，兴趣爱好等面试常问话题，当时时间紧，其实都还没准备完，还想着机试完后再准备。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>开放日活动共三天</p><ol><li>上午报到，下午机试</li><li>面试。分成上下午两批，每批大概十个组，每组十多人</li><li>介绍参观+与老师交流</li></ol><p>其实就主要三个活动：机试，面试，找导师签字。</p><h2 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h2><p>机试的形式在OJ形式，，两个小时，三道题，三百分，每道题十个测试样例，每个十分。<strong>机试非常重要！</strong> 这个在我从网上看到任何一个博客/经验帖里都这样说，甚至还有说面试只是走一个过场。我联系的导师也是这样对我说的，<del>面试给的分都差不多，而机试可能拉上百分。</del></p><p>可选择语言为C/C++ ， Java，提供的ide有Visual Studio和Eclipse。</p><h3 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h3><p>给一个不超过m(m&lt;=100)位的整数，从中移除k(k&lt;=m)位，使得剩下的整数最小。</p><p>当时的思路是每次移除最大的数字，然后有60分，但这个在后来做完其它回来重新想的时候已经发现有问题了，如对于<code>1032</code>，去掉3后显然没有去掉1小。当时考虑用dp重写，<code>dp(i,j)=min(10*dp(i-1,j)+num[i],dp(i-1,j-1))</code>,但没时间调试了。</p><p>现在搜索看到一个贪心的方法：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符。具体链接为<a href="https://blog.csdn.net/C20190413/article/details/77368590" target="_blank" rel="noopener">C++贪心算法之最小新整数</a></p><h3 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h3><p>B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，有多少种排队方式</p><p>直接就DFS了，<code>dfs(b,g,k)</code></p><ul><li>当<code>b==B&amp;&amp;g==G</code>时，成功，计数</li><li>当<code>b&gt;B||g&gt;G||k&gt;K</code>时，失败，返回</li><li>否则两种递归<ul><li><code>dfs(b+1,g,k+1)</code></li><li><code>dfs(b,g+1,0)</code></li></ul></li></ul><p>最后超时，70分。当时已经很满意了，直接跳过放弃优化。</p><h3 id="第三道题"><a href="#第三道题" class="headerlink" title="第三道题"></a>第三道题</h3><p>给出一个二叉树的前序遍历序列和后序遍历序列，问可能的二叉树有多少种</p><p>也是dfs解决,<code>dfs(preorder,postorder)</code>，直接AC了</p><ul><li>如果是叶子，返回1</li><li>找子树<ul><li>如果有两个子树，则返回子树的dfs乘积</li><li>如果只有一个子树，则返回2*子树的dfs</li></ul></li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>因为机试考得比较不错，加上前一晚准备时差不多是跟同房的同学吹了一晚水，面试准备得比较一般，晚上看了看英文wiki准备一下计算机学科相关话题，以及完善一下自我介绍与项目经历。</p><p>面试当天，探听到每个人的面试的形式基本一样，基本是自我介绍+专业/算法/项目问题+性格测试，而内容与难度则根据不同的组别可以有很大的差别，但感觉总体面试都不会为难学生，不会的问题老实说不会，也不会继续追问。本人的面试内容如下：</p><ul><li>中文自我介绍，没说时间</li><li>专业问题<ul><li>数据挖掘是统计还是概率</li><li>买桃问题：一个桃多少钱，三个桃核换一个桃，给定钱能有多少桃</li><li>立方体不借助工具怎么倒出一半水</li><li>最小生成树算法</li><li>单链表怎样在常数空间复杂度查有没有环</li></ul></li><li>项目相关<ul><li>聚类算法的结果是什么（第一个问题就踩雷，然后就没有后续了</li></ul></li><li>英语提问<ul><li>大学期间最感兴趣/擅长的课程</li></ul></li><li>性格相关<ul><li>喜欢跟什么样的人相处</li><li>遇到不好相处的人怎么办</li><li>遇到压力/挫折怎么办</li></ul></li></ul><p>面试时间规定是在十分钟内，但是这个基本都是由面试的老师来控制，我面试的时候没吃午餐+等了太久+有点紧张，我觉得发挥得挺一般的，有些能答出来的题都没答出来（那个单链表的题我还在LeetCode刷过，也没答出来，勉强给了个线性空间复杂度的解法），实在可惜。不过好像从最后的结果来看好像影响也不大？</p><h2 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h2><p>在挺早的时候，我院的一个老师帮忙宣传一个实验室时，我就发了简历给我联系的导师的实验室，然后在参加开放日之前几天，我又发了一封邮件联系，沟通得也不错。面试之后就找他聊一聊，顺带签字了。联系导师其实也不算难，我觉得不提前联系其实也是没什么问题，除去那些很热门的实验室和导师外，导师都还是很乐意为你签字。跟我一起去的同学，面试当天才联系导师签字，一气呵成。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>住：本次学生的住宿分成两批，一个是就在计算机系楼旁的国际会议中心，另一个是步行三十分钟左右的中公汇悦酒店。两者规格差不多，远的就麻烦一点，有行李可以坐公车。</li><li>食：看往年的帖子都说是发饭卡，还可以到超市买东西，而今年则只有指定饭堂的五张饭票，每张饭票当15元使用，只能单次使用，有点麻烦。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。&lt;/p&gt;
    
    </summary>
    
      <category term="保研" scheme="http://scottyeung.club/categories/%E4%BF%9D%E7%A0%94/"/>
    
    
      <category term="南京大学" scheme="http://scottyeung.club/tags/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="计算机系" scheme="http://scottyeung.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB/"/>
    
      <category term="夏令营" scheme="http://scottyeung.club/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
      <category term="开放日" scheme="http://scottyeung.club/tags/%E5%BC%80%E6%94%BE%E6%97%A5/"/>
    
      <category term="算法" scheme="http://scottyeung.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>枚举排列</title>
    <link href="http://scottyeung.club/2019/%E6%9E%9A%E4%B8%BE%E6%8E%92%E5%88%97/"/>
    <id>http://scottyeung.club/2019/枚举排列/</id>
    <published>2019-07-03T02:21:44.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>如何按字典序从小到大输出前n个数的所有排列？</p><a id="more"></a><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>将数字分成两部分：</p><ul><li>已确定前缀序列</li><li>待定元素</li></ul><p>每次移除一个待定元素添加到前缀序列末尾，进行下一次递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* A, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//尝试在A[cur]中填各种整数i</span></span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        <span class="keyword">if</span>(A[j] == i) ok = <span class="number">0</span>; <span class="comment">//如果i已经在A[0]~A[cur-1]出现过，则不能再选</span></span><br><span class="line">        <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">            A[cur] = i;</span><br><span class="line">            print_permutation(n, A, cur+<span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接生成"><a href="#直接生成" class="headerlink" title="直接生成"></a>直接生成</h2><p>该方法直接获取到排列序列</p><ol><li>将元素排序，记录初始序列。</li><li>将当前首元素记录。</li><li>每次将记录的元素右移1位（交换位置），生成一个排列</li><li>直到元素移到最右边，回到步骤2</li><li>当出现了初始序列时，排列生成完毕</li></ol><p>具体代码可以参照std标准库里面的方法<code>next_permutation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; //包含next_permutation</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">        sort(p, p+n); <span class="comment">//排序，得到p的最小排列</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]); <span class="comment">//输出排列p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(next_permutation(p, p+n)); <span class="comment">//求下一个排列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何按字典序从小到大输出前n个数的所有排列？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="排列组合" scheme="http://scottyeung.club/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://scottyeung.club/2019/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://scottyeung.club/2019/并查集/</id>
    <published>2019-06-19T03:59:22.000Z</published>
    <updated>2019-11-12T14:48:29.989Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p><p>有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作:</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开数组记录每个元素的从属情况，find操作返回元素从属情况，union操作修改其中一个元素的从属情况，将其合并</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单模板"><a href="#最简单模板" class="headerlink" title="最简单模板"></a>最简单模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i&lt;<span class="number">0</span>;i&lt;size;i++) <span class="built_in">set</span>[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="built_in">set</span>[x]?x:<span class="built_in">set</span>[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的情况下没有任何优化，易退化成链状查询，查询复杂度到达$O(n)$</p><h3 id="优化模板"><a href="#优化模板" class="headerlink" title="优化模板"></a>优化模板</h3><p>添加路径压缩，减少查询时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//使用递归写find函数，同时有路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">set</span>[a]!=a)<span class="comment">///循环方法查找前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="built_in">set</span>[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=x,j;</span><br><span class="line">    <span class="keyword">while</span>(i!=a)<span class="comment">///路径压缩,修改历经的前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="built_in">set</span>[i];<span class="comment">///记录x的前导结点</span></span><br><span class="line">        <span class="built_in">set</span>[i]=a;<span class="comment">///将i的前导结点设置为r的根节点.</span></span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a=Find(x);<span class="comment">///x的根节点为a</span></span><br><span class="line">    b=Find(y);<span class="comment">///y的根节点为b</span></span><br><span class="line">    <span class="keyword">if</span>(a!=b)<span class="comment">///如果a,b不是相同的根节点，则说明ab不是连通的</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[a]=b;<span class="comment">///将a,b连接，将a的前导点设置为b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>图的连通性问题：将所有节点合并邻接节点，判断是否属于同一集合</li><li>重复数据合并/关联<ul><li><a href="https://leetcode-cn.com/problems/accounts-merge/submissions/" target="_blank" rel="noopener">Leetcode 721 Accounts Merge</a>:</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。&lt;/p&gt;
&lt;p&gt;有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。&lt;/li&gt;
&lt;li&gt;Union：将两个子集合并成同一个集合。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="集合" scheme="http://scottyeung.club/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Windows快捷键</title>
    <link href="http://scottyeung.club/2019/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://scottyeung.club/2019/Windows快捷键/</id>
    <published>2019-06-13T12:07:11.000Z</published>
    <updated>2019-11-12T14:48:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>无意中在油管看到的快捷键集锦视频，有些还是挺有用的，遂记录之。</p><p>原视频<a href="https://www.youtube.com/watch?v=VeAK7Bv4F1o" target="_blank" rel="noopener">可点此</a></p><a id="more"></a><ul><li>打开新的虚拟桌面 <code>Win + Ctrl+ d</code></li><li>虚拟桌面切换 <code>Win + Ctrl + 方向键左/右</code></li><li>最小化所有应用并返回桌面 <code>Win + M</code></li><li>临时切回桌面 <code>Win + ,</code></li><li>最大化/最小化当前程序<code>Win + 方向键上/下</code></li><li>打开/收回任务栏中程序 <code>Win + 数字键</code></li><li>当前程序快速分屏 <code>Win + 方向键</code></li><li>查看所有程序 <code>Win + Tab</code> 或 <code>Win + Ctrl + Tab</code></li><li>任务管理器 <code>Ctrl +Shift +Esc</code></li><li>开启新的文件管理器 <code>Win + e</code></li><li>快速截图 <code>Win + PrintScreent</code></li><li>打开侧边栏 <code>Win + a</code></li><li>打开设置 <code>Win + i</code></li><li>快速锁电脑 <code>Win + l</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意中在油管看到的快捷键集锦视频，有些还是挺有用的，遂记录之。&lt;/p&gt;
&lt;p&gt;原视频&lt;a href=&quot;https://www.youtube.com/watch?v=VeAK7Bv4F1o&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可点此&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.club/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="Windows" scheme="http://scottyeung.club/tags/Windows/"/>
    
      <category term="shortcut" scheme="http://scottyeung.club/tags/shortcut/"/>
    
  </entry>
  
  <entry>
    <title>如何减少焦虑</title>
    <link href="http://scottyeung.club/2019/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E7%84%A6%E8%99%91/"/>
    <id>http://scottyeung.club/2019/如何减少焦虑/</id>
    <published>2019-06-07T09:20:09.000Z</published>
    <updated>2019-11-12T14:48:29.989Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的公众号推送中看到的一篇Scott H. Young的关于减少焦虑的博文推送，感觉方法还不错，刚好这段时间常常因为保研的事情而感到焦虑，遂打算写一篇文章学习一下方法。但也因为推送中的中文翻译实在有一点让人摸不着头脑，遂上文官网找了<a href="https://www.scotthyoung.com/blog/2019/05/14/worry-less/" target="_blank" rel="noopener">原文</a>重新阅读并记录。</p><a id="more"></a><p>每个人都会有焦虑，会担心犯错，担心收到批评，担心事业失败，担心社交出现问题，可以说焦虑的类型有很多。大多数的时间中，焦虑只是存在于脑海中，可以人为地忽视掉而不受焦虑，但当焦虑程度过深之后，便可能跳出你的脑海，影响到你的实际行动。<br>所以，我们必需采取方法来减少焦虑。</p><h1 id="减轻焦虑"><a href="#减轻焦虑" class="headerlink" title="减轻焦虑"></a>减轻焦虑</h1><p>焦虑的消除并不复杂，但是却是一个顽固的问题，我们可能需要一遍又一遍的解决同样的问题，但是焦虑的问题很少会完全消失。</p><h2 id="旁观者心态"><a href="#旁观者心态" class="headerlink" title="旁观者心态"></a>旁观者心态</h2><p>对于我们脑海中的思想，我们通常会认为它就是我们自身的一部分，思想的出现，是因为我们创造的原因，而且思想也是我们可以控制的东西。但是，按照这种思想的话，当我们无法摆脱焦虑的时候，我们就很容易对自身的能力而怀疑，感到焦虑，毕竟担心焦虑的出现以及控制也是一种焦虑。</p><p>所以，我们可以以一种旁观者的心态来对待这些思想，任其发生，只将其当作一种感官体验，虽然来自你的脑海内部，但也将其当成来自外部世界感受到的感觉一样，通过这种旁观者的角度，便不会轻易纠结于想要控制焦虑这种想法，使得焦虑加深，相反，对其抱着一种漠视的旁观者心态，逐渐可对其置之不理，减轻其影响。</p><p>如何练习这种旁观者心态呢？冥想是一个很好的手段。冥想本身也是一种观其自身思想的过程。同时，这种心态也可以联系到佛学中的无我思想，本质可以归结为，对于过往经历过的每件事，回顾并能承认自己无法控制。（个人对于佛学基本没有了解，原文给出的<a href="https://en.wikipedia.org/wiki/Anatta" target="_blank" rel="noopener">维基链接</a>也挂了，无法进一步了解）</p><h2 id="远离社交-社交媒体"><a href="#远离社交-社交媒体" class="headerlink" title="远离社交/社交媒体"></a>远离社交/社交媒体</h2><p>焦虑是可以传播的，只要有消息的传播，就可能导致焦虑的传播。本人觉得最为典型的例子是：考完试后，往往会有人聚在一起讨论试题与答案，然而大多数人对本次考试都有着自己的焦虑，例如某道题的做法或答案是否正确，他们或许企图通过对答案来获取他人的确认来消除焦虑，但实际上，往往无法如愿，但是焦虑却因此而传播：对方也会开始考虑这个问题自己是否正确。</p><p>有了社交媒体后，消息传播就变得更为便捷，可谓是无处不在了。刚考完的考试，课程群里马上就有考试题目或给分等相关的讨论，看到群里讨论的一系列问题，你的内心就不会引起对刚刚考试的联想，从而引起焦虑？</p><p>所以，我们应该根据你的承受力，恢复力等相关状况，挑选你的合适的环境，远离那些<br>会传播焦虑的环境。但非常可惜的是，虽然我们明知某些社交媒体环境会传播焦虑，但很多时候我们还是忍不住进入其中。正如上面所说的课程群，虽然考前你就知道会有相应的讨论，考后你还是忍不住点进去。那怎么办呢？这就涉及到自制力的提高问题了。</p><h2 id="找到最为焦虑的问题并直面"><a href="#找到最为焦虑的问题并直面" class="headerlink" title="找到最为焦虑的问题并直面"></a>找到最为焦虑的问题并直面</h2><p>焦虑分为两种，一种是单一的，可能是因为过往的某次事件而引发，如说了不当的话；另外一种是持续的问题，会反反复复的地出现，如对于事业，学习的焦虑。</p><p>对于前者，随着时间的推移便会逐渐减轻，而后者的话，则必须直面问题，找到一个持久有效的解决方法，学习如何去面对该问题。</p><p>原文这一点讲得较为笼统，而且我也觉得是一个知易行难的方法，便不继续展开。</p><h2 id="停止试图解决焦虑"><a href="#停止试图解决焦虑" class="headerlink" title="停止试图解决焦虑"></a>停止试图解决焦虑</h2><p>当你感到焦虑时，你往往倾向于向他人寻求安慰，而他人面对你的焦虑情况时，往往也只能对你给予安慰。虽然这样短时间之内让你感到更好，但事实上在之后会让事情变得更糟糕。使用安慰来回应焦虑的思维模式，实际上会通过负强化增强了这种模式。</p><p>在心理学的理论中，焦虑是一种动机，具有明确的目标，焦虑是为了识别出威胁并形成解决方案。当你因为某件事情感到焦虑时，若他人的安慰使你暂时变好了，当再出现类似问题时，你便倾向于再次陷入焦虑来解决问题。所以，越解决焦虑，越容易在后续引发焦虑。</p><p>此处给出了一个心理学家的建议：面对焦虑，抑制住解决问题的冲动，虽然这会使你焦虑更加严重，但因为没有形成解决方案，焦虑的思维模式被削弱了，当目标没有实现时，下次的回应便会减弱。</p><p>这个方法对我而言是一个挺有创新性的方法，个人感觉不错，值得学习。光看标题，还以为是类似方法一那一种忽视焦虑的方法。但其实不是，这个方法是从行为模式的角度出发，通过行为模式的效果反馈抑制行为模式的出现，通俗点说，就是让自己意识到焦虑无用后便不会焦虑，但这其实也我想到一个问题：焦虑是为了发现问题解决问题，削弱了这种行为模式后，对于问题的感官敏锐性会否也相应下降，会不会说虽然不焦虑的，但是已经没有感觉了，发现不了问题。但还是可以去尝试该方法。</p><h2 id="分析可行性而非合理性"><a href="#分析可行性而非合理性" class="headerlink" title="分析可行性而非合理性"></a>分析可行性而非合理性</h2><p>在陷入焦虑时，我们经常会通过试图将焦虑分类，找出合理的焦虑，忽视不合理的焦虑，从而减轻焦虑。但这事实上是不可行的，大多数的焦虑，都有其合理的基础，你的担心也不是一无是处，你会发现所有的焦虑似乎都是合理的，不可忽视。</p><p>所有，与其纠结于焦虑的可行性，不如切实地分析焦虑的源头问题，判断问题是否可行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在最近的公众号推送中看到的一篇Scott H. Young的关于减少焦虑的博文推送，感觉方法还不错，刚好这段时间常常因为保研的事情而感到焦虑，遂打算写一篇文章学习一下方法。但也因为推送中的中文翻译实在有一点让人摸不着头脑，遂上文官网找了&lt;a href=&quot;https://www.scotthyoung.com/blog/2019/05/14/worry-less/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;重新阅读并记录。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.club/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="状态调节" scheme="http://scottyeung.club/tags/%E7%8A%B6%E6%80%81%E8%B0%83%E8%8A%82/"/>
    
      <category term="焦虑" scheme="http://scottyeung.club/tags/%E7%84%A6%E8%99%91/"/>
    
      <category term="心理" scheme="http://scottyeung.club/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++ std::set</title>
    <link href="http://scottyeung.club/2019/C-std-set/"/>
    <id>http://scottyeung.club/2019/C-std-set/</id>
    <published>2019-05-21T04:40:46.000Z</published>
    <updated>2019-11-12T14:48:29.973Z</updated>
    
    <content type="html"><![CDATA[<p>集合作为一个比较重要的数据结构，具有不含重复元素的性质，在许多算法中实现去重操作时，都需要用到集合这个数据结构。在近来使用c++刷题，用集合踩过较多的坑以后，决定写篇东西记录一下标准库中的集合。</p><a id="more"></a><p>集合一般通过二分搜索树实现。集合内元素保持严格弱序性质</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>Associative：元素不是靠决定位置访问的</li><li>Ordered：容器内元素保持严格顺序</li><li>Set：元素的值通过元素的键标识</li><li>Unique keys：元素没有相同的键</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>集合的初始化有两种形式</p><ol><li>直接给出模板类型初始化集合<code>set&lt;template&gt; s;</code></li><li><p>给出模板类型以及比较对象</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">template</span>,Compare&gt; s;</span><br></pre></td></tr></table></figure><p> 其中Compare类为谓词类，需重载<code>()</code>运算符，在其中判断元素顺序</p></li></ol><p>对于基本类型而言，方法1足以解决一起，但是对于自定义结构体，则需进行额外的工作，以帮助集合组织元素以及判断元素是否相同。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>额外的工作其实就是两个元素的比较，通过一下两种方式可以实现</p><ul><li>重载<code>&lt;</code>运算符</li><li>谓词类重载<code>()</code>运算符</li></ul><p>元素的比较需满足对于两个相等的元素a，b有<code>a&lt;b</code>和<code>b&lt;a</code>都不成立。以一个坐标点的结构体为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;p)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x==p.x?y&lt;p.y:x&lt;p.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h2><ul><li><code>insert(value)</code>:插入元素</li><li><code>find(value)</code>：查找元素并返回迭代器,不存在时返回<code>set::end</code></li><li><code>erase</code>:取出迭代器位置元素/某值元素</li><li><code>count</code>：返回某元素的数量</li><li><code>empty/size</code>：判断元素数量是否为0/返回元素数量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合作为一个比较重要的数据结构，具有不含重复元素的性质，在许多算法中实现去重操作时，都需要用到集合这个数据结构。在近来使用c++刷题，用集合踩过较多的坑以后，决定写篇东西记录一下标准库中的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://scottyeung.club/categories/C/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="std" scheme="http://scottyeung.club/tags/std/"/>
    
  </entry>
  
  <entry>
    <title>判断二分图</title>
    <link href="http://scottyeung.club/2019/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://scottyeung.club/2019/判断二分图/</id>
    <published>2019-05-17T02:40:52.000Z</published>
    <updated>2019-11-12T14:48:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>给定一个无向图，判断这个图是否二分图。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><a id="more"></a><p>graph将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在0到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code>中不存在i，并且<code>graph[i]</code>中没有重复的值。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><ul><li>graph 的长度范围为 [1, 100]。</li><li>graph[i] 中的元素的范围为 [0, graph.length - 1]。</li><li>graph[i] 不会包含 i 或者有重复的值。</li><li>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。</li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>问题核心为如何判断一个图为二分图，似乎是在离散数学里面学过相关知识，但已经早已忘却。与二分图相关的资料可看<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">维基百科</a>。</p><p>我们可以通过二分图测试，在线性时间内判断一个图是否二分图。具体思路为：深度优先进行图遍历，在遍历的过程中对图进行二染色，即给相邻节点染上不同的颜色，当发现二染色时后有相邻节点颜色相同，即可判断不是二分图。</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><ol><li>初始化染色数组。染色数组包含三种状态：未染色（-1），0，1。</li><li>每一个节点深度遍历。若该节点未染色则进行染色，递归地对相邻节点进行染色，当发现相邻节点染色与当前节点相同，返回<code>false</code></li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;colors,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> color = colors[i]==<span class="number">-1</span>?<span class="number">0</span>:colors[i];</span><br><span class="line">            <span class="comment">// if(colors[i]==-1)</span></span><br><span class="line">        <span class="keyword">auto</span> adjs = graph[i];</span><br><span class="line"></span><br><span class="line">        colors[i]=color;</span><br><span class="line">        <span class="keyword">bool</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j=<span class="number">0</span>;j&lt;adjs.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[adjs[j]]==color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(colors[adjs[j]]==<span class="number">-1</span>) &#123;</span><br><span class="line">                colors[adjs[j]]=<span class="number">1</span>-color;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,colors,adjs[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=graph.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colors (n,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,colors,i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;p&gt;给定一个无向图，判断这个图是否二分图。&lt;/p&gt;
&lt;p&gt;如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="LeetCode" scheme="http://scottyeung.club/tags/LeetCode/"/>
    
      <category term="图论" scheme="http://scottyeung.club/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>异常检测</title>
    <link href="http://scottyeung.club/2019/%E2%80%9C%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%9D/"/>
    <id>http://scottyeung.club/2019/“异常检测”/</id>
    <published>2019-05-03T05:30:38.000Z</published>
    <updated>2019-11-12T14:48:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>一般的异常检测问题为：对于给定的一系列样本，给出一个新的测试样本，判断该测试样本是否属于这系列已知样本/该样本是否异常样本。异常检测为无监督学习方法。</p><p>例如：对于一批正常的引擎，监测带有一系列的数据（散热，震动强度），对于一个新的引擎，测得相关的数据，判断其是否异常引擎。</p><a id="more"></a><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>利用统计学知识，建立数据分布模型，并用已知样本进行参数估计。然后利用分布模型继续概率估计。一般选择使用高斯分布。</p><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>单元高斯分布<br>$$p(x;\mu;\sigma)={1\over \sqrt{2\pi \sigma}}e^{(x-\mu)^2\over 2\sigma^2}$$</p><ul><li>$\mu$为平均值，影响分布的对称轴</li><li>$\sigma^2$为方差，影响图形的胖瘦</li></ul><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><ul><li>$\mu = {1\over m}\sum_{i=1}^mx^{(i)}$</li><li>$\sigma^2= {1\over m}\sum_{i=1}^m(x^{(i)}-\mu)^2$</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>对于给定的训练集，从中选择能够反映出是否异常的特征</li><li>对于每一个特征，进行参数估计</li><li>得出模型$$p(x)=\prod_{j=1}^n p(x_j;\mu_j;\sigma_j)=\prod_{j=1}^n{1\over \sqrt{2\pi \sigma_j}}e^{(x-\mu_j)^2\over 2\sigma_j^2}$$</li><li>对于测试样本，如果$p(x)&lt;\varepsilon$,则为异常</li></ol><h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><ol><li>满足高斯分布，不满足的可以通过变形生成满足高斯分布的特征</li><li>由异常样本出发找特征</li><li>相关的特征可以构造新特征</li></ol><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>同一般的机器学习，我们将样本分成训练集、CV集、测试集，其中训练集不含异常样本。</p><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>因为样本为偏斜集（skewed class)，所以不能直接计算准确率，我们采用<br>$$F_1score={PR\over P+R}$$</p><ul><li>P:Precision 预测的准确率</li><li>R:Recall 召回率=真阳性/实际阳性</li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>因为其在测试时使用了带label的数据，类似于监督学习。</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><p>异常检测：</p><ul><li>异常样本数量很少，正常样本数量多</li><li>异常的类型很多</li><li>未来的异常类型不确定</li></ul></li><li><p>监督学习：</p><ul><li>正常异常样本都很多</li><li>异常样本数量足够多到能够了解异常样本是什么样的</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>异常检测<ul><li>欺诈检测</li><li>制造业</li><li>监控设备</li></ul></li><li>监督学习<ul><li>垃圾邮件过滤</li><li>天气预测</li><li>癌症分类</li></ul></li></ul><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>$$p(x;\mu;\Sigma)={1\over {(2\pi)^{n\over2} |\Sigma|^{1\over 2}}}e^{(x-\mu)^T\Sigma^{-1} (x-\mu)}$$</p><p>多元高斯分布可以直接得出特征之间的相关性</p><h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><ul><li>多元高斯分布可以直接得出特征之间的相关性</li><li>计算复杂</li><li>必须满足$m&gt;n$,且$\Sigma$可逆</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的异常检测问题为：对于给定的一系列样本，给出一个新的测试样本，判断该测试样本是否属于这系列已知样本/该样本是否异常样本。异常检测为无监督学习方法。&lt;/p&gt;
&lt;p&gt;例如：对于一批正常的引擎，监测带有一系列的数据（散热，震动强度），对于一个新的引擎，测得相关的数据，判断其是否异常引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://scottyeung.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>春秋古筮法</title>
    <link href="http://scottyeung.club/2019/%E6%98%A5%E7%A7%8B%E5%8F%A4%E7%AD%AE%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/春秋古筮法/</id>
    <published>2019-04-20T03:18:35.000Z</published>
    <updated>2019-11-12T14:48:29.990Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接触春秋古筮法是在大二上名为中国术数文化的公选课上。当时因为需要按类别选课，不得不选择中国与全国类别的公选课，恰好一直以来都对玄学有着谜之兴趣，就选了这门公选课。当时十几周的课程，现在我的印象就剩下春秋古筮法了，最终也能叫有所收获？</p><p>到了寒假，不知为什么又重新想到了春秋古筮法，然而大体以及忘记了，在重新复习了相关的方法后，为了不至于忘却，我萌生了开发一个春秋古筮法占卜的应用，然后在这个学期里大概花了两个星期的时间，上线了WEB版本，<a href="http://divi.scottyeung.club:8080/" target="_blank" rel="noopener">点此可体验</a>（因为服务器没有备案，所以暂且不能直接上80端口）。在基本完成之后的现在，打算写点东西记录一下。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在谈什么是古筮法之前，我们先来谈谈，是什么？</p><p>所谓的“占”，指的是解读兆象吉凶，也就是我们现在说的铁口直断的断。</p><p>据《周礼》记载，古代的占法主要有三项：占卜、占筮、占梦。占卜是通过灼烧龟壳得出兆象，占筮则是通过蓍草演算出卦象，占梦则是根据梦境来预测吉凶。然而其中的占卜和占梦的方法都已经失传，现在从周朝流传下来的占法就只有占筮，这就是流传下来的春秋古筮法</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>传统的方法使用的是蓍草，在我们的实操中，使用纸牌也行（课堂上用的就是纸牌）</p><ol start="0"><li>初始选择49张纸牌</li><li>将其随意分成2堆</li><li>随意从1堆中拿出1张单独放置</li><li>两堆牌分别4张4张地数，记录余数，余数为0时记作4</li><li>将余数的牌取出来弃置</li><li>将两堆牌合并后，回到步骤1，合共重复3次</li><li>三次变化之后，牌数除以四，就得出9、8、7、6中的一个，此为一卦六爻中的一爻，分别是变爻阳爻，阴爻，阳爻，变爻阴爻。其中阳爻为<code>-</code>,阴爻为<code>--</code></li><li>上述步骤重复六次，分别得到六爻，此为卦象。卦象中爻的顺序自下到上</li></ol><p>每一爻需要3次变化，求出6爻共需要18次变化，此所谓“十有八变而成卦”。</p><h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>当得出卦象后，我们可以根据《周易》来断卦。周易共分为64节，每一节对应一个卦象，小节中包含卦义卦辞，及各爻爻辞。周易的卦象爻辞解释网上随处可以找到，这里就不直接给出。</p><p>根据卦象变卦数量情况，可分为：</p><ul><li>无变爻：看卦辞卦义</li><li>单变爻：看本卦变爻爻辞</li><li>三变爻：本卦和变卦的卦辞卦义</li><li>五变爻：变卦的卦辞卦义</li></ul><p>以上的规则都是古书里的春秋筮例中归纳出来的，并没有什么确定性的表述或规则，所以如果你问为什么要这样看，或者为什么不那样看，我不能回答你，估计也没有人能回答你。</p><h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>整个古筮法分为得出卦象，解卦两方面。<br>碍于变爻需要根据特定情况的分析，且找到的周易卦象解释了没有具体的爻辞解析，所以整个程序忽略的变爻，并直接使用卦象本身卦辞卦义作为解释。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>卦象数据的来源为<a href="https://www.eee-learning.com/" target="_blank" rel="noopener">易学网</a>，感觉是一个非常专业而全面的易经学习网站。我使用爬虫爬取了64卦的卦文，运程分析等相关资料。</p><p>卦象的生成为六爻的随机生成组合。并根据相应的卦象返回相应的解读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次接触春秋古筮法是在大二上名为中国术数文化的公选课上。当时因为需要按类别选课，不得不选择中国与全国类别的公选课，恰好一直以来都对玄学有着谜之兴趣，就选了这门公选课。当时十几周的课程，现在我的印象就剩下春秋古筮法了，最终也能叫有所收获？&lt;/p&gt;
&lt;p&gt;到了寒假，不知为什么又重新想到了春秋古筮法，然而大体以及忘记了，在重新复习了相关的方法后，为了不至于忘却，我萌生了开发一个春秋古筮法占卜的应用，然后在这个学期里大概花了两个星期的时间，上线了WEB版本，&lt;a href=&quot;http://divi.scottyeung.club:8080/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此可体验&lt;/a&gt;（因为服务器没有备案，所以暂且不能直接上80端口）。在基本完成之后的现在，打算写点东西记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.club/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="玄学" scheme="http://scottyeung.club/tags/%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CCF 201903</title>
    <link href="http://scottyeung.club/2019/CCF-201903/"/>
    <id>http://scottyeung.club/2019/CCF-201903/</id>
    <published>2019-04-18T03:34:47.000Z</published>
    <updated>2019-11-12T14:48:29.974Z</updated>
    
    <content type="html"><![CDATA[<p>最后一次的认证，事前准备了差不多一个月，都觉得没什么问题了，考的时候还做出了四道题，觉得三百分是稳的。然后一查成绩，居然比第一次基本没怎么准备还低（第一次270），不甘心，又无奈。</p><p>于是等到网上出了题后，把当时提交的题重新做一遍，提交一遍，重新看看问题在哪，写一写题解。也不是想要证明什么，只是觉得努力不应该被白费？<br>代码链接<a href="https://github.com/yeung66/codesAboutCCF/tree/master/201903" target="_blank" rel="noopener">点此</a><br><a id="more"></a></p><h2 id="小中大"><a href="#小中大" class="headerlink" title="小中大"></a>小中大</h2><p>题目为有序序列中找最大值，最小值和中位数，并按大到小的顺序输出。</p><p>非常简单，最大最小值直接按索引取值即可，中位数则需要根据个数的奇偶性判断要不要取均值。</p><p>然而，第一道题的输入样例就给错了，样例2的输入并不是有序的，这就引发了我一个非常关键的问题：最值怎么取？是根据他说的原本有序取两侧，还是取实际的最值？我当时想的是前者，这就又引发出了另一个问题，中位数可能比最大值大或者比最小值小，所以三者又做了额外的排序，耽误了一定的时间。</p><p>最后直到我第二题都差不多做完，才通知说题目有误，改了样例。而我上面的代码一样符合它的思路，只是做多了额外功夫，测试了一下新样例就完事了。</p><p>最后这题拿了100分</p><h2 id="二十四点"><a href="#二十四点" class="headerlink" title="二十四点"></a>二十四点</h2><p>题目为根据输入表达式判断结果是否等于24。</p><p>对于有着eval的Python的选手来说，非常简单，处理一下输入调用<code>eval</code>即可。考试时注意到除法为整除，而Python3已经将整除变为<code>//</code>所以先用replace替换一下除号即可。</p><p>然而这道题我拿了40分，考后提交发现运行错误。细看题，发现题目中给出的乘号居然是小写字母<code>x</code>来表示。为什么会发现不了？当时因为第一题题目本身有问题，耽误了一点时间，所以做得比较快，而且最关键的是，<strong>这一次全部题面都用了图片，包括输入样例！！！</strong>我们只能一个个手敲输入样例，因为是手敲样例的缘故，自己就直接先入为主当成*号了，发现不了看错题的情况，血崩。</p><p>发现问题后对乘法做一个处理，将x替换成*，问题解决，100分。</p><h2 id="损坏的RAID5"><a href="#损坏的RAID5" class="headerlink" title="损坏的RAID5"></a>损坏的RAID5</h2><p>麻烦模拟题</p><p>待续</p><h2 id="消息传递接口"><a href="#消息传递接口" class="headerlink" title="消息传递接口"></a>消息传递接口</h2><p>一个比较典型的死锁问题，感觉可以用信号量去解决。</p><p>当时跳了这道题没做，现在估计也不会去做。</p><h2 id="317号子任务"><a href="#317号子任务" class="headerlink" title="317号子任务"></a>317号子任务</h2><p>多源点最短路径问题</p><p>题目要求给出图中每一个点到k个特定类型的点的最短路径和。</p><p>对于图论题我一直都是抱着能拿分就拿分的态度，超时的话一般都不考虑，于是直接采用最为暴力直接的方法——弗洛伊德算法，直接求出多源点最短路径，复杂度为$O(n^3)$，求出后直接找每个点到特定点的距离，排序后取前k个求和即可。</p><p>考试时，这道题我得了0分，现在重新提交，显示运行超时。运行超时我并不感到意外，但是超时到连第一个样例都过不了？？？重新看数据规模，发现这里第一档的数据（30%的数据），点的规模就已经到了500，重新翻了翻以往的图论题，别的单源最短路径或者最小生成树的问题第一档数据规模一般都是$10$,今年因为放到了第五题，强行通过数据规模提高难度，也是醉了。但是即使如此，现在的模拟提交因为时间只有1秒超时，在考试的时候时间上限是10s，10s也不能跑完第一档的数据？很奇怪。</p><p>换用了C++重新写了一个C++版本的弗洛伊德算法，还是超时0分。上网搜了一下，相关题解只有<a href="https://www.cnblogs.com/brainm/p/10548893.html" target="_blank" rel="noopener">一个</a>，而且也是用弗洛伊德算法。将其直接复制提交，提示错误，这次不超时了，但是时间也接近界限了。一样的方法为什么它可以不超时？我一直贴近它的代码修改我的，可是我的代码还是一直超时，莫得办法。看它的代码，没有考虑重边和自环。修改后还是错误。暂时只能放弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后一次的认证，事前准备了差不多一个月，都觉得没什么问题了，考的时候还做出了四道题，觉得三百分是稳的。然后一查成绩，居然比第一次基本没怎么准备还低（第一次270），不甘心，又无奈。&lt;/p&gt;
&lt;p&gt;于是等到网上出了题后，把当时提交的题重新做一遍，提交一遍，重新看看问题在哪，写一写题解。也不是想要证明什么，只是觉得努力不应该被白费？&lt;br&gt;代码链接&lt;a href=&quot;https://github.com/yeung66/codesAboutCCF/tree/master/201903&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>循环体中局部变量的小坑</title>
    <link href="http://scottyeung.club/2019/%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>http://scottyeung.club/2019/循环体中局部变量的小坑/</id>
    <published>2019-04-12T11:37:42.000Z</published>
    <updated>2019-11-12T14:48:29.990Z</updated>
    
    <content type="html"><![CDATA[<p>前几个晚看《The Go Progromming Language》时，在<a href="https://yar999.gitbooks.io/gopl-zh/content/ch5/ch5-06.html" target="_blank" rel="noopener">匿名函数</a>的最后一小节中，发现了一个比较有趣的小坑。<br>大概的场景为：首先创建一些目录，然后对于每一个目录，分别声明一个匿名函数删除目录，样例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以先自行考虑一下，有没有什么问题，效果会是怎样</p><a id="more"></a><h1 id="警告：捕获迭代变量"><a href="#警告：捕获迭代变量" class="headerlink" title="警告：捕获迭代变量"></a>警告：捕获迭代变量</h1><blockquote><blockquote><p>（颇为中二的标题名字是从书上搬过来的</p></blockquote></blockquote><p>上面的代码是有问题的，运行后<code>rmdirs</code>中每一个函数的效果都是删除最后一个目录。</p><p>为什么没有出现我们预期的效果呢？原因在于循环变量的作用域。</p><blockquote><p>。在上面的程序中，for循环语句引入了新的词法块，循环变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。</p></blockquote><p>正确的代码应该如下修改，通过在块级中声明一个局部临时变量，将其代替循环变量放入匿名函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := dir <span class="comment">// declares inner dir, initialized to outer dir</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这个修改是可行的？原因很简单，我们在匿名函数内部使用的是一个局部的临时变量，因为是临时的，块级代码结束时，变量地址指向内容很可能要回收，所以不能存储地址，只能够存储变量的值。<br>那为什么前者的代码匿名函数值中记录的就是变量的内存地址？循环变量不也属于这个词法块吗？还真不太一样。循环变量虽说也是由循环词法块被声明，但是相对于词法块内的代码，它实质上是一个全局变量的地位，它对于代码块的每一次执行都是一样的地位，一样的地址,所以实际存储的是变量的地址。</p><h1 id="JavaScript中的循环变量"><a href="#JavaScript中的循环变量" class="headerlink" title="JavaScript中的循环变量"></a>JavaScript中的循环变量</h1><p>当时看到书，我第一时间就想到了JavaScript中也有着同样的情况，我之前还遇到过类似的问题：给一系列的控件绑定事件触发函数，每个函数中根据循环变量设定条件，然后出现了相似的问题。当时采用的解决方法是提到了参数处理的，治标不治本。</p><p>看到这里后，我马上就用JavaScript复现了这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    arr.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">f</span>)=&gt;</span>&#123;f()&#125;)</span><br></pre></td></tr></table></figure><p>结果就如同预期一样，输出了5个4，没有达到预期。然后用跟在Go一样的思路，在循环体内部中使用一个临时局部变量代替，运行后出现预期效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i</span><br><span class="line">    arr.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(j)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">f</span>)=&gt;</span>&#123;f()&#125;)</span><br></pre></td></tr></table></figure><p>注意到这里用的是<code>let</code>而不是<code>var</code>。使用 let 语句声明一个变量，该变量的范围限于声明它的块中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几个晚看《The Go Progromming Language》时，在&lt;a href=&quot;https://yar999.gitbooks.io/gopl-zh/content/ch5/ch5-06.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;匿名函数&lt;/a&gt;的最后一小节中，发现了一个比较有趣的小坑。&lt;br&gt;大概的场景为：首先创建一些目录，然后对于每一个目录，分别声明一个匿名函数删除目录，样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; rmdirs []&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, dir := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; tempDirs() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    os.MkdirAll(dir, &lt;span class=&quot;number&quot;&gt;0755&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rmdirs = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(rmdirs, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        os.RemoveAll(dir) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大家可以先自行考虑一下，有没有什么问题，效果会是怎样&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://scottyeung.club/categories/Go/"/>
    
    
      <category term="GO" scheme="http://scottyeung.club/tags/GO/"/>
    
      <category term="JavaScipt" scheme="http://scottyeung.club/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>图论常见题目及算法</title>
    <link href="http://scottyeung.club/2019/%E5%9B%BE%E8%AE%BA%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/图论常见题目及算法/</id>
    <published>2019-03-14T13:00:07.000Z</published>
    <updated>2019-11-12T14:48:29.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近来都在刷CCF的题，准备认证考试。最近几天开始刷其中的第四题，一般而言，CCF的第四题都是图论题。对于我这样之前没怎么刷题的人来说，图论题看上去就感觉很难，主要是感觉到很陌生，因为在实际的开发过程中比较少用到图这样的数据结构，都是线性的数据结构，连树都比较少用。</p><p>但是在刷得比较多的图论题后，发现其实图论题好像也就那么回事，也不是说简单，主要感觉来来去去都是考那几个东西，如果是没有接触过或者不会做的话，可能有点难，但是只要接触过相似的，直接套板子修改就行了（当然也有可能是我还接触的不够多XD），另外，就是感觉没有什么题是DFS/BFS不能破，只是会不会超时，能拿多少的分的问题（对于CCF认证只想拿300分而言，有几十分就够了），其实很多算法的核心也就是DFS与BFS。</p><p>所以在今晚刷完了CCF往年所有的第四题后，总结一下最近接触的图论问题及解法。</p><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先，在解决问题之前，我们要先做好图论输入的模拟，图可以分为有向无向，有无权值。一般是以邻接矩阵或者邻接表的形式表示。</p><ul><li>邻接矩阵 :<code>graph = [[INF/False for _ in range(n+1)] for _ in range(n+1)] #带权值或无权图</code></li><li>邻接表：<code>graph = [{}/[] for _ in range(n+1)] # 带权值或无权图</code></li></ul><p>一般来说，邻接矩阵表示比较简单，但是时间空间成本都比较高，选用邻接表比较好，不过在CCF的认证似乎差别不大（样例水</p><h1 id="问题及解法"><a href="#问题及解法" class="headerlink" title="问题及解法"></a>问题及解法</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul><li><p>问题：给一个无向带权图，选取其中一定数量的边生成一个包含所有点的树，且权值最小</p></li><li><p>方法：</p><ul><li>Prim算法：优先队列+BFS 每次弹出距生成树距离最小的未加入生成树的点</li><li>Kruskal算法：边排序+并查集</li></ul></li><li><p>实例：</p><ol><li>最优灌溉</li><li>数据中心</li></ol></li></ul><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ul><li>对于一个图，指定两点间的最短距离，或者是指定一点的最长路径长度</li><li><p>方法：</p><ul><li><p>迪杰斯特拉算法：优先队列 每次弹出到源点距离最小的点，并修改邻接的未确定点，记录确定情况</p></li><li><p>spfa：队列 将源点入队列，每次弹出点后，修改邻接的点的距离，若修改且未入队则加入队列，记录入队列情况</p></li><li><p>floyd算法：求多源最短路径问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>变形：</p><ul><li>最短路径中对特殊点有数量限制：spfa中将数量记录放入队列 开二维dp数组</li><li>大路小路问题（小路的权值为连续小路权值的平方）：floyd算法生成新的小路边 开两个dp数组进行spfa</li></ul></li></ul><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><ul><li><p>在有向图中，两个点互相可达称为强连通，任意两点均为强连通的子图称为强连通分量</p></li><li><p>方法：</p><ul><li><p>Tarjar算法：记录节点访问时间及最短时间，深度遍历邻接点并入栈，更新最短时间。当出现访问时间等于最短时间时，栈顶到该节点构成一个强连通分量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tarjan</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ans,time</span><br><span class="line">    time+=<span class="number">1</span></span><br><span class="line">    DNF[i]=LOW[i]=time</span><br><span class="line">    stack.append(i)</span><br><span class="line">    instack[i]=<span class="literal">True</span></span><br><span class="line">    visited[i]=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> edges[i]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[j]:</span><br><span class="line">            tarjan(j)</span><br><span class="line">            LOW[i]=min(LOW[j],LOW[i])</span><br><span class="line">        <span class="keyword">elif</span> instack[j]:</span><br><span class="line">            LOW[i]=min(LOW[j],LOW[i])</span><br><span class="line">    <span class="keyword">if</span> DNF[i]==LOW[i]:</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            instack[node]=<span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node==i:<span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>变形：</p><ul><li>如果只是求强连通的点的对数，也可直接每一个点分别BFS/DFS，确定单向可达性</li></ul></li></ul><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><ul><li>在树中，任意两个叶子节点的最长路径为树的直径</li><li>方法：当成图两次BFS，第一次任一点开始，第二次由第一次结果开始</li><li>实例：<ul><li><a href="http://scottyeung.club/2019/03/14/CCF201503-4-%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6/">网络延时</a></li></ul></li></ul><h2 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h2><ul><li><p>一个图如果能从一个点出发，每条边都经过一次后回到起始点，则这个图为欧拉图，这个遍历的路径为欧拉路径</p></li><li><p>方法：</p><ol><li>检查连通性：并查集 find union 检测是否每一个点都属于同一集合</li><li>检查是否存在欧拉路径：每个点的度数均为偶数，或只有两个点度数为奇数且这两个点为起点终点</li><li>确定存在欧拉路径后，直接DFS遍历，记录访问过的边</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;近来都在刷CCF的题，准备认证考试。最近几天开始刷其中的第四题，一般而言，CCF的第四题都是图论题。对于我这样之前没怎么刷题的人来说，图论题看上去就感觉很难，主要是感觉到很陌生，因为在实际的开发过程中比较少用到图这样的数据结构，都是线性的数据结构，连树都比较少用。&lt;/p&gt;
&lt;p&gt;但是在刷得比较多的图论题后，发现其实图论题好像也就那么回事，也不是说简单，主要感觉来来去去都是考那几个东西，如果是没有接触过或者不会做的话，可能有点难，但是只要接触过相似的，直接套板子修改就行了（当然也有可能是我还接触的不够多XD），另外，就是感觉没有什么题是DFS/BFS不能破，只是会不会超时，能拿多少的分的问题（对于CCF认证只想拿300分而言，有几十分就够了），其实很多算法的核心也就是DFS与BFS。&lt;/p&gt;
&lt;p&gt;所以在今晚刷完了CCF往年所有的第四题后，总结一下最近接触的图论问题及解法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="图论" scheme="http://scottyeung.club/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
</feed>
