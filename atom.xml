<?xml version="1.0" encoding="utf-8"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>YeungYeah 的乱写地</title><link>https://scottyeung.top/</link><description>YeungYeah 的乱写地中记录了作者的所思所想及所为。</description><generator>Hugo 0.83.1 https://gohugo.io/</generator><language>zh-CN</language><managingEditor>yeungyeah@qq.com (YeungYeah)</managingEditor><webMaster>yeungyeah@qq.com (YeungYeah)</webMaster><lastBuildDate>Sat, 16 Sep 2023 12:57:55 +0000</lastBuildDate><atom:link rel="self" type="application/rss+xml" href="https://scottyeung.top/atom.xml"/><item><title>JVM 当中的剪贴板访问</title><link>https://scottyeung.top/2023/clipboard-access-jvm/</link><guid isPermaLink="true">https://scottyeung.top/2023/clipboard-access-jvm/</guid><pubDate>Sun, 10 Sep 2023 20:00:00 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>起因是想要写一个 kotlin 的脚本，用于读取剪贴板中的内容并保存到文件当中。然而网上搜了一圈，java 和 kotlin 给出的方法都是通过 jdk 中的 awt 包来获取系统剪贴板。因为 kotlin 脚本还是跑的 jvm target，所以方法还是通用的。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-java" data-lang="java">&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.awt.*&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.awt.datatransfer.DataFlavor&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.awt.datatransfer.UnsupportedFlavorException&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">java.io.IOException&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">class&lt;/span> &lt;span class="nc">Test&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kd">static&lt;/span> &lt;span class="kt">void&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="kd">throws&lt;/span> &lt;span class="n">IOException&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">UnsupportedFlavorException&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">var&lt;/span> &lt;span class="n">clipboard&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Toolkit&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getDefaultToolkit&lt;/span>&lt;span class="o">().&lt;/span>&lt;span class="na">getSystemClipboard&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">var&lt;/span> &lt;span class="n">transferable&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">clipboard&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getContents&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kc">null&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">out&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">println&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">transferable&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">getTransferData&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">DataFlavor&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">stringFlavor&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">val&lt;/span> &lt;span class="py">toolkit&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Toolkit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getDefaultToolkit&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">clipboard&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">toolkit&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">systemClipboard&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getData&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">DataFlavor&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">stringFlavor&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">String&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个方法用是能用，而且支持操作的数据类型还挺全，除了文本，还能读写图片。然而有一个缺点，就是使用时必须关掉 headless 选项。kotlin 默认是关掉的，需要显示声明配置 &lt;code>kotlin -Djava.awt.headless=false&lt;/code>来禁用掉。&lt;/p>
&lt;blockquote>
&lt;p>Headless mode is a system configuration in which the display device, keyboard, or mouse is lacking. Sounds unexpected, but actually you can perform different operations in this mode, even with graphic data.&lt;/p>
&lt;/blockquote>
&lt;p>禁用掉 headless 模式后是代码是可用，然而运行起来时会拉起一个 jre 程序，虽然这个拉起的程序没有界面，但是还是会强制跳转切换一次窗口，体感很差。于是只能另寻办法，选择使用 nodejs，最后找到了 (clipboardy)[https://github.com/sindresorhus/clipboardy]，一个简单好用的 npm 库，先实现了我的需求。后来细细看了下它的实现代码，是通过调用命令后的方式来实现访问系统剪贴板。然而调用系统命令的话，各个系统环境的命令都不同，如何兼顾可移植性，在不同的系统环境都能运行呢？解决的办法也很简单粗暴，手动为每个系统都写一个实现，并且针对如果某些系统没有这个操作系统剪贴板的命令程序，还在 npm 包里附带一个二进制作为 fallback。简单，但可用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-javascript" data-lang="javascript">&lt;span class="kr">import&lt;/span> &lt;span class="nx">process&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;node:process&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="nx">isWSL&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;is-wsl&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="nx">termux&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;./lib/termux.js&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="nx">linux&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;./lib/linux.js&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="nx">macos&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;./lib/macos.js&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">import&lt;/span> &lt;span class="nx">windows&lt;/span> &lt;span class="nx">from&lt;/span> &lt;span class="s1">&amp;#39;./lib/windows.js&amp;#39;&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="kr">const&lt;/span> &lt;span class="nx">platformLib&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">(()&lt;/span> &lt;span class="p">=&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">switch&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">process&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">platform&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;darwin&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">macos&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;win32&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">windows&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">case&lt;/span> &lt;span class="s1">&amp;#39;android&amp;#39;&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">process&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">env&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">PREFIX&lt;/span> &lt;span class="o">!==&lt;/span> &lt;span class="s1">&amp;#39;/data/data/com.termux/files/usr&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">throw&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="nb">Error&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;You need to install Termux for this module to work on Android: https://termux.com&amp;#39;&lt;/span>&lt;span class="p">);&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">termux&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="k">default&lt;/span>&lt;span class="o">:&lt;/span>
&lt;span class="c1">// `process.platform === &amp;#39;linux&amp;#39;` for WSL.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">isWSL&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">windows&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">linux&lt;/span>&lt;span class="p">;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">})();&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>于是很自然地借鉴这个思路，用 kotlin 也来实现一版。代码实现可见 &lt;a href="https://github.com/yeung66/clipboard-jvm">clipboard-jvm&lt;/a>，实现的思路也是通过不同的操作系统，调用不同的 shell 命令，访问与操作系统剪贴板。对于执行外部命令&lt;/p>
&lt;p>使用起来也很简单&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">import&lt;/span> &lt;span class="nn">org.yeungyeah.clipboard.Clipboard&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">clipboard&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getClipboard&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原本想把依赖库发布到 maven central 仓库，这样脚本就可以一行直接使用。然而 maven 发布实在是麻烦，研究了几个小时，还是被一些相关的检查卡点了，只能够先 install 到本地，给自己先用。&lt;del>后续上传到 maven central 后再更新，也顺便更新一篇文章如何 deploy to maven central.&lt;/del>&lt;/p>
&lt;p>部署到 maven central 仓库后，就可以通过配置直接导入依赖使用了。比如在 java 项目，通过&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-xml" data-lang="xml">&lt;span class="nt">&amp;lt;dependency&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;groupId&amp;gt;&lt;/span>io.github.yeung66&lt;span class="nt">&amp;lt;/groupId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;artifactId&amp;gt;&lt;/span>clipboard-jvm&lt;span class="nt">&amp;lt;/artifactId&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;version&amp;gt;&lt;/span>1.0.0&lt;span class="nt">&amp;lt;/version&amp;gt;&lt;/span>
&lt;span class="nt">&amp;lt;/dependency&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>或者是在 kotlin script 中，直接&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="nd">@file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">DependsOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;io.github.yeung66:clipboard-jvm:1.0.0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">import&lt;/span> &lt;span class="nn">org.yeungyeah.clipboard.Clipboard&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">clipboard&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">Clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">getClipboard&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">set&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Hello World&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">clipboard&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">get&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>起飞🛫️。不过只是测试了在macOS系统下面的使用，按理说其他系统也是可行的，如果有兴趣的可以试试玩玩。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/Java/">Java</category><category domain="https://scottyeung.top/tags/kotlin/">kotlin</category><category domain="https://scottyeung.top/tags/coding/">coding</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/JavaScript/">JavaScript</category></item><item><title>Scripting in Kotlin</title><link>https://scottyeung.top/2023/Scripting-in-Kotlin/</link><guid isPermaLink="true">https://scottyeung.top/2023/Scripting-in-Kotlin/</guid><pubDate>Wed, 30 Aug 2023 20:01:30 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>最近又重新非常心仪 kotlin，甚至将自己的 rss 时间线聚合都重新用 kotlin 写了一次。kotlin 的各种函数式的写法确实很招我喜欢。因此就想要把它更加应用到自己的生活中，其中 code 在日常生活中最重要的部份，还是写点小脚本解决日常问题，于是就考察了一下使用 kotlin 来写脚本的方式。&lt;/p>
&lt;h2 id="kotlin-官方">kotlin 官方&lt;/h2>
&lt;p>一搜 kotlin scripting，第一个结果就是官方关于 scripting 的 &lt;a href="https://kotlinlang.org/docs/custom-script-deps-tutorial.html">文档&lt;/a>，我也到其提供的代码示例库去研究了一下，它主要提供了三种方式的 kotlin scripting 使用方式。&lt;/p>
&lt;h3 id="jsr223">jsr223&lt;/h3>
&lt;p>java 里面的一个已经实现了的提案，提供了一个可用于运行脚本的 host，通过使用外部依赖，可以使这个 host 支持 kotlin。main.kts 的功能似乎更强，可以导入别的脚本 &lt;code>@file:Import(&amp;quot;import-common.main.kts&amp;quot;)&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">import&lt;/span> &lt;span class="nn">javax.script.ScriptEngineManager&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">engine&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">ScriptEngineManager&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">getEngineByExtension&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;main.kts&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">!!&lt;/span>
&lt;span class="c1">// 或者
&lt;/span>&lt;span class="c1">// val engine = ScriptEngineManager().getEngineByExtension(&amp;#34;kts&amp;#34;)!!
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;gt; &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nd">`in&lt;/span>&lt;span class="err">`&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">reader&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">forEachLine&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">res&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">engine&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">it&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">res&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;&amp;gt; &amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要依赖&lt;/p>
&lt;pre>&lt;code class="language-kts" data-lang="kts">runtimeOnly(&amp;quot;org.jetbrains.kotlin:kotlin-main-kts:$kotlinVersion&amp;quot;) // 可选
runtimeOnly(&amp;quot;org.jetbrains.kotlin:kotlin-scripting-jsr223:$kotlinVersion&amp;quot;)
&lt;/code>&lt;/pre>&lt;p>它的输出是直接打到 System.out 里面，但是也不会直接显示出来，需要截获它的输出，有点诡异&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">fun&lt;/span> &lt;span class="nf">captureOut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">body&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">()&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="n">Unit&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="n">String&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">outStream&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">ByteArrayOutputStream&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">prevOut&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">out&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setOut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">PrintStream&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">outStream&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="k">try&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">body&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">finally&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="k">out&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">flush&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">System&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">setOut&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">prevOut&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">outStream&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toString&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">trim&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="simple-main-kts">simple-main-kts&lt;/h3>
&lt;p>官方提供了 kotlin-scripting-common|jvm|jvm-host 的依赖库（但是在 experimental 中，而且在很久了）。&lt;/p>
&lt;p>这种方式本质也是通过创建一个 jvm 运行时 host 来执行，不过这个可以通过注解的方式，添加许多编译配置，从而获取声明的 maven 依赖。不过这样需要的额外配置还是很多，自定义工作很多。&lt;/p>
&lt;p>一方面通过注解来声明 kotlin script&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="k">import&lt;/span> &lt;span class="nn">kotlin.script.experimental.annotations.KotlinScript&lt;/span>
&lt;span class="c1">// The KotlinScript annotation marks a class that can serve as a reference to the script definition for
&lt;/span>&lt;span class="c1">// `createJvmCompilationConfigurationFromTemplate` call as well as for the discovery mechanism
&lt;/span>&lt;span class="c1">// The marked class also become the base class for defined script type (unless redefined in the configuration)
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="nd">@KotlinScript&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="c1">// file name extension by which this script type is recognized by mechanisms built into scripting compiler plugin
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// and IDE support, it is recommendend to use double extension with the last one being &amp;#34;kts&amp;#34;, so some non-specific
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="c1">// scripting support could be used, e.g. in IDE, if the specific support is not installed.
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">fileExtension&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;simplescript.kts&amp;#34;&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="c1">// the class is used as the script base class, therefore it should be open or abstract
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">abstract&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">SimpleScript&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以通过配置 @KotlinScript 注解来声明脚本的编译配置和执行配置&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span class="nd">@KotlinScript&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="n">fileExtension&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;smain.kts&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1">// the class or object that defines script compilation configuration for this type of scripts
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">compilationConfiguration&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">SimpleMainKtsScriptDefinition&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="c1">// the class or object that defines script evaluation configuration for this type of scripts
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">evaluationConfiguration&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">MainKtsEvaluationConfiguration&lt;/span>&lt;span class="o">::&lt;/span>&lt;span class="k">class&lt;/span>
&lt;span class="err">)&lt;/span>
&lt;span class="c1">// the class is used as the script base class, therefore it should be open or abstract. Also the constructor parameters
&lt;/span>&lt;span class="c1">// of the base class are copied to the script constructor, so with this definition the script will require `args` to be
&lt;/span>&lt;span class="c1">// passed to the constructor, and `args` could be used in the script as a defined variable.
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">abstract&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">SimpleMainKtsScript&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">val&lt;/span> &lt;span class="py">args&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Array&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">String&lt;/span>&lt;span class="p">&amp;gt;)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>根据声明的 script class 来创建运行的 host。host 的创建其实就是通过之前注解声明的 Script class 来创建编译的 configuration，另外根据需要来创建 evaluate 时的 configuration，来编译执行。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin"> &lt;span class="k">val&lt;/span> &lt;span class="py">compilationConfiguration&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">createJvmCompilationConfigurationFromTemplate&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="n">SimpleScript&lt;/span>&lt;span class="p">&amp;gt;&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">jvm&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 声明需要的依赖，用于编译
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="n">dependenciesFromCurrentContext&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="s2">&amp;#34;script&amp;#34;&lt;/span> &lt;span class="cm">/* script library jar name (exact or without a version) */&lt;/span>
&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="n">BasicJvmScriptingHost&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">eval&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">scriptFile&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">toScriptSource&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">compilationConfiguration&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="k">null&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="main-kts">main-kts&lt;/h2>
&lt;p>通过上面的配置，其实就已经可以实现一个简单的 kotlin scripting。只需要再封装一下，添加点功能，比如缓存，就可以变成一个可用的 scripting 工具。实际上 jetbrains 官方将这个封装成来一个 kotlin-main-kts.jar 供运行。&lt;/p>
&lt;p>可以把 kotlin script 命名成&lt;code>*.main.kts&lt;/code>，即可以直接用 kotlin 来运行脚本&lt;/p>
&lt;pre>&lt;code>kotlinc -cp &amp;lt;path/to/kotlin-main-kts.jar&amp;gt; script.main.kts
&lt;/code>&lt;/pre>&lt;p>在 Kotlin version 1.3.70 后，可以直接把这个 jar 都省掉，直接&lt;/p>
&lt;pre>&lt;code>kotlin script.main.kts
&lt;/code>&lt;/pre>&lt;p>或者直接在脚本里面写 shebang&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-kotlin" data-lang="kotlin">
&lt;span class="err">#&lt;/span>&lt;span class="p">!/&lt;/span>&lt;span class="n">usr&lt;/span>&lt;span class="p">/&lt;/span>&lt;span class="n">bin&lt;/span>&lt;span class="p">/&lt;/span>&lt;span class="n">env&lt;/span> &lt;span class="n">kotlin&lt;/span>
&lt;span class="nd">@file&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="n">DependsOn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;org.jetbrains.kotlinx:kotlinx-html-jvm:0.8.0&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">import&lt;/span> &lt;span class="nn">kotlinx.html.*;&lt;/span> &lt;span class="k">import&lt;/span> &lt;span class="nn">kotlinx.html.stream.*;&lt;/span> &lt;span class="k">import&lt;/span> &lt;span class="nn">kotlinx.html.attributes.*&lt;/span>
&lt;span class="k">val&lt;/span> &lt;span class="py">addressee&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="n">args&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">firstOrNull&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="o">?:&lt;/span> &lt;span class="s2">&amp;#34;World&amp;#34;&lt;/span>
&lt;span class="n">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">createHTML&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">html&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">body&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="n">h1&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="p">+&lt;/span>&lt;span class="s2">&amp;#34;Hello, &lt;/span>&lt;span class="si">$addressee&lt;/span>&lt;span class="s2">!&amp;#34;&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">})&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>真爽，看起来就是我想要的方案了。这个 main-kts 的方法，会对脚本进行缓存，第一次运行后，会编译保存到本地 cache 目录，如果内容没有更改，会直接把已编译版本拿来用。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202308302040485.png" alt="">&lt;/p>
&lt;p>而且官方仓库还说 idea 支持 main.kts 脚本的补全提示，看起来就更香了，用起来也还行，补全还是挺香的，尤其是加上 GitHub Copliot，起飞。&lt;/p>
&lt;blockquote>
&lt;p>Starting from the Kotlin IntelliJ plugin version 1.3.70, the .main.kts scripts are supported automatically in the IntelliJ IDEA, provided that they are placed outside of the regular source folders. E.g. if this project is imported into the IntelliJ, the demo scripts in the scripts folders should be properly highlighted and support navigation, including navigation into imported libraries.&lt;/p>
&lt;/blockquote>
&lt;h2 id="第三方支持">第三方支持&lt;/h2>
&lt;p>除了官方提供的 scripting 方法以外，也有一些第三方库因为各种原因，比如之前官方的 scripting 功能还没出的时候，造出一些用 kotlin scripting 写代码的方法&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/kscripting/kscript">kscript&lt;/a> 是 GitHub 一个比较有名的 kotlin 脚本库。
&lt;ul>
&lt;li>可以提供更加丰富功能特性的 kotlin 脚本。比如编译缓存，使用外部依赖，设置运行时参数，从输入或者链接读取脚本内容以及将脚本发布成独立二进制文件。&lt;/li>
&lt;li>不过随着官方发布了正式的 scripting 功能，好像提到的大多功能特性都被覆盖到了。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="">jbang&lt;/a> 是一个使用 jvm 语言写脚本的工具软件。jbang 支持的脚本语言就更多了，java，kotlin 都可以，而且 jbang 感觉是有意做成一个脚本平台广场，还可以将写好的代码发布到其提供的 app store 中，看起来也不错，idea 也可以通过插件提供自动补全对支持。不过其对于 kotlin 的支持好像也不怎么样，前两年刚接触的时候，还帮其修了一个 kotlin 编译的 bug。&lt;/li>
&lt;/ul>
&lt;h2 id="后记">后记&lt;/h2>
&lt;p>写脚本最主要的还是方便，而方便有两方面，一是写要方便，二是跑起来要方便，比如有个小任务，随手打开个 vscode 甚至都不同打开目录，就能有自动补全开写，并在命令行一行命令执行，完成。这样才叫方便。&lt;/p>
&lt;p>这样调研了一轮，看起来用 kotlin 脚本，方便地跑起来现在已经是没有问题了，问题就在于如何方便地写。写个小东西打开 idea 是否方便呢？如果是以前的 Windows，打开一次得等上个几分钟，那可以直接否掉了。但是现在新电脑打开 idea 几乎是秒开，看起来使用 idea 来写脚本好像又变得可以接受了。&lt;/p>
&lt;p>&lt;del>不过最后好像还是用F#来写香😂·&lt;/del>&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/kotlin/">kotlin</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</category></item><item><title>Arc 浏览器使用小记</title><link>https://scottyeung.top/2023/arc-browser/</link><guid isPermaLink="true">https://scottyeung.top/2023/arc-browser/</guid><pubDate>Wed, 02 Aug 2023 20:46:35 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>之前其实一直都有听说过 Arc 这个号称要改变浏览器格局，取代 Chrome 的浏览器，但是一直只有 Macos 版，不支持 Windows 系统，所以也只能一直观望。直到工作之后，拿到了 Mac 的工作电脑，然后自己也提了一台 MacBook，终于有机会可以体验了。于是马上下载下来，设成默认浏览器，体验一番。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/20230802204238.png" alt="">&lt;/p>
&lt;p>下载好打开 Arc 浏览器，给人的第一感觉是好看，它的设计以及动画特效，一看就有种花里胡哨的感觉，据说还得付出性能代价，不过实际使用过程中倒也没有察觉到有什么性能问题。&lt;/p>
&lt;p>实际使用下来，对比于 Chrome 系的浏览器，Arc 主要有下面这些特性&lt;/p>
&lt;ol>
&lt;li>垂直侧边栏。Arc 直接把顶部的标签栏，地址栏，收藏夹等都搬到侧边栏，以换取更大的浏览高度&lt;/li>
&lt;li>不同的标签机制。
&lt;ol>
&lt;li>Arc 没有了收藏夹和书签的概念，取而代之的是可以将页面 Pined 住，或者设成 Fav&lt;/li>
&lt;li>Arc 为了解决开太多标签难以关闭的问题，选择定时会关闭标签，标签打开最多 24 小时就会关闭，默认好像是几个小时。为了防止想看的 tab 被关，必须把它 Pin 住&lt;/li>
&lt;li>同时，针对日常在各种应用打开链接只是看一下的情况，Arc 提供小窗模式供临时打开一些链接，觉得有必要在点击到大窗&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>对于页面分屏良好支持，可以随时在当前页面分出一半打开其他页面。&lt;/li>
&lt;li>使用 Space 来取代多窗口。提供 Space 这个概念来隔离浏览器的使用，不同分组的标签和 Pined 页面可以放到不同的 space 当中使用。相对地，这里比较少用多窗口，甚至打开的新窗口之间会共享已经打开的标签页。&lt;/li>
&lt;/ol>
&lt;p>本质上，Arc 也是用的 Chromium 内核，所以其实 Chrome 支持的插件 Arc 都能支持，实际使用起来感觉也还好。但是我的评价是，Arc 浏览器确实是个有特性的浏览器，然后并不算是一个好用的浏览器，尤其是其中的一些概念，可能喜欢的人会很喜欢，但对我来说，感到束手束脚的。比如&lt;/p>
&lt;ol>
&lt;li>强行为用户做决定，强制关闭标签页。就这一点，意味在工作中需要一直开着许多工作页面的场景根本不能用 Arc。&lt;/li>
&lt;li>很别扭的标签页同步。一方面它希望你能够及时关闭看完的页面，但另一方面又自作主张把你把所有打开的标签页同步到每一个打开的窗口，甚至是电脑打开的标签页给你实时地同步到手机上。感觉其实用起来挺别扭的，尤其是很多时候其实手机电脑浏览的场景都是分开的。&lt;/li>
&lt;li>过分注重美观导致在一些细节上面有很多小问题，不好用，比如靠近右上角自动触发分屏提示，但有时有些按钮在右上角边缘，可能还会导致按不了。&lt;/li>
&lt;li>没有书签的概念后，收藏页面只能用 Pin，但是 Pin 又不能在 Space 上面共享，又变得要绑定于某一个 Space，最终也还是只用一个 Space，失去了 Space 的意义。&lt;/li>
&lt;li>一个浏览器居然强制登录才能使用，而登录居然还有墙的限制，从开始就给使用者加障碍了。&lt;/li>
&lt;li>移动端应用实在太简陋了，甚至没有无痕浏览。&lt;/li>
&lt;/ol>
&lt;p>Arc 作为一个很有特点的浏览器，玩玩可以，真沉浸投入使用，可能还是得忍受种种差异与不适，当然就像臭豆腐一样，总有人能接受，如果能够接受，那它的优点还是很香的。另外，Arc 似乎也有很高的定制性，可以自己定制样式，甚至区块布局，不过我探索的时间（和兴趣）有限，懒得折腾。但是大家有兴趣的话也可以玩一玩，试一试。&lt;/p>
&lt;p>从前在没有 MacBook 的时候，对于 Macos 专享的应用，内心总是有特别的向往，不过真的使用下来，好像又会觉得不过如此，或者仅是还行而已。最近 Macos 上也多了很多新软件，比如 Warp Terminal，Raycast，这些都有在用。可能也是自己还没有深度使用，或者用到它们的精髓，所以感觉也还比较一般。继续慢慢发掘。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E5%90%90%E6%A7%BD/">吐槽</category></item><item><title>表达的力量：写作与情绪宣泄</title><link>https://scottyeung.top/2023/power-of-expression/</link><guid isPermaLink="true">https://scottyeung.top/2023/power-of-expression/</guid><pubDate>Fri, 07 Jul 2023 23:14:39 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>在知乎看看到一个 &lt;a href="https://www.zhihu.com/question/610553893/answer/3105392840">回答&lt;/a>，对此颇为认同。&lt;/p>
&lt;blockquote>
&lt;p>当你意识到自己的表达能力或者自尊水平下降的时候，一定要非常非常小心警惕，这是很危险的征兆。表达真的很重要的，比看起来还要重要。把表达能力一直顶在一个比较高的状态上实际上是一种维持平衡跟自我保护的办法。大家一定要留一个地方来表达，无论表达什么内容都好。&lt;/p>
&lt;p>不要沉默，别怕嘴笨，习惯去表达。表达是另一种意义上的健身。&lt;/p>
&lt;/blockquote>
&lt;p>表达或输出不仅是展示自我的有效工具，更是一种释放情绪的有效方式。一直以来自己都只是集中于表达在前者的作用，着眼于输出的意义和作用。这种情况下，写作大多数是为了知识的积累与沉淀，以及是将这些内容和自己的一些想法和记录分享给大家，好是好，但难免会带点为了外在的功利心。&lt;/p>
&lt;p>同时其实自己也有在 OneNote 上面开启一个带有密码的笔记本来写一点随心的周记记录，虽然因为各种各样的原因搁置过，但是也断断续续地写了几年，也囤了不少的文字。虽然当时写作的心态，是为了记录当时发生过的事情和想法，方便以后重温，但是在通过写作表达内心想法的过程中，其实也无形中释放了许多负面的情绪。尤其当情绪比较郁闷而不想开始工作的时候，甚至可以每天在 OneNote 上面写个几百上千字，哪怕其实没有什么内容，在无病呻吟，但在写的过程和写完之后，心情总是会畅快得很。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202307071741719.png" alt="">&lt;/p>
&lt;p>昨晚在 B 站看到一个 &lt;a href="https://www.bilibili.com/video/BV1dm4y1J7n1">视频&lt;/a>，讲述了一个观点，为什么好人不长命。up 主认为，好人总是为考虑他人，为别人想很多，而这样想太多，就会在内心中积累很多的想法和情绪，但他是好人，他会为他人着想，会顾虑想法表达出来后对他人的影响，于是藏在心中。长久以来，思绪积聚易成气，气郁结则容易演化成结节，影响健康。&lt;/p>
&lt;p>我深表赞同这个 UP 主的观点，也觉得自己有时也会有这样的情况。我也不是说很好人，不过自己会很在意他人的想法，所以很多想法或者情绪都会藏在心中，自己消化，以免影响他人，影响关系，又或是影响自己所谓的“形象”。虽然偶尔也能于好友亲人吐槽，但是总有些时候，是找不到表达倾诉的对象，此时通过写作的方式把想法写下来就很有价值了，哪怕只是写给自己看，甚至自己以后不看，写出来了，就已经足够了。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202307072311304.jpg" alt="">&lt;/p>
&lt;p>然而，就像许多知道有好处的事情一样，写周记和表达自我也常常因为各种原因而难以坚持。尤其是当我习惯于使用电脑键盘敲字后，如果某个时候无法使用电脑，我就会放弃记录，这些积压在心中的想法和感受就会被遗忘，这实在是一种遗憾。如何更方便地使用手机等移动端进行记录和写作，将是后面一个探索的方向。（这篇文章的文字内容就是用手机的 obsidian 写出来的，然后用 vscode 整理具体的博客内容✌️）&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%86%99%E4%BD%9C/">写作</category><category domain="https://scottyeung.top/tags/%E6%9D%82%E8%B0%88/">杂谈</category><category domain="https://scottyeung.top/tags/%E8%BE%93%E5%87%BA/">输出</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/">健康</category><category domain="https://scottyeung.top/tags/%E5%BF%83%E6%80%81/">心态</category></item><item><title>更好的写脚本方式</title><link>https://scottyeung.top/2023/better-script-with-fsharp/</link><guid isPermaLink="true">https://scottyeung.top/2023/better-script-with-fsharp/</guid><pubDate>Fri, 30 Jun 2023 12:00:41 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>毕业季和同学去拍了一些照片，后面共享回来的照片，格式是 HEIC 格式的，在电脑上可以直接打开，但是 iCloud 相册里面上传照片只支持 jpg 格式，哪怕这些照片就是用 iPhone 拍的，也不能直接上传，没有办法，只能够手动转一次照片格式。
网上也有很多 HEIC 转 JPG 格式的工具网站，但是都只能够一张张上传，然后一张张下载，这对于需要处理较大量照片的情况显然并不是一个好的解决方案。于是自然打算写个脚本，进行转换。&lt;/p>
&lt;p>当然现在有了 ChatGPT，写脚本都不用亲历亲为了，直接把问题抛给它，我们只需要做代码的搬运工。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306301213820.png" alt="">&lt;/p>
&lt;p>看起来很不错，复制到本地，替换一下路径一跑，发现脚本并不能正常运行，原因是使用的 Pillow 库其实不支持 HEIC 格式的图片。继续把问题交给它，它又给我推了一个 pyheif 库来处理，然而这个库需要 MSVC 相关工具链来编译安装，在我的电脑安装总是失败，后面尝试了几个它推荐的依赖库，都安装不了，寄！被 Python 的跨平台安装构建的低移植性狠狠教训，而为了写个脚本专门去配个环境或者容器又太夸张了。&lt;/p>
&lt;p>于是使用最近在学的 F#来代替，继续把问题交给 ChatGPT，来回复制粘贴代码运行尝试几次后，顺利完成任务。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-FSharp" data-lang="FSharp">&lt;span class="o">#&lt;/span>&lt;span class="n">r&lt;/span> &lt;span class="s">&amp;#34;nuget:Magick.NET-Q16-AnyCPU&amp;#34;&lt;/span>
&lt;span class="k">open&lt;/span> &lt;span class="nn">System.IO&lt;/span>
&lt;span class="k">open&lt;/span> &lt;span class="nn">ImageMagick&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">convertHEICtoJPG&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">inputPath&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">outputPath&lt;/span>&lt;span class="o">:&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">=&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">image&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">MagickImage&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">inputPath&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">image&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Format&lt;/span> &lt;span class="o">&amp;lt;-&lt;/span> &lt;span class="nn">MagickFormat&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">Jpg&lt;/span>
&lt;span class="n">image&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Write&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">outputPath&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">// 获取当前目录下的所有 HEIC 文件
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">let&lt;/span> &lt;span class="nv">heicFiles&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nn">Directory&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">GetFiles&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="s">@&amp;#34;/path/to/you&amp;#34;&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;*.heic&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="c1">// 遍历每个 HEIC 文件，并进行转换
&lt;/span>&lt;span class="c1">&lt;/span>&lt;span class="k">for&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="k">in&lt;/span> &lt;span class="n">heicFiles&lt;/span> &lt;span class="k">do&lt;/span>
&lt;span class="k">let&lt;/span> &lt;span class="nv">jpgFile&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nn">Path&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ChangeExtension&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">heicFile&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="s">&amp;#34;.jpg&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="n">convertHEICtoJPG&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="n">jpgFile&lt;/span>
&lt;span class="n">printfn&lt;/span> &lt;span class="s">&amp;#34;转换完成：%s -&amp;gt; %s&amp;#34;&lt;/span> &lt;span class="n">heicFile&lt;/span> &lt;span class="n">jpgFile&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对比于 Python，使用 F#来写脚本其实也足够简单和方便，可以单个 fsx 文件来写，也可以直接把写好的代码复制到 fsi 交互命令行里逐段代码执行，方便得很。尤其是对于有外部依赖库的脚本代码，使用 F# 或者 C# 的脚本，这样一行代码引用依赖库，可比在命令行中全局安装一个依赖好用得多。（起码不会有安装失败的问题）&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/Coding-%E8%AE%B0%E5%BD%95/">Coding 记录</category><category domain="https://scottyeung.top/tags/Python/">Python</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</category><category domain="https://scottyeung.top/tags/dotnet/">dotnet</category><category domain="https://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</category></item><item><title>我的动态时间线聚合</title><link>https://scottyeung.top/2023/my-timeline/</link><guid isPermaLink="true">https://scottyeung.top/2023/my-timeline/</guid><pubDate>Sat, 24 Jun 2023 20:30:00 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>之前一段时间偶然发现了 DIYGod 创建的一个个人 &lt;a href="https://t.me/awesomeDIYgod">Channel&lt;/a>，内容是关于他的一些动态，包括其发布的推特内容，以及豆瓣的书影音动态等内容。这种形式的 Channel 对我来说很有意思，一方面也是一个对外界分享自身情况的平台（虽然我的内容也没什么人关注），另一个方面也是可以有个地方将自己的相关信息数据持久化地保存下来，拿到自己手上。于是我也写了点代码，整出了一个自己的时间线聚合 &lt;a href="https://t.me/yeungyeah_channel">YeungYeah's Timeline&lt;/a>。&lt;/p>
&lt;p>程序大体的工作流程是这样的&lt;/p>
&lt;ol>
&lt;li>Vercel 上面部署一个自己的 RSSHub，通过 rss 的方式来订阅相关的个人信息。
&lt;ul>
&lt;li>&lt;a href="https://github.com/DIYgod/RSSHub">RSSHub&lt;/a> 是一个让所有事情都可以 rss 订阅的服务，支持许多网站源，而且 &lt;a href="https://docs.rsshub.app/">文档详细&lt;/a>，基本都可以查得到。&lt;/li>
&lt;li>一些网站的信息生成订阅需要相关的访问权限或者有一些访问次数的限制，比如 YouTube 保存的视频，和 Spotify 点赞的音乐，因此自己搭建最佳，搭建以后根据 &lt;a href="https://docs.rsshub.app/install/#pei-zhi-bu-fen-rss-mo-kuai-pei-zhi">文档&lt;/a> 在环境变量进行配置即可。&lt;/li>
&lt;li>一般地 Vercel 部署后提供的域名在大陆访问都不太方便，需要的话可以绑一个自己的域名。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>运行一个程序定时访问 RSSHub 相关接口，获取 rss 订阅内容并保存&lt;/li>
&lt;li>缓存获取的数据的链接，如果发现新数据，则以一定的格式发送到 Telegram Channel 当中。
&lt;ul>
&lt;li>要往 Telegram Channel 自动发送消息，虽然首先申请一个自己的 Channel，获取 Channel 的 ID&lt;/li>
&lt;li>然后在 &lt;a href="https://t.me/BotFather">@BotFather&lt;/a> 处创建一个自己的 bot，并获取这个 bot 对应的访问 token。&lt;/li>
&lt;li>将 bot 添加为自己 Channel 的管理员，确保 bot 发送的信息可以传给 Channel&lt;/li>
&lt;li>通过官方提供的 API，附带访问 token，调用相应的接口，发送消息&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>程序的工作流程很简单，实现起来也不难。一开始我用 typescript 写了一个版本，使用 sqlite 存储数据，sequelize 作为 ORM 库，node-telegram-bot-api 作为 telegram 接口的封装库，两三天就写完上线。写起来没什么难点，只有在开发过程中一些坑点：&lt;/p>
&lt;ol>
&lt;li>Vercel 部署的 RSSHub 提供的访问域名和 Telegram 的接口，在大陆可能会出现不能访问的问题。在本地开发时，可以走代理，但是因为要 24 小时定期几分钟就跑一次，所以还是得放在服务器上面，服务器就不太方便走代理了，于是我放在了 CloudCone 位于美国的 VPS 上面，可以直连。&lt;/li>
&lt;li>往 Channel 发送消息时不好调试，需要真实往 Channel 发送消息才能看到效果。但有时候调试或者出了点啥问题后，一下子给自己的 Channel 发个几十条信息，还得自己手动删除，幸好也没有其他人关注，只影响到了自己。&lt;/li>
&lt;li>Telegram 接口发送文本消息支持 Markdown 格式信息，但是如果 Markdown 内容解析异常，会直接发送失败，而且因为内容是从 rss 订阅里抽出来的，也难判断哪里会有解析的问题，只能够出一次问题，就修复一次，重新上线一次。&lt;/li>
&lt;/ol>
&lt;p>这也好像是我第一次用 typescript 来开发项目，整体而言还是挺爽的，即使没有学过 ts，凭着 js 的基础和 ide 的帮助，也可以爽写 ts（当然原因可能代码只是写给自己的，很多时候都不太需要复杂的类型标注）。不过刚好当时也在学习 Rust，再加上可以打包成单个可执行文件的诱惑，于是我就使用 Rust 重新实现了一个版本，并编译部署到我的服务器上面。运行起来确实好像要快了点，而且最主要的好处是，内存占用从 ts 版本的 100+M，下降到了 10+M，内存占用只有原来的十分之一，而且开发效率也还不错。&lt;/p>
&lt;p>虽然写起来没什么问题，但是在打包发布上面，Rust 还是有很多槽点的。虽然 Rust 支持多个系统平台，但是很多的 crate 在系统的兼容性上都存在一定的问题，尤其是传递依赖，导致打包出来的产物还会动态依赖系统的库，或者 crate 的编译需要系统工具链的支持。我是在 Windows 上面开发调试，完成后编译一个 linux 版本的 release 一样，传到服务器上面运行。听起来很简单，但是实际上跨平台编译会出现各种问题，一些传递引入的 crate 在编译时需要 gnu 的工具链和一些在 Windows 没有的链接库，而其中的一些 crate 明确就是不支持 Windows 系统的，在解决了一个 crate 的编译问题后，又来一个，完全没有办法，只能够在 Windows Subsystem for Linux (WSL) 上面的 Ubuntu 来编译。&lt;/p>
&lt;p>然而使用 WSL 也没有那么简单，代码放在 WSL 能够正常编译得到二进制产物，传到服务器上面就不能运行，提示找不到某个版本 libssl.so 的链接库。一检查发现是因为我 WSL 上的 Ubuntu 是 18.04，而服务器在跑的已经是 22.04 的，两者通过 apt 安装的 ssl 库版本不一致，导致 WSL 编译出来的产物没有办法在服务器运行。也尝试过使用基于容器的方式来进行编译，比如 &lt;a href="https://github.com/cross-rs/cross">cross-rs&lt;/a>，但在编译的过程中还是会出现各种的问题导致编译不成功。&lt;/p>
&lt;p>于是只能够根据依赖进行进一步的具体排查，找到跟这个动态 so 库相关的依赖，发现许多需要和使用到网络连接的依赖库，都可能间接或直接依赖于 &lt;a href="https://github.com/sfackler/rust-native-tls">rust-native-tls&lt;/a>，这个库会根据系统自动选择相应的 TLS 实现 crate，来调用系统的 SSL bindings，比如在 Linux 上就会调用系统的 &lt;a href="https://docs.rs/openssl/latest/openssl/">openssl&lt;/a> 这个依赖库，包括常用的 http 请求库 reqwest，支持连接远程数据库的 orm 库 sea-orm，以及 telegram api 的封装库。这种通过 binding 方式依赖于具体的某个系统环境和依赖库，就使得构建过程和程序运行的可移植性大大降低。于是考虑使用 Rust 版本实现的 tls 依赖库 &lt;a href="https://github.com/rustls/rustls">rustls&lt;/a> 来全部替代掉。比较好的一点是，很多人都在 native-tls 的跨平台编译上面踩过不少坑，于是上面提到的这些库都提供了相关的 feature 配置选项，供用户使用 rustls 替换掉 native-tls，具体的设置方式可以到依赖库自身的文档和提供的 feature 查询。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="p">[&lt;/span>&lt;span class="nx">dependencies&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">reqwest&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.11.16&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">default&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;rustls-tls&amp;#34;&lt;/span>&lt;span class="p">]}&lt;/span>
&lt;span class="nx">teloxide&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.12&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">default&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;macros&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;rustls&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">}&lt;/span>
&lt;span class="nx">sea&lt;/span>&lt;span class="err">-&lt;/span>&lt;span class="nx">orm&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="nx">version&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;0.11.2&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">features&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">[&lt;/span> &lt;span class="s2">&amp;#34;sqlx-sqlite&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;runtime-tokio-rustls&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;macros&amp;#34;&lt;/span> &lt;span class="p">]&lt;/span> &lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后 Rust 版本的程序通过 WSL 成功编译，并能够在服务器上面运行，运行的性能和资源占用也挺不错。但是实际上，我也并不缺这一点性能，跑得快一点意义不大，服务器的内存其实也暂时充足。而程序其实上线后也常常会出现一些意料之外的小问题，或者是需要添加一些新的订阅资源，这些都需要快速迭代，快速修改，因此使用 Rust 每次修改重新编译发布，可能都要比修改代码的时间长了。于是只能又用回 ts 版本。&lt;/p>
&lt;p>PS：另外偶然发现，Rust 开发过程中生成的中间产物，居然这么吃硬盘空间， &lt;del>又劝退多一点了&lt;/del>&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306242025064.png" alt="">&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</category><category domain="https://scottyeung.top/tags/Vercel/">Vercel</category><category domain="https://scottyeung.top/tags/JavaScript/">JavaScript</category><category domain="https://scottyeung.top/tags/Rust/">Rust</category><category domain="https://scottyeung.top/tags/Coding-%E8%AE%B0%E5%BD%95/">Coding 记录</category><category domain="https://scottyeung.top/tags/rss/">rss</category></item><item><title>Umami: 更简单的自托管网站统计服务</title><link>https://scottyeung.top/2023/umami/</link><guid isPermaLink="true">https://scottyeung.top/2023/umami/</guid><pubDate>Wed, 14 Jun 2023 10:41:12 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>此前博客都是用 Google Analytics 来提供网站统计服务，统计博客中各个页面的访问情况。可用是可用，但是 Google Analytics 提供了太多的统计内容，让人眼花缭乱，都不知道要看些什么。另外 Google 的服务，总是会存在访问性的问题。因此在看到介绍其它博主介绍 &lt;a href="https://github.com/umami-software/umami">Umami&lt;/a> 的文章后，我也打算搭建一个自己的网站统计服务，并进行切换。&lt;/p>
&lt;blockquote>
&lt;p>Umami is a simple, fast, privacy-focused alternative to Google Analytics.&lt;/p>
&lt;/blockquote>
&lt;p>Umami 主打的就是注重隐私，毕竟像访问数据这些数据，还是不落在大公司手上好点。Umami 支持多种部署方式，比如 Docker。不过对于我这种云计算爱好者来说，当然是都上云服务了。Umami 服务本身可以部署在 Vercel 上面，绑定一个域名就可以直接访问了。Umami 支持 MySQL 和 Postgresql 两种数据库，这两种数据库都可以找到对应的 serverless 提供商。这里我选择的是 PingCap 家的 &lt;a href="https://www.pingcap.com/tidb-cloud/">TiDB Cloud&lt;/a>，能够提供每个集群最大 5G 容量，每月 5 千万次访问的 MySQL 数据库。&lt;/p>
&lt;p>最终部署的成果如下。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202306141051580.png" alt="">&lt;/p>
&lt;h2 id="搭建过程">搭建过程&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>TiDB Cloud 登录后，创建一个 Serverless 的数据库 cluster&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在集群的 overview 页面，点击 connect 获取建立数据库链接的相关内容，以 MySQL CLI 的连接方式为例，包括&lt;/p>
&lt;ul>
&lt;li>用户名 -u&lt;/li>
&lt;li>host -h&lt;/li>
&lt;li>端口 -P&lt;/li>
&lt;li>密码 -p&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>根据获取得到的相关信息，拼接出 MySQL 的连接 URL&lt;/p>
&lt;ul>
&lt;li>&lt;code>mysql://&amp;lt;username&amp;gt;:&amp;lt;password&amp;gt;@&amp;lt;host&amp;gt;:&amp;lt;port&amp;gt;/&amp;lt;database_name&amp;gt;?pool_timeout=60&amp;amp;sslaccept=accept_invalid_certs&lt;/code>&lt;/li>
&lt;li>需要预先创建一个数据库并指定数据库&lt;/li>
&lt;li>因为 TiDB Cloud 默认是需要 TLS 的，因此必须添加参数 &lt;code>sslaccept=accept_invalid_certs&lt;/code>，否则会连不上（这是一个隐藏的小坑）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>GitHub Fork Umami 项目，并到 Vercel 部署，部署时填入环境变量 &lt;code>DATABASE_URL&lt;/code>，值是上面的连接 URL&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署后在 Vercel 绑定自己的域名，因为 DNS 污染的原因，Vercel 提供的域名大多数时候不能够正常访问，需要自己的域名，才能更顺利地被访问到&lt;/p>
&lt;/li>
&lt;li>
&lt;p>部署成功后，通过绑定的域名访问网站，默认账号用户名和密码是 admmin 和 umami，进去后可以修改密码，添加网站，添加用户&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在设置页面处添加网站，填写相关信息，Umami 会为需要统计的网站分配一个 ID 以及影响的 tracking code。只需要把这个 tracking code 放到网页的 head 标签中，即可以开始收集统计数据，并在 dashboard 中看到相应的统计结果。&lt;/p>
&lt;ol>
&lt;li>以我使用的 hugo 为例，在主题的 html 模板当中找到 head 标签相关的生成模板，然后把 tracking code 放进去就行了。为了增加可配置性，也可以把 tracking code 中的 id 抽取出来变成变量，从配置中读取。&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-html" data-lang="html"> {{- if and .Site.Params.enableUmami (eq hugo.Environment &amp;#34;production&amp;#34;) }}
{{ $id := .Site.Params.umamiTrackingID }}
{{ $host := .Site.Params.umamiHost }}
&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nt">script&lt;/span> &lt;span class="na">async&lt;/span> &lt;span class="na">src&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;https://{{ $host }}/script.js&amp;#34;&lt;/span> &lt;span class="na">data-website-id&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s">&amp;#34;{{ $id }}&amp;#34;&lt;/span>&lt;span class="p">&amp;gt;&amp;lt;/&lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">&amp;gt;&lt;/span>
{{- end }}
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-toml" data-lang="toml">&lt;span class="nx">enableUmami&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span>
&lt;span class="nx">umamiTrackingID&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;your_id&amp;#34;&lt;/span>
&lt;span class="nx">umamiHost&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="s2">&amp;#34;your_umami_website&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/serverless/">serverless</category><category domain="https://scottyeung.top/tags/Vercel/">Vercel</category><category domain="https://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1/">云服务</category></item><item><title>系统工具替换之 Rust 化推进</title><link>https://scottyeung.top/2023/replace-with-tools-based-rust/</link><guid isPermaLink="true">https://scottyeung.top/2023/replace-with-tools-based-rust/</guid><pubDate>Mon, 24 Apr 2023 10:51:42 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>起因是在知乎看到了这篇 &lt;a href="https://zhuanlan.zhihu.com/p/436024560">文章&lt;/a>，讲到作者使用 Rust 新开发的终端工具生态，以构建一个能在不同设备环境下运行的终端配置。里面提到的 Starship 自己就已经在用，确实不错，而且自己确实对于 Rust 有不少的好感。于是就按照他的思路，将日常使用的一些工具，迁移到使用 Rust 实现的版本当中，体验还是挺不错的。&lt;/p>
&lt;p>具体做了以下的替换。&lt;/p>
&lt;h2 id="starship-cross-shell-prompt">Starship: Cross-Shell Prompt&lt;/h2>
&lt;p>此前在新环境开启一个 shell 之后，总是会第一时间就对 shell 进行配置，以获取更好的终端使用体验。比如在 zsh 当中使用 &lt;a href="https://ohmyz.sh/">oh-my-zsh&lt;/a>。不过这些 prompt 配置往往会因为其对于特定 shell 的移植性，以及实际使用起来的性能响应问题，而让人劝退。&lt;/p>
&lt;p>&lt;a href="https://starship.rs/">Starship&lt;/a> 是一个使用 Rust 实现的适用于任何 shell 的 prompt。实际使用起来，看起来足够美观，性能也不错，而且安装配置也方便，几乎是开箱即用。于是在很早就为我的 powershell 切换到 Starship 了。&lt;/p>
&lt;p>基本各个包管理工具都有 Starship，在 Windows 下可以使用 scoop 安装。安装好后根据相应使用的 shell 进行配置即可。&lt;/p>
&lt;h2 id="nushell">Nushell&lt;/h2>
&lt;p>&lt;a href="https://www.nushell.sh/">Nushell&lt;/a> 是使用 Rust 实现的一种新型的 shell，得益于使用 Rust 实现，Nushell 可以运行于各个 OS 平台，即使是在 Windows 上面也有着很不错的体验。这对于一个在 Windows 上面一直没有良好终端交互体验的人来说（powershell 不能根据历史记录进行补全，补全提示也很弱，不能看到所有的候选项，只能一个个 tab 切换过去尝试，简直窒息），简直是质的的飞跃。这段时间使用下来，主要有以下的爽点。&lt;/p>
&lt;ul>
&lt;li>全平台提供统一的命令和功能，使得使用起来非常统一。而且提供的命令足够丰富，完全可以涵盖日常使用。&lt;/li>
&lt;li>良好的命令补全功能。某种程度这种补全能力才是最吸引我的哈哈哈。&lt;/li>
&lt;li>一切皆数据。所有命令得到的数据，可以通过管道流动，进行数据处理加工，从而得到想要的结果和效果。
&lt;ul>
&lt;li>很多命令的输出结果都是以表格的形式返回，方便进行数据处理&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>足够美观。命令的输入和结果的输出，都有不错的格式化，看起来体验不错。&lt;/li>
&lt;/ul>
&lt;p>除了提供足够好用的 shell 以外，Nushell 使用语法也不错，可以很简单地进行 shell 变成，写脚本实现自己想要的功能，比如看视频常用的，获取当前目录下最近访问的视频文件。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-shell" data-lang="shell">ls -l &lt;span class="p">|&lt;/span> where &lt;span class="nb">type&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s2">&amp;#34;file&amp;#34;&lt;/span> and &lt;span class="nv">name&lt;/span> &lt;span class="o">=&lt;/span>~ &lt;span class="s2">&amp;#34;.(rmvb|mp4|mkv)&lt;/span>$&lt;span class="s2">&amp;#34;&lt;/span> &lt;span class="p">|&lt;/span> sort-by accessed &lt;span class="p">|&lt;/span> reverse &lt;span class="p">|&lt;/span> first &lt;span class="m">1&lt;/span> &lt;span class="p">|&lt;/span> get name
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同时 Nushell 也为来自使用不同 shell 的用户提供了 mapping 指南。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.nushell.sh/book/coming_from_bash.html">Coming from Bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.nushell.sh/book/coming_from_cmd.html">Coming from CMD&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>真心安利大家试试！&lt;/p>
&lt;h2 id="bat-alternative-to-cat">Bat: alternative to cat&lt;/h2>
&lt;p>Linux cat 的命令用于输出文本文件的内容，几乎是 Linux 上最常用的命令之一了。&lt;a href="https://github.com/sharkdp/bat/">Bat&lt;/a> 则是带有自动格式化和语法高亮的 cat 命令。而且 Windows powershell 当中居然不提供 cat 的命令或者 alias，让人不适应。Bat 还有许多的功能，比如与 git 集成，以及自动分页。&lt;/p>
&lt;p>Bat 已经用很久了，它已经存在于我的每个设备上面，大量使用，已经替换掉我的 cat 了。&lt;/p>
&lt;h2 id="fd-alternative-to-find">fd: alternative to find&lt;/h2>
&lt;p>&lt;a href="https://github.com/sharkdp/fd">fd&lt;/a> 是使用 rust 实现的简单快捷的 find 命令代替版。实际使用的性能表现挺不错的，而且输出就自带颜色格式化，结果看起来也很美观。不过 fd 的出现，最主要是可以让我在 Windows 下面也可以用到 find，快速地找到文件。在终端使用 fd 命令，几乎可以当成一个命令行版本的 everything，来搜索文件。&lt;/p>
&lt;h2 id="zoxide">zoxide&lt;/h2>
&lt;p>&lt;a href="https://github.com/ajeetdsouza/zoxide">zoxide&lt;/a> 是使用 Rust 实现的目录切换工具，是一个更加智能的 cd 命令。类似于 autojump，zoxide 可以记录历史访问切换路径，然后根据历史数据，快速跳转到目标路径。比如通过多次 cd 进入了一个深层级的目录后，后面就可以直接根据目录名一步跳转到目标目录。得益于 Rust 的跨平台能力，zoxide 适用于多种不同的 shell，而且性能表现还不错。&lt;/p>
&lt;p>现在正在逐步使用 z 替换掉习惯中的 cd。&lt;/p>
&lt;h2 id="helix-alternative-to-vim">Helix: alternative to vim&lt;/h2>
&lt;p>&lt;a href="https://github.com/helix-editor/helix">Helix&lt;/a> 是一个使用 vim 键位的终端编辑器，其自带有比较完备的配置设置，基本可以开箱即用，而且一些操作也更加简单，其内置了较多的提示和选项菜单，使用体验比 vim 要好很多，尤其是在大家都没配置的情况下。对于我这种懒折腾的人来说简直完美。&lt;/p>
&lt;p>现在在服务器上也基本用 helix 来代替 vim 了，几乎没有什么学习成本。&lt;/p>
&lt;h2 id="zellij-alternative-to-tmux">zellij: alternative to tmux&lt;/h2>
&lt;p>&lt;a href="https://github.com/zellij-org/zellij">zellij&lt;/a> 是一款类似于 tmux 的终端复用工具。不过相比于 tmux，zellij 使用起来更加简单（因为几乎所有的操作命令都可以在窗口的指示中了解到），不需要再像用 tmux，如果一段时间没用，还得现搜一些快捷键，看怎么退出会话，怎么切换 tabs。使用体验还是不错的。&lt;/p>
&lt;hr>
&lt;p>Rust 语言的发展，带来了大量工具软件的蓬勃发展。虽然有些人会觉得 Rust 开发者是不是闲得没事，总是喜欢造轮子，总是喜欢把已有的东西重新实现一遍。但我觉得这样的发展趋势还是很棒的，这也并不是简单地重复造轮子，除了 Rust 带来的性能提升以外，我觉得最主要的卖点，还是 Rust 跨平台特性，所带来的软件工具的移植性。因为 Rust 跨平台，所以可以为各个 OS 和架构都直接打出一个可用的二进制包，借助各类型的包管理工具，下载安装的体验极佳，即使是 Windows。退一步，即使包管理源还没有相应的工具，还能够通过 cargo 进行源码安装（就是花的的时间多一点，不过可以考虑使用 &lt;a href="https://github.com/cargo-bins/cargo-binstall">cargo binstall&lt;/a> 提速一下）。&lt;/p>
&lt;p>感谢 Rust，让我有机会能够在 Windows 平台下体验到许多原本只能在 Linux 系统才能够体验到的命令行工具，还能够有非常不错的体验，值得向大家推荐。&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category><category domain="https://scottyeung.top/tags/Windows/">Windows</category><category domain="https://scottyeung.top/tags/Linux/">Linux</category><category domain="https://scottyeung.top/tags/shell/">shell</category><category domain="https://scottyeung.top/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/">生产力</category><category domain="https://scottyeung.top/tags/Rust/">Rust</category></item><item><title>Hugo 如何转义美元符号 $</title><link>https://scottyeung.top/2023/hugo-escape-dollar-sigh/</link><guid isPermaLink="true">https://scottyeung.top/2023/hugo-escape-dollar-sigh/</guid><pubDate>Thu, 13 Apr 2023 10:42:26 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>写上一篇博客的时候出现了一些美元符号 $，因为平时比较少用，所以发布后才发现这是个特殊字符，显示效果会有点问题，需要进行转义。不转义的话，可能就会当成行内公式来处理，显得很奇怪。&lt;/p>
&lt;p>&lt;img src="https://scottyeung.top/my-images/202304131045363.png" alt="">&lt;/p>
&lt;p>反应过来后很快就给这些 $ 符号添加上反斜杠 \ 来转义了，即使用&lt;code>1\$&lt;/code>的形式。因为文章还同时发布在 &lt;a href="https://blog.yeungyeah.top/">xLog&lt;/a> 的平台上面，所以修改后就直接在上面看效果，看起来没事，就重新发布了。&lt;/p>
&lt;p>然后今天发现主页上 hugo 的版本还是显示不正常，在本地跑了一下才发现，这样加一个反斜杠转义并没有转义效果。搜了一轮才意识到，应该是我的 Hugo 全局开了 MathJax 的问题。在开启 MathJax 的情况下，文章 markdown 会出现处理一轮，先做一轮转义，比如 &lt;code>\$&lt;/code> 会转义成 &lt;code>$&lt;/code>，然后再用 MathJax 扫描，如果这时还发现 $ 符号，自然就会当成公式再处理一遍，导致不能正常显示出 $。&lt;/p>
&lt;p>所以解决办法是，要么关掉 Hugo 的全局 MathJax，要么给反转义符再加一层转义，像下面一样。这两者都可以解决问题，使得文章正常显示 $。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-markdown" data-lang="markdown">花了 1\\\$ 手续费
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>最终为了方便在两个平台同时发布，还是选择了关掉了全局的 MathJax，然后再为出现了数学公式的文章添加 Front Matter&lt;/p>
&lt;p>mathjax: true&lt;/p>
&lt;/blockquote></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/Hugo/">Hugo</category><category domain="https://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/">博客</category></item><item><title>使用 Depay 绑定 OpenAI</title><link>https://scottyeung.top/2023/depay-and-openai/</link><guid isPermaLink="true">https://scottyeung.top/2023/depay-and-openai/</guid><pubDate>Tue, 11 Apr 2023 12:02:17 +0800</pubDate><author>yeungyeah@qq.com (YeungYeah)</author><description>&lt;p>之前一直苦于没有外币信用卡，外面的很多服务都没有办法体验。然后刚好 4.1 号后 OpenAI 送的 credit 到期了，继续使用 ChatGPT 的 API 就需要绑定信用卡，才能够继续使用。没有办法，只能寻找办法办一张可以支付的卡。刚好看到土木坛子关于 &lt;a href="https://tumutanzi.com/archives/16984">depay 信用卡的介绍&lt;/a>，看起来还行，有支付的渠道，而且能用于 OpenAI 的付费，就搞了一张。&lt;/p>
&lt;h2 id="depay">Depay&lt;/h2>
&lt;p>Depay 支持申请 Master 卡，是一种预付型的信用卡。可以简单地理解成需要预先充值才能使用的银行卡。Depay 办卡本身还是挺容易的，麻烦在于后面的充值。&lt;/p>
&lt;h3 id="办卡">办卡&lt;/h3>
&lt;ol>
&lt;li>在 &lt;a href="https://depay.depay.one/web-app/register-h5?invitCode=737033&amp;amp;lang=zh-cn">Depay 网站&lt;/a> 或者 APP 上注册账号
&lt;ul>
&lt;li>可以用我的邀请码进行注册 737033
&lt;ul>
&lt;li>&lt;img src="https://scottyeung.top/my-images/202304111229402.jpg" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如果是 IOS 用户的话，需要切换到美区才能够找到 Depay 的 app，国区的 Depay 测试已满，已经加不进去了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>在 APP 进行身份认证，然后录制一段小视频完成 KYC/AML 反洗钱程序，等待通过&lt;/li>
&lt;li>通过后就可以申请卡，有不同的卡片等级可以选择，不同等级有着不同的开卡费，月费，充值手续费的区别。个人感觉选个最低级别的其实就够了，后续用得多了还可以再升级。
&lt;ul>
&lt;li>&lt;img src="https://scottyeung.top/my-images/202304111225681.png" alt="">&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>开了卡之后需要充值 5$ 还是 10$ 以上才能激活，获得卡号&lt;/li>
&lt;/ol>
&lt;h3 id="充值">充值&lt;/h3>
&lt;p>作为一张预付型的卡，Depay 需要先充值才能够再使用。Depay 主要是通过数字货币 USDT 来进行充值，只需要把 USDT 转到他们指定的账号上，然后就能够将其兑换成美元使用。当然 USDT 的获取在这里也不是那么容易，这里选择的是在 &lt;a href="https://www.cnouyi.care/">欧易交易所&lt;/a> 进行交易。&lt;/p>
&lt;ol>
&lt;li>首先在欧易注册个账号，并通过认证。&lt;/li>
&lt;li>然后通过快捷买币的方式获取 USDT，支付方式支持使用支付宝。这里购买的 USDT 并不能马上提现，需要等 24 小时才能提现出去。&lt;/li>
&lt;li>在 Depay 获取充值的地址，注意选择一致的网络，比如我选择的是 TRC20
&lt;ol>
&lt;li>充值是有最小金额限制的，一般需要大于 5USDT，&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>提现后大概等十来分钟 USDT 就能入账到 Depay&lt;/li>
&lt;li>将 Depay 当中入账的 USDT 转换成 USD，就可以充值到申请的卡当中，充值完成后就可以获取到卡号等相关信息，算是激活成功了&lt;/li>
&lt;/ol>
&lt;p>在充值过程中，从欧易提现 USDT 花了 1$ 手续费，然后充值到 Depay 当中又收了 1.35% 的手续费（这个还有个最小 1$ 的限制），最后 USDT 转成美元又有损耗（1USDT 约等于 0.99USD）。这样一轮转换下来，我原本是买了 50USDT，最终搞定转入卡中的 USD 只有 47.5$ 左右，过程大概花了 2.5$ 的手续费。总的来说手续费还是有点点高的，因此最好充值的时候考虑一次性充值足够的钱，当然也不要太多，&lt;del>Depay 跑路就麻烦了&lt;/del>，看手续费来衡量吧。&lt;/p>
&lt;h2 id="openai-绑定">OpenAI 绑定&lt;/h2>
&lt;p>有了卡之后就可以去 OpenAI 处添加消费方法，绑卡。绑卡主要填写的内容是卡号，安全码，以及账单地址。卡的信息可以在 Depay 的 app 上面找到，地址信息可以到一些地址生成网站获取，如 &lt;a href="https://www.haoweichi.com/Index/custom_result">haoweichi&lt;/a>。&lt;/p>
&lt;p>然而 OpenAI 的风控非常的诡异，除了限制国内许多的信用卡外，很多时候还会因 IP 而不让绑卡。网上的说法五花八门，比如让开全局代理，开无痕模式，甚至还说要梯子的 IP 要跟填写的地址一致的。根据亲身体验，其实并不一定要使用美国的 IP，而且 IP 和填写的地址也不一定需要一致。相反地，感觉非美国的其它区域的 IP 地址可能回因为冷门点反而更好通过。最后我是使用了一个日本还是新加坡的节点，在第四次的时候成功绑定。&lt;/p>
&lt;p>在绑定 OpenAI 之后，卡会扣 5$ 的授权额度，然后应该是根据每个月使用的情况进行扣费，到时候还得看能不能顺利扣费成功🤣&lt;/p></description><category domain="https://scottyeung.top/posts/">posts</category><category domain="https://scottyeung.top/tags/AI/">AI</category><category domain="https://scottyeung.top/tags/%E8%AE%B0%E5%BD%95/">记录</category><category domain="https://scottyeung.top/tags/%E6%94%AF%E4%BB%98/">支付</category><category domain="https://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/">工具</category></item></channel></rss>