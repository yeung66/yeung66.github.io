<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeungYeah 的乱写地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.club/"/>
  <updated>2020-02-29T04:19:23.985Z</updated>
  <id>http://scottyeung.club/</id>
  
  <author>
    <name>Scott Yeung</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>记一次漫画批量的爬取/下载</title>
    <link href="http://scottyeung.club/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/"/>
    <id>http://scottyeung.club/2020/记一次漫画批量的爬取-下载/</id>
    <published>2020-02-28T14:01:33.000Z</published>
    <updated>2020-02-29T04:19:23.985Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。</p><a id="more"></a><h1 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>漫画下载无非就是图片的抓取下载，也算是一种比较简单的爬虫。分析选为抓取来源的网页的URL，发现其URL规律为<code>host/type/漫画的ID+漫画章节号+第几页</code>，可以按照该规律生成所有漫画每一页的URL，则可以根据每一个URL获取里面的漫画图片下载。进一步分析这些页面上漫画图片的URL，发现是跳转到一个ASP页面进行提供，链接为三级ID组成，包括漫画ID，章节号，页码组成。在浏览器直接访问图片的URL，发现会跳转到404页面。根据开发者调试工具的Network栏中拦截的请求，发现图片实则来自另一个URL，并且图片URL的规律十分明显。于是问题就转变成根据规律批量生成图片的URL并下载。</p><h1 id="具体实现：Python"><a href="#具体实现：Python" class="headerlink" title="具体实现：Python"></a>具体实现：Python</h1><p>为了简单，就没有使用任何的轮子。直接使用requests库访问这些URL获取图片资源，并写入到本地文件中保存。</p><h2 id="v1"><a href="#v1" class="headerlink" title="v1"></a>v1</h2><p>具体的实现思路大概如下。对于漫画的每一话，先创建目录，然后根据该话的序号和页面生成目标资源URL，发送GET请求获取资源，通过文件写入保存到本地，直到访问的URL不存在漫画图片，跳转到404页面，此处我们通过判断响应首部的内容长度是否等于404图片的大小来判断该话是否结束爬取。根据漫画的总数，对每一话进行下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">'https://www.xxxxxx.com/1234/1234/&#123;0:0&gt;3d&#125;/&#123;1:0&gt;3d&#125;.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getChapter</span><span class="params">(no)</span>:</span></span><br><span class="line">    <span class="string">'''获取并保存第no话的漫画'''</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    os.mkdir(saveDir + str(no))</span><br><span class="line">    req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    print(req.status_code, req.headers)</span><br><span class="line">    <span class="keyword">while</span> req.status_code == <span class="number">200</span> <span class="keyword">and</span> req.headers[<span class="string">'Content-Length'</span>] != size404:</span><br><span class="line">        <span class="keyword">with</span> open(saveDir + str(no) + <span class="string">'/'</span> + str(cnt)+<span class="string">'.jpg'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(req.content)           </span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    <span class="keyword">return</span> cnt - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p>实在是太慢了！</p><p>尝试着下了一话大概花费半到一分多钟左右，这里总共有一百多话，两个多小时肯定是走不掉了，而且还没考虑网络不稳定的因素。考虑了一下其中效率的制约因素，最主要为：</p><ul><li>网络请求。发请求获取资源需要传输时间。</li><li>IO。图片保存到本地需要写入时间。</li></ul><h2 id="v2"><a href="#v2" class="headerlink" title="v2"></a>v2</h2><p>考虑使用多线程进行并行下载，进而提高速度。虽说Python提供的多线程只是伪多线程，实际上还是只能有一个线程被核心处理，但应该还是可以减少其中的等待时间。采用threading.Thread对象，将下载任务分成若干个patch交由不同的线程完成，每个线程完成20话的下载任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPatch</span><span class="params">(start,size,max_chapter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,min(size,max_chapter)+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'save chapter &#123;:0&gt;3d&#125; page &#123;:0&gt;3d&#125;'</span>.format(i,getChapter(i)))</span><br><span class="line"></span><br><span class="line">patch = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    t = threading.Thread(target=getPatch,kwargs=&#123;<span class="string">'start'</span>:i*patch+<span class="number">1</span>,<span class="string">'size'</span>:patch,<span class="string">'max_chapter'</span>:<span class="number">136</span>&#125;)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="效果-1"><a href="#效果-1" class="headerlink" title="效果"></a>效果</h3><p>并没有提升多少速度。感觉这个多线程并没提高多少并行程度，我开了7个线程，但是最开始只创建了4文件夹进行下载，在这4话中进行调度交替下载。也不知道花了多少时间，下完这4话之后，我就强制关掉了，弃掉该方案。</p><h1 id="具体实现：Goland"><a href="#具体实现：Goland" class="headerlink" title="具体实现：Goland"></a>具体实现：Goland</h1><p>说到多线程，最方便的肯定就是Go语言了，直接的关键字支持多线程。于是拾起很久没碰过的Goland，甚至新电脑上还没安装环境，还需要重新安装Go语言，配置环境和开发工具，就下Vscode的插件都花了点功夫。</p><p>实现思路还是同Python版本一样，为了简单不使用任何额外的轮子，直接使用net/http包进行http访问，获取图片，并写入到本地文件。</p><h2 id="v3"><a href="#v3" class="headerlink" title="v3"></a>v3</h2><p>具体的单话下载代码如下。方法跟Python版本的几乎一样，不过Go语言做了额外的错误处理，显得有点冗余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downChapter</span><span class="params">(no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">page := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ;; page++ &#123;</span><br><span class="line">_, err := os.Stat(fmt.Sprintf(saveDir, no))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(saveDir, no))</span><br><span class="line">os.Mkdir(fmt.Sprintf(saveDir, no), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line">res, err := http.Get(fmt.Sprintf(baseUrl, no, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.Header.Get(<span class="string">"Content-Length"</span>) == size404&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Create(fmt.Sprintf(saveDir, no) + fmt.Sprintf(postfix, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">io.Copy(file, res.Body)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down chapter %3d with %3d pages\n"</span>,no,page)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Go语言最主要就是要用它的多线程特性。在Go中只需要在调用函数前加上关键字Go就可以开启新的多线程调用函数。将下载任务分成20个为一批的多个patch，开启了7个线程进行下载。此处使用WaitGroup进行多线程的等待，避免主线程提前结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downPatch</span><span class="params">(start, patch, maxChapter <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> no:=start;no&lt;=start+patch &amp;&amp; no&lt;=maxChapter;no++&#123;</span><br><span class="line">downChapter(no)</span><br><span class="line">cnt++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down patch from %3d to %3d total %d"</span>,start,start+cnt<span class="number">-1</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;maxChapter/patch;i++&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> downPatch(i * patch,patch,maxChapter)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果-2"><a href="#效果-2" class="headerlink" title="效果"></a>效果</h3><p>速度确实提升了，但是感觉没有到很快的程度。。。</p><p>直到写文章的此刻，跑了两个半小时，下了大概86话。打开任务管理器看了看情况，CPU占用率一直很低，磁盘读写占用也很低，感觉瓶颈就在网络传输上面。另外，觉得7个线程也开得有点少了，应该多开一点，榨干电脑的性能，而且开多了也不会有很大的浪费。不过似乎制约速率的瓶颈就这网络传输上面，确实没办法。</p><h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><ul><li>对于网络爬虫/下载，最为制约效率的因素始终是网络因素，这个也是我们最不能把握的。可能是服务器端的接入速率因素，可能是服务器端的处理计算速度因素，可能是链路的传输速度因素，还可能是墙的因素，有很多的可能性。</li><li>在程序刚运行的时候，我想到过多的http请求会不会把那个站点搞崩。一百多话，每画平均25页，接近三千多张图片，需要发三千多个http请求，会不会over了，不过在当前这个速度下显然是想多了。不过这在以后的爬虫获取数据或者资源的时候确实需要考虑，为他人想想，可以考虑加点间隔时间。</li><li>东西不用了就会忘记，技能确实需要是不是拾起来使使。</li><li>有时候问题并不是在选择的方法或工具上面，可能只是简单的自己做错了/做得不够，或者当时的环境不行。</li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>最终因为电脑在休眠的时候自动更新，强行重启了，最终还是没下完，大概下了120话，花了4个半小时，远远超出我的预期。大概原因为</p><ul><li>线程设置有误。原本想设置7个线程，但没考虑到Go里面除法取整，少了一个线程，最后一个patch的任务没有执行，实际是六线程运行。</li><li>代码存在一些不合理的地方，造成了操作上的重复。如判断在每一话当中判断文件夹是否存在，我把他放到了循环当中，每下载一页的图片前都会判断；还有设置patch的时候没有考虑开闭区间，且下载的时候没有判断文件是否已经下载，导致首尾的漫画重复下载。</li><li>后期漫画的图片质量上去了，由前面的一百几十kb提升到后面的四五百kb，所以负责后面漫画下载的线程速度较慢，速度没有达到预期。</li><li>网络问题。可能昨天晚上的网确实不行，也可能是频繁访问被制约了网速。</li></ul><p>今天早上用Python把剩下的十几话下载下来，发现其实昨天的多线程代码有问题，修改了一下，顺利下载，而且速度还不错，我开了6个线程，下18话用了不到20分钟。看来还是网络的问题，难顶。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding记录" scheme="http://scottyeung.club/categories/Coding%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="Golang" scheme="http://scottyeung.club/tags/Golang/"/>
    
      <category term="爬虫" scheme="http://scottyeung.club/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="多线程" scheme="http://scottyeung.club/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>太极拳中的劲</title>
    <link href="http://scottyeung.club/2020/%E5%A4%AA%E6%9E%81%E6%8B%B3%E4%B8%AD%E7%9A%84%E5%8A%B2/"/>
    <id>http://scottyeung.club/2020/太极拳中的劲/</id>
    <published>2020-02-16T14:59:05.000Z</published>
    <updated>2020-02-17T13:18:54.320Z</updated>
    
    <content type="html"><![CDATA[<p>相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。</p><a id="more"></a><p>最近，又开始寻找锻炼方式，最好是一种万能的方法，能够对全身有着极大的帮助，于是又开始转回太极，在YouTube上面学了几个动作，回家后又再次搁置下来。在书柜乱翻时，心血来潮将高中时买的一本书《内家拳的瑰宝——懂劲》再次拿出来看看。这本书主要是描述内家拳当中最重要的核心——劲。所谓的劲，比较玄乎，大致的理解为肌肉收缩产生力，筋的收缩则产生劲。从太极拳等内家拳当中领悟到劲的感觉，且带着劲来打拳架，才是真的入门，用书中的话来说，才能到达“阶及神明”的地步。主要的好处有：</p><ul><li>劲能够刺激锻炼到全身，对身体当中的筋有很好的锻炼效果</li><li>通过劲在打拳当中能够更好的效果，尤其是在推手或技击中</li><li>只有领会到真正的劲，才能体会到太极当中的松，在生活当中有更好的状态</li><li>不伤身，可长久练习，不像一些刚猛的技击方法，对身体有所损耗</li></ul><p>怎样练习而找到这种劲呢？当时第一次看这本书，就是因为书中写得太过玄乎，而练习方式的叙述又太简单，被当时因学业紧张而对时间使用非常功利的我放弃掉。如今在家里比较闲，生活没有那么紧张，而且对有无所成感到没什么要求，又重新找了一下。劲怎么来？主要是从地来，力从地起，通过脚对地面的各种接触方式，产生根劲。再通过筋脉，由脚到腿，由腿到腰，由腰到全身。怎么练习呢？个人感觉关键有两点，一是怎么由脚产生劲，二是怎么在全身传导劲。前者，书中讲到一个脚掌落地与落地的方式，以左脚为例，从右上方根据顺时针分成四块，落地顺序为一四二三，离地则反过来。后者则需要注重旋转，变换重心等方式来转移劲。当然纸上谈兵非常简单，真的练习找到感觉非常困难，且是需要那种讲究顿悟的学习。具体的练习可以站桩，或者走拳架。书中给出了作者简化的二十二式太极拳，每天走十遍左右，可以试试感悟，不过书中的每一式就附上一张静态图片和一段文字解释（甚至不是动作描述），学会还是有难度的，不过太极拳的招式大致相同，且并不需要走套路，单独的招式也有效果（可能），网上找找估计能找到。</p><p>附上书中的二十二式太极拳：</p><blockquote><p>起势，左掤，右掤，捋，挤，按，单鞭，采，挒，肘，靠（左右二式），提手上式，搬拦捶，右斜飞式，搂膝拗步（三式），上步十字手，半步崩拳，抱虎归山，如封似闭，倒撵猴（三步），半单鞭（三式），左每人照镜，收势。</p></blockquote><p>常说传武式微，但就当前这种环境以及流传下来的资料，确实难以传承，就这本书来讲，一味地讲理论，讲劲的好处，而练习方式，拳架教学，只有短短不到三十页，还不到全书五分之一，仅凭这些就能够学会的确实是天赋非凡。因为没有资料，只能靠师傅人工传承，但终有各种的不方便，最主要的，还是好师傅难寻，寻到也不一定愿意教，这样的环境，技艺失传又有何奇怪。不过我也没想着练出啥绝世的武功，无非是希望能锻炼下身体，以及能够以太极的松柔状态来过生活，仅此而已，所以随缘就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.club/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="养生" scheme="http://scottyeung.club/tags/%E5%85%BB%E7%94%9F/"/>
    
      <category term="太极" scheme="http://scottyeung.club/tags/%E5%A4%AA%E6%9E%81/"/>
    
      <category term="运动" scheme="http://scottyeung.club/tags/%E8%BF%90%E5%8A%A8/"/>
    
      <category term="内家拳" scheme="http://scottyeung.club/tags/%E5%86%85%E5%AE%B6%E6%8B%B3/"/>
    
      <category term="玄学" scheme="http://scottyeung.club/tags/%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>就医当中的医疗选择——《最好的抉择》读书总结</title>
    <link href="http://scottyeung.club/2020/%E5%B0%B1%E5%8C%BB%E5%BD%93%E4%B8%AD%E7%9A%84%E5%8C%BB%E7%96%97%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E3%80%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E6%8A%89%E6%8B%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://scottyeung.club/2020/就医当中的医疗选择——《最好的抉择》读书总结/</id>
    <published>2020-02-01T09:20:32.000Z</published>
    <updated>2020-02-02T04:02:36.978Z</updated>
    
    <content type="html"><![CDATA[<p>在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。</p><a id="more"></a><h2 id="理想状况"><a href="#理想状况" class="headerlink" title="理想状况"></a>理想状况</h2><p>最理想的就医情况，莫过于在就医时，医生可以根据个人的具体情况，进行具体的分析，对于病症，给出可供选择的治疗方案。每个方案，都给患者进行完备的解释，包括具体流程，治疗效果，方案成功率，副作用的几率及程度，并且可以提供一定的数据，对效果和概率进行形象化的说明。患者可以根据医生提供的方案和说明，清楚自己的选择可以带来的效果和副作用，并向医生提出自己的疑问和担忧以获得解答。最终两者达成一致，进行治疗。</p><p>但事实上，这样的理想情况，很难出现，尤其是在国内的就医环境当中。医生往往因为无法根据患者的具体情况进行判断，一是会诊时间不多无法对患者进行详细的询问以获取更多信息，二是病患有些时候也不知道如何表达自身情况，应该告诉医生什么信息。所以医生有些时候只能流水线般地给出一些固定的方案。另外，因为患者有些时候对于医生的权威有着畏惧，不敢提出自己的疑问，甚至反对意见。病人怕于见医生，怕于反对医生，最后可能糊里糊涂地就接受了医生的某个方案，最终只能对着不好的效果后悔。</p><p>所以，就医过程中，需要考虑若干因素，从医生的角度，从病人自己的角度，做出最佳选择。</p><h2 id="医生的建议"><a href="#医生的建议" class="headerlink" title="医生的建议"></a>医生的建议</h2><p>当医生给出若干的选项，然后建议你其中一个最好时，甚至医生只给你提供了一个医疗选项，说其它的不够好时，你是否应该听从呢？</p><p>书中讲到了一个治疗甲亢的例子，主人公因为甲亢而去看内科医生，医生给出的方案是让其服用放射性碘丸，利用放射性烧掉甲状腺，日后通过口服甲状腺激素进行补充替代，需要终生服药。破坏掉人体中的一个器官，并且终身都离不开某种药物，相信很多人都不太能接受，真的只有这种方法吗？患者经过查询向其他医生求助时发现，其实还有两个方法，一是手术切除甲状腺，后续终身服药，另一种是通过服用一些抑制药物来抑制症状。在得知这些信息后，患者重新去询问该内科医生，医生只是简单地回答这个方法效果最好，好在哪里，也说不出个所以然。但是根据数据统计，其实三种方法的效果都差不多，而放射性碘丸还可能有辐射到其它器官的风险。说是最好，也未必是。</p><!-- 医生的偏见。 --><p>医生会有这样不同的观点，很显然医生也有着自己的偏好，当可供选择的方案相差不大时，医生可能会因为自己的主观因素而对其中的某种选择有着更高的偏好，或者对某种方案有着偏见。如同上面提到的三种方案，根据调查，经历过地震导致核泄露的日本医生就会更偏向于不使用放射性碘丸，而传统的极端的医生则倾向于通过手术切除甲状腺，一步到位。带有偏好的选项，真的适合我们吗？我们做出的选择恐怕会受其影响。为了避免这种情况的出现，不妨对医生深入地询问备选方案，问清其利弊，偏好或是建议的原因。若在该医生处得到的信息不够完备，不妨多问几个不同的医生，上网查询相关的方案信息和病例数据。</p><h2 id="选择的影响因素"><a href="#选择的影响因素" class="headerlink" title="选择的影响因素"></a>选择的影响因素</h2><p>除了医生的影响之外，影响病人做出医疗方案选择的，还有许多因素。在选择时，我们需要考虑这些因素，排除噪声影响。</p><h3 id="易得性因素"><a href="#易得性因素" class="headerlink" title="易得性因素"></a>易得性因素</h3><p>对于听到的具体的传言或故事，我们的印象总是要比冰冷的数据更为深刻。尽管医生推荐你可以用方案B，告诉你方案B相较于方案A的成功率要高，副作用相对可能较少，但若果你知道身边的某个人通过方案A成功治愈，且效果良好，没有副作用，你也会被这个真实的例子吸引住，进而选择方案A而不是方案B，因为你不知道这个成功率高，可能较少，是一种什么情况。同理，像治疗高血脂的药，如果不服用降低血脂，会有一定的概率出现心血管疾病，但是服用药物有一定的概率出现不良反应。一般来说，医生应该给出不服用的心血管患病概率，以及不良反应的症状和概率，由患者进行权衡（不过在国内好像很少会考虑药物的不良反应，都是有症状就直接开，出现不良反应就再治不良反应或换药）。尽管可能不良反应概率可能很低，或者可以通过停药而消失，但如果你的身边有人服用这些药物出现不良反应，而且消失不了，相信你的心里对服用这些药物也会有着一定的介怀。</p><h3 id="自然主义与极端主义"><a href="#自然主义与极端主义" class="headerlink" title="自然主义与极端主义"></a>自然主义与极端主义</h3><p>有一部分人，对于服用药物，进行手术等通过外力改变身体状况的方式比较排斥，这些人可以成为自然主义者，这些人信奉可以通过自己调整生活方式或生活状态，使身体自然恢复。当身体出现某些症状后，他们第一时间通过调整生活方式，试图消灭这些症状，当没有效果时，他们才会去寻求医生和药物的帮助，即使如此，他们仍然希望接受最少的治疗，他们的内心对于医学有着一定的怀疑。与之相对的，还有极端主义者。他们一旦身体出现了某些症状，甚至只是某些身体指标的升高，他们就会第一时间寻求医生的帮助，试图通过药物或手术让身体指标回复正常，不能容忍身体存在一丝异常。</p><p>此处并不能指出两者谁更好，两者都有正面与反面的例子。当然这两者都比较极端，我们在生活中也很少极度偏向一端，而且我们的观点也很可能会随着某些事情的出现而改变。既然有着某一边的偏向，就要向医生表达出来，达成妥协，不然在治疗过程中，内心可能会心生不满，甚至事后埋怨治疗结果。</p><h3 id="病人的交流"><a href="#病人的交流" class="headerlink" title="病人的交流"></a>病人的交流</h3><!-- 向病人寻求咨询和交流，获取信息以帮助交流 --><p>上面提到的易得性原则，大多数具体信息的获得来自于其它病人。当我们患病需要寻求其它信息帮助我们做出选择时，我们可以通过求助于此前使用这些治疗方法的病人。通过他们，我们可以获取详细而真实的信息，病人往往无所顾忌，对于疗效和后续的不良反应能够直接表达。当然，有些时候，病人也可能会因为某些原因而隐瞒一些状况。这就需要自己思考过滤信息了。</p><h3 id="承受程度"><a href="#承受程度" class="headerlink" title="承受程度"></a>承受程度</h3><!-- 低估对生活状况的忍受程度。觉得接受不了，其实未必 --><p>在我们健康的时候，我们总会对生活质量的下降而感到不能忍受，就如若让你去除双眼以保住性命，很多人可能宁可不活了，也不能忍受失明后的生活。我们很多人其实都低估了自身对于生活质量下降的承受程度，觉得不能承受这些改变。不过当我们真的不得不做出如此改变，生活质量下降之后，我们其实也能够迅速适应，并且觉得不以为然。</p><blockquote><p>许多心理学研究发现，人们往往低估了自己适应新环境和新情况的能力。很多健康的人会把遭遇某种医疗问题后生活的“效用”或者“价值”低估，但是真正有这些问题的人却远没有那么悲观。比方说，健全的人会认为失明是非常糟糕的事情，但是失明几年之后的盲人却认为情况没有健全的人想的那么坏。这对那些在肠道造口术后无法控制排便的人也一样。许多健全人觉得这些结果非常可怕，所以给它们的“效用”或者“价值”打了非常低的分数，但是那些需要承受这些结果的人却觉得生活比前者所想的好多了。<strong>人们的适应能力其实是很强的，我们总能够在生活中发现“价值”，总有未爆发的抗挫潜力</strong>。</p></blockquote><h2 id="代理人的选择"><a href="#代理人的选择" class="headerlink" title="代理人的选择"></a>代理人的选择</h2><!-- 代理人为在病人无法做出选择时，替代其做出医疗方案选择的人。三个原则：自决性，行善性，不伤害性。 --><p>除了需要病人自己做出选择以外，在有些特殊情况，还需要选择代理人，通过代理人来替自己做出选择。所谓的代理人，为在病人意识不清楚而不能做出决定时，代替病人做出选择的人。代理人做出的选择，也是需要通过非常艰难的抉择，一方面要符合病人的意愿，选择不能让其反对，必须要他接受，另一方面又要最为适合病人，效果最好。当病人的意愿与最佳疗法冲突时，当病人的想法与代理人的想法有出入时，当病人没有或无法表达选择意愿时，代理人应该怎样做出选择。</p><p>书中给出了三个原则以帮助代理人做出抉择，三种的优先级从高到低。首先是自决性原则，无论如何，承受治疗的主体都是病人本书，好与不好都由他本人承受，因而所有的选择都必须符合其意愿，至少在他做出选择的一刻是符合他当时的意愿的。其次，则是行善性，所做出的选择必须是对病人有利的，是不是最优的先不谈，但必须是有帮助的，有帮助的可以先上。最后，是不伤害性，治疗方案应该尽可能对人体无害，当然这个在有些时候也不能百分百保证，尤其是当情况紧急，状况不佳时，不得不采取一定的权衡。</p><hr><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>书中称医学为一门精确而不确定的科学。说其精确，是因为现代医学将一切都数据化，精确化。对于某些症状，其数据指标符合特定的数据指标，则判定为某疾病，采用某治疗方式。然而这种全通过数据，机械化的诊断流程，真的可以适应任何人，满足任何人吗？在这样的灰色地带，想要做决定往往并不容易，选择也往往不是那么明显。因此，医学涉及医生和病人微妙并且私人的决定。</p><blockquote><p>通过研究和数据，我们可以知道在100位像苏珊·鲍威尔那样的妇女中，会有一两位患有高胆固醇，但究竟是哪一两位呢？同样，我们也无法判断在300位妇女中，有哪一位或者两位妇女服用他汀类药物会产生疗效。甚至通过检测带有遗传信息的BRCA基因，我们也只能得到一个癌症发病率的估计值。没有人能够确切地知道，哪位妇女会在哪个确定时间患上乳腺癌；也没有人能够清楚地指出心房颤动、前列腺癌或者其他的疾病会给个体的生活带来怎样的影响，某种治疗方案在某个人身上又会出现怎样的副作用。我们每个人都是由不同的基因组合以及各自的环境造就出来的独一无二的个体。怎样保持健康或者从疾病中康复，并没有一个统一的方法。<br>然而这一本质性的问题往往被一些专家忽视，他们试图将治疗标准化，而不考虑病人的个体需求。虽然有人把这些公式当作科学来看，但是其实这种方法的实质是要把患病的经验转变成数字，这种努力的方向其实就是错误的，是徒劳的。然而保险公司和政府官员却总是在给医生和医院施加压力，要求他们通过各种公式把医疗服务标准化。保单设计人员，甚至是某些医生自己都宣称，把医学当作一门艺术的想法已经过时了。现在，医疗服务应当按照工业生产的方式来提供，医生和护士只要按照操作手册亦步亦趋就可以了。这些人甚至认为，医生和病人没有资格决定什么治疗方案最好。所以，当他们大谈医疗改革的目标是“以病人为中心”的时候，他们其实追求的是“以体制为中心”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="医学" scheme="http://scottyeung.club/tags/%E5%8C%BB%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Sum Circular Subarray</title>
    <link href="http://scottyeung.club/2020/Maximum-Sum-Circular-Subarray/"/>
    <id>http://scottyeung.club/2020/Maximum-Sum-Circular-Subarray/</id>
    <published>2020-01-21T11:59:53.000Z</published>
    <updated>2020-02-06T04:43:03.600Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><ul><li>source: <a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">Maximum Sum Circular Subarray</a></li><li>difficulty: Medium</li></ul><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p><p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i] when 0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i] when i &gt;= 0</code>.)</p><p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray $C[i], C[i+1], …, C[j]$, there does not exist $i &lt;= k_1, k_2 &lt;= j$ with$k_1 mod A.length = k_2 mod A.length $.)</p><a id="more"></a><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><p>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 = 10</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 = 4</span><br></pre></td></tr></table></figure></p><p>Example 4:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure></p><p>Example 5:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ol><li>$-30000 &lt;= A[i] &lt;= 30000$</li><li>$1 &lt;= A.length &lt;= 30000$</li></ol><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="暴力法"><a href="#暴力法" class="headerlink" title="暴力法"></a>暴力法</h2><p>因为太久没有做过题了，对题目都没什么感觉了，感觉有点熟悉，可以用DP（发现是暑假的时候在紫书中看过），但是一下不知道怎么用。于是先用暴力法试试水。</p><p>题目当中要求的是最大子段和，所以考虑枚举所有的子段，每个子段包含一个普通的区间和一个首尾相接的连续区间。<br>枚举的情况有$2 * C_n^2$种，每种情况计算子段和可以通过累计前缀和来计算，总复杂度为$O(n^2$)。</p><p>最后结果为超时，大概能过 91 / 109 个样例。</p><h2 id="最大子序列和算法"><a href="#最大子序列和算法" class="headerlink" title="最大子序列和算法"></a>最大子序列和算法</h2><p>暴力法超时后思考无果，上网看看别人的思路。发现求解最大子序列的和有一个很好的算法，就是 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">Kadane 算法</a>。很好理解，直接在下面提出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = cur = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">        cur = arr[i] + max(cur, <span class="number">0</span>)</span><br><span class="line">        ans = max(ans, cur)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>源方法来自于DP的化简，设 $dp[i]$ 为数组以元素<code>arr[i]</code>结尾的最大子序列和，则有下列的转移方程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>] = dp[i] + arr[i+<span class="number">1</span>] <span class="keyword">if</span> dp[i] &gt; <span class="number">0</span> <span class="keyword">else</span> arr[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>实际使用过程中无需存储dp数组，为了降低空间复杂度，使用数值变量记录数值即可。</p><h2 id="问题进一步分析"><a href="#问题进一步分析" class="headerlink" title="问题进一步分析"></a>问题进一步分析</h2><p>于是问题就变成了在求解数组的最大子序列和的基础上，进一步考虑双向区间的和。原本的子序列，只考虑数组的单向区间，这一块可以通过kadane算法求解，所以所需考虑的问题为怎么求双向区间（一头一尾组成）的子数组和。大致有下面三种方法。</p><h3 id="相邻数组法"><a href="#相邻数组法" class="headerlink" title="相邻数组法"></a>相邻数组法</h3><p>单区间子序列的最大值可以通过Kadane算法直接求出。<br>环形序列的双区间子序列则可分成左右两部分来找出，我们定义<code>maxright[i]</code> 为下标为i的元素右侧的最大子序列和，这个可以通过一次倒序扫描求出。所以双区间最大子序列和为<code>max(leftsums[i] + maxright(i+1) for i in range(N-2))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(A)</span>:</span></span><br><span class="line">    ans = cur = A[<span class="number">0</span>]</span><br><span class="line">    N = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">        cur = A[i] + max(<span class="number">0</span>,cur)</span><br><span class="line">        ans = max(ans,cur)</span><br><span class="line"></span><br><span class="line">    leftsums = [A[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N): leftsums[i] = leftsums[i<span class="number">-1</span>] + A[i]</span><br><span class="line"></span><br><span class="line">    rightsums = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    maxright = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        rightsums[i] = rightsums[i+<span class="number">1</span>] + A[i]</span><br><span class="line">        maxright[i] = max(maxright[i+<span class="number">1</span>],rightsums[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N<span class="number">-1</span>):</span><br><span class="line">        ans = max(ans, leftsums[i<span class="number">-1</span>]+maxright[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="变号法"><a href="#变号法" class="headerlink" title="变号法"></a>变号法</h3><p>本方法将双区间的序列和转化为整个数组的总和减去单区间子段和，其值为$S - \sum_{k=i}^jA_k$，该值的最大值为后者取最小值时的值，问题变成求解数组元素i到j的最小值，将数组元素全体乘以-1，则变成求解最大值，可套用kadane算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(gen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(gen) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = cur = gen[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> gen[<span class="number">1</span>:]:</span><br><span class="line">            cur = i + max(cur,<span class="number">0</span>)</span><br><span class="line">            ans = max(ans,cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    alls = sum(A)</span><br><span class="line">    ans1 = kadane(A)</span><br><span class="line">    ans2 = alls + kadane([-A[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)<span class="number">-1</span>)])</span><br><span class="line">    print(alls,ans1,ans2)</span><br><span class="line">    <span class="keyword">return</span> max(ans1,ans2)</span><br></pre></td></tr></table></figure><h3 id="前缀和-优先队列"><a href="#前缀和-优先队列" class="headerlink" title="前缀和+优先队列"></a>前缀和+优先队列</h3><p>因为数组A的循环子段必然是数组B=A+A的子段，所以可将数组拼接一次在求单区间的最大子序列和，只需满足子序列长度不超过原数组长度。<br>对于子序列<code>B[i+1:j+1]</code>，其和为<code>P[j]-P[i]</code>，这里我们固定j，找出使P[i]最小的i值，可通过优先队列实现，这里通过在插入元素时比较当前元素与队列末元素的大小进行插入处理，手动实现优先队列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(A)</span>:</span></span><br><span class="line">    P = A * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        P[i] = P[i] + P[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque([<span class="number">0</span>])</span><br><span class="line">    ans = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        i = queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> j-i &gt; len(A):</span><br><span class="line">            queue.popleft()</span><br><span class="line">            i = queue[<span class="number">0</span>]</span><br><span class="line">        ans = max(ans, P[j]-P[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> P[queue[<span class="number">-1</span>]] &gt; P[j]:</span><br><span class="line">            queue.pop()</span><br><span class="line"></span><br><span class="line">        queue.append(j)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;source: &lt;a href=&quot;https://leetcode-cn.com/problems/maximum-sum-circular-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Sum Circular Subarray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;difficulty: Medium&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.&lt;/p&gt;
&lt;p&gt;Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, &lt;code&gt;C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length&lt;/code&gt;, and &lt;code&gt;C[i+A.length] = C[i] when i &amp;gt;= 0&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray $C[i], C[i+1], …, C[j]$, there does not exist $i &amp;lt;= k_1, k_2 &amp;lt;= j$ with$k_1 mod A.length = k_2 mod A.length $.)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="LeetCode" scheme="http://scottyeung.club/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://scottyeung.club/tags/DP/"/>
    
      <category term="最大子序列和" scheme="http://scottyeung.club/tags/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>谈谈牙齿</title>
    <link href="http://scottyeung.club/2020/%E8%B0%88%E8%B0%88%E7%89%99%E9%BD%BF/"/>
    <id>http://scottyeung.club/2020/谈谈牙齿/</id>
    <published>2020-01-03T11:43:59.000Z</published>
    <updated>2020-01-05T02:17:30.695Z</updated>
    
    <content type="html"><![CDATA[<p>周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。</p><a id="more"></a><p>因为来得比较早，加上只是挂了个普通号，比较快就看上了。拍了个牙片，给医生看了看，病情和治疗方式基本如之前设想的一样，需要做根管治疗。所谓的根管治疗，是将牙齿内部的根管/神经清理干净，彻底清理消毒后，填入消毒材料进行填充。根管治疗后牙齿因为失去神经/根管的营养，会比较脆弱，需要加个牙冠。在医生再三向我强调根管治疗的注意事项以及协商了时间之后，我签署了同意意向书，开始治疗。给我看牙的是一个很温柔的女医生。暂时的治疗只是在病牙上打了一个洞，对牙齿内部进行了药物冲洗，让其暴露几天，流出之前的发炎的分泌物。治疗后就不怎么痛了，不过仍然要进行后续的治疗。</p><p>一直以来，我的牙齿都不是特别的好，这也已经不是第一次牙齿出问题了。在小的时候，对于牙齿不是很重视，在没换牙之前，牙齿就出过问题，换了牙之后，也出过不少的问题。在中考结束后，第一次补了牙，当时是因为大牙出现冷热酸痛。后面陆续补过几个牙，之后才开始重视牙齿问题。但已经感到有点为时已晚。个人感觉小地方的牙医诊所有些不足的地方：一是治疗追求治标，蛀牙了便补，牙痛了便打开杀神经再补，再痛就再来一次。二是没有一个很好的教育预防理念，牙痛/蛀牙去看牙，都是帮你补了就算，也没有告诉你成因，提醒了你应该怎么做，更不会顺便检查你的其它牙齿，最有趣的是我箍牙的时候的医生，经常跟我说我没有好好刷牙，但事实是我刷的认真且勤快，他也不给出具体的解释或者补充。</p><p>大一的时候也有出现过牙痛的状况，寒假的时候以为是普通的小事就忍了忍，开学就发作，也是跑去了武大口腔，两个连着的牙齿蛀了，其中一个还疑似深髓，可能要根管，当时对于金钱还比较敏感（也可以说是没这么多钱），听到要可能2000+之后就放弃了在那里治疗，忍了一个学期回去小城市治，方法就是普通的去除蛀牙部分，补牙，痛了就下杀神经的药，下周再来，陆续也治了三周，最后不痛了，也不知道是不是就算是治好了。</p><p>在当时回去治疗之前，上网看牙齿相关的资料，发现了一本很有趣的书 <em>Cure Tooth Decay: Heal &amp; Prevent Cavities with Nutrition</em> 是说用营养学来治疗牙齿疾病的，中心内容就是多吃富含脂溶性维他命的东西，鱼肝油，无机盐钙和镁，少吃升血糖指数高的和植酸食物。书中其实没给出什么比较科学的解释，基本都是通过一些资料/实际情况做的实证研究/统计，试了下，也就那样，该疼还是疼。</p><p>在这次痛的过程中，我又重新翻了翻这本书，又上网搜了搜这本书，结果在豆瓣找到了一个对于这本书的读者&amp;实证者，此处贴出他的一篇<a href="http://blog.sina.com.cn/s/blog_6e979bb90100mnf0.html" target="_blank" rel="noopener">文章</a> 基本上就是在上面的营养防治的理论的完善补充。为什么会蛀牙，出现牙病，原因无非是细菌繁殖在我们的牙齿上，造成了酸性的环境，腐蚀我们的牙齿。一直以来的理论，都是让我们通过刷牙来消灭这些细菌，但对于有些人，例如我，效果就属实一般，即使是使用电动牙刷+牙线+漱口水，该蛀还是得蛀。采用营养学的方法是另一种思路，通过加固/恢复我们的牙齿，进行防治。一方面，还是需要使用牙线+冲牙器清洁牙齿，去除细菌，但另一方面，还需要补充一些营养来恢复牙齿，加固牙齿。<br>书中给出的主要方法是：</p><ul><li>使用牙线 + <strong>冲牙器</strong> 来保持牙齿的清洁</li><li>补充维生素$K_2$和$D_3$帮助牙齿吸收钙质元素</li><li>补充钙和镁等矿物质</li><li>尽量避免摄入酸性物质，对牙齿有腐蚀作用的食物</li></ul><p>感觉还是挺有道理的，可以尝试一下。不过这些方法感觉都只能用在预防上面，当牙齿真的出了问题，还是建议去大医院好好地看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.club/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="生活" scheme="http://scottyeung.club/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="牙齿" scheme="http://scottyeung.club/tags/%E7%89%99%E9%BD%BF/"/>
    
  </entry>
  
  <entry>
    <title>&lt;唤醒大脑：神经可塑性如何帮助大脑自我疗愈&gt; 读书笔记</title>
    <link href="http://scottyeung.club/2019/%E5%94%A4%E9%86%92%E5%A4%A7%E8%84%91%EF%BC%9A%E7%A5%9E%E7%BB%8F%E5%8F%AF%E5%A1%91%E6%80%A7%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E5%A4%A7%E8%84%91%E8%87%AA%E6%88%91%E7%96%97%E6%84%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://scottyeung.club/2019/唤醒大脑：神经可塑性如何帮助大脑自我疗愈-读书笔记/</id>
    <published>2019-12-30T09:53:48.000Z</published>
    <updated>2019-12-30T09:55:01.194Z</updated>
    
    <content type="html"><![CDATA[<p>本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。</p><a id="more"></a><p>一直以来，大脑都是被认为是一个精密的仪器，一旦某处出现问题，身体就会出现相关的问题，且难以治疗。作者提出，可以利用神经可塑性的方法，使用一些自然的刺激手段，帮助大脑进行自我修复，进而治疗因大脑的问题而出现的疾病，如中风，帕金逊。</p><p>具体的疾病及其治疗如下：</p><h2 id="慢性疼痛"><a href="#慢性疼痛" class="headerlink" title="慢性疼痛"></a>慢性疼痛</h2><p>疼痛其实并不是疼痛源引发疼痛而被大脑感觉到，而是大脑为了警告危险的出现，而发出疼痛的表现来提醒自身。每次疼痛，相应的神经元会进行放电，长期某个位置疼痛，会形成一个习惯，即使身体痊愈，疼痛系统仍然会放电，引发疼痛。</p><p>神经可塑性的一条核心规律是，同时启动放电的神经元是连接在一起的，也就是说，反复的精神体验使大脑处理该体验的神经元产生结构性变化，令神经元之间的突触连接更为强健。反过来也是一样。如果一个人长期放弃执行某一活动，这些连接就弱化了，随着时间的推移，很多连接甚至消失了。这说明了神经可塑性的一条更普遍的原理：用进废退现象。</p><p>疼痛需要大脑的神经元进行处理，因而我们可以通过分散大脑区域的资源，减少处理疼痛的大脑区域。具体可以通过可视化想象的方法来压倒疼痛。处理视觉信息和疼痛的有两个脑区，后扣带回（帮我们从视觉上想象东西所处的空间位置）和后顶叶（也用于处理视觉输入）。</p><blockquote><p>每当疼痛袭来，他就立刻开始可视化想象。但想什么内容呢？他想象的就是自己绘制的脑图，他提醒自己，大脑真的可以改变，好让自己保持动力。他先栩栩如生地想象大脑处于慢性疼痛中的画面，然后观察慢性疼痛过程中脑图有多少地方的神经可塑性在扩展。接着，他会想象启动放电的区域渐渐缩小，看起来就像是大脑没有感到疼痛时的样子。“我必须无情，比疼痛信号本身更无情。”他说。他用大脑疼痛区域缩小的画面迎接每一波疼痛，他知道，必须强迫自己的大脑后扣带回和后顶叶处理视觉图像。</p></blockquote><p>因为神经可塑性用进废退的特点，当每次慢性疼痛出现的过程，通过可视化的方式，分散/避开/减少大脑对疼痛的处理来减轻疼痛，弱化疼痛的感受，久而久之，疼痛的回路弱化，慢性疼痛的现象消失。</p><h2 id="走路疗愈帕金逊综合征的症状"><a href="#走路疗愈帕金逊综合征的症状" class="headerlink" title="走路疗愈帕金逊综合征的症状"></a>走路疗愈帕金逊综合征的症状</h2><p>帕金逊综合征为大脑黑质出现问题，影响了关于身体活动所需的多巴胺，会导致身体的活动能力丧失，但通过每天坚持锻炼，尤其是走路，可以使身体保持活动的能力，当然这并不是治好帕金逊综合征，药物也不能轻易地减少，但通过保持每天的走路，保持每天的运动量，可以通过另一种方式来保持自身的活动能力。</p><hr><p>其它的章节感觉比较玄乎，篇幅也比较常，待填坑。包括：</p><ul><li>光帮助大脑连接</li><li>帮助自闭患者重新获得会话能力</li><li>一位盲人学会了看</li><li>重新习得发声的能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="大脑" scheme="http://scottyeung.club/tags/%E5%A4%A7%E8%84%91/"/>
    
      <category term="神经" scheme="http://scottyeung.club/tags/%E7%A5%9E%E7%BB%8F/"/>
    
      <category term="疗愈" scheme="http://scottyeung.club/tags/%E7%96%97%E6%84%88/"/>
    
      <category term="疼痛" scheme="http://scottyeung.club/tags/%E7%96%BC%E7%97%9B/"/>
    
  </entry>
  
  <entry>
    <title>&lt;被讨厌的勇气&gt;读书体会与摘要</title>
    <link href="http://scottyeung.club/2019/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%91%98%E8%A6%81/"/>
    <id>http://scottyeung.club/2019/被讨厌的勇气-读书体会与摘要/</id>
    <published>2019-12-19T04:08:40.000Z</published>
    <updated>2019-12-19T04:36:19.867Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26369699/" target="_blank" rel="noopener">《被讨厌的勇气》</a>通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。</p><p>这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃</p><a id="more"></a><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><ul><li>世界是简单的，人也是简单的。复杂是因为人把世界看得复杂，这就涉及到有无勇气，正视世界的问题</li></ul><h3 id="另一种心理学"><a href="#另一种心理学" class="headerlink" title="另一种心理学"></a>另一种心理学</h3><ul><li>另一种心理学：阿德勒心理学，属于目的论，对比于传统心理学流派的原因论，区别相当于想法影响情绪还是情绪影响想法。对于原因论，有几个问题：对于当前遇到的心里问题，一味分析其成因，对于解决问题没有太多实际的意义，如同感冒去看医生，医生只告诉你感冒是因为之前着凉了一样了；给予同样的经历，即原因相同，但是不同人会有不同的结果。目的论讲究目的，认为主要是取决于个人的看待态度与方式。重要的不是经验本身，而是对待经验的方式。换而言之，情绪是可以控制的，情绪只是某些时候特定行为的一个借口。同样，人的性格与本性也是可以改变的，受到自身的观念所影响，很多时候不是不想改变，而是自身不想改变，缺乏面对改变时可能会遇到的陌生与不安的勇气。另外，也担心改变之后失去了对当前不满的状况的解释借口。不去改变，借口没有这个条件才不能实现这件事情，这样就能掩饰自己实现不了这件事的状况。</li><li>自卑感与自卑情结。自卑感是一个很正常的感受，每个人都会有，健康的自卑感应该来自当前的自己与理想中自己的落差，而不应该来自与他人的对比。通过健康的自卑感，我们可以找到自己努力成为更好的自己的方向 。至于自卑情结，则是一种不健康的状态，由不健康的，过度的自卑感来形成。带有自卑情结的人，往往会将生活遇到的问题，对当前状况的不满，归结于当前所拥有的自卑感。因为在某些条件上处于落后，感到自卑，所以在某些事情上面失败就有理由了，要不是那样，我就怎么样了。因为有着可以逃避的借口，带有自卑情结的人会一直处于这种自卑的状态来保护自己。另外，自卑情结还会带来：权势张越，因为自身的不自信，所以需要通过一些外在的事物/功绩来夸耀自己；弱者保护，我弱我有理，因为我弱，所以我做出了某些成绩我就是了不起，做不出来的话则是我本应如此。</li></ul><h3 id="关于竞争"><a href="#关于竞争" class="headerlink" title="关于竞争"></a>关于竞争</h3><ul><li>竞争应该是在一张平面上各人沿着自己的方向按照自己的速度前进，竞争的对象应该是自己，而不是其他人。每个人的速度不一样，必然有人走在前面，有人走在后面。走在前面的未见得能够一直保持走在前面，如果选择了不当的对比对象，只能造成自身长久的失败感。另外，将他人放在竞争对手的位置上面，很难够成为真正的伙伴。竞争必然存在输赢，有时候我们不能发自内心地为他人的成功高兴，就是因为将其放在竞争对手的位置上面，因而会有他人的成功等同于自身的失败这种想法。</li><li>基于上面的原因，也没有必要与人争执，尤其是争执的程度发展到企图通过发怒来解决。发怒不只是情绪，其实也是你的一种表达方式，一种不太好的表达方式，遇到争执时，可以通过发怒来表达，但效果没有通过言语沟通交流来得好。所以遇到争执无法解决时，不妨承认错误，以免事情的讨论上升到人身的讨论，变成你对我错的二元选择。当你坚信是对的话，别人持什么样的态度都无法改变你的观点。</li></ul><h3 id="关于人生"><a href="#关于人生" class="headerlink" title="关于人生"></a>关于人生</h3><ul><li>人生行为的两大目标：自立和与社会和谐相处。而支持这些想法的也有两个心理目标：我有能力的意识和人人都是我的伙伴的意识。这些目标可以通过直面人生课题来解决，包括工作，交友，爱。</li><li>人生的谎言。我们常常为逃避生活中遇到的事情而寻找开脱的谎言和借口。一个很典型的例子，不是因为某人的缺点而讨厌某人，而是因为讨厌某人而自然就会去发现其缺点，归根到底，实在逃避糟糕的人际关系。我讨厌某人，不愿与某人相处，我发现到他有什么缺点，因为他有这些问题，我就可以离他远点，不用相处。</li><li>否定寻求他人认同的行为和想法，我们没有必要总是想着需要满足他人的期待。每个人都只是为了自己活着，而非为了其他人活着。但在实际生活中，好多人都无法做到这一点，甚至可能会事事都想着得到他人的认同，从而被他人影响自身的行为，不得不做许多并不情愿的行为。</li><li>工作课题的分离。所谓的工作课题，为每个人各自应该要做的事情，不同人，具有不同的身份，处于不同的位置都具有不同的工作课题，我们不应该干涉他人的工作课题，也不应该被他人干涉。如何判断工作课题属于谁？谁将承担后果就由谁来处理。当我们在日常生活中陷入困境或对现状不满时，我们不妨想一想有没有进入到他人的课题中，如果有，果断抛开，进行分离。正如上面说到的让他人满意，他人接受，这不应该是你的课题，你做完了自己的工作就已经足够，他人是否接受，如何评价，会否反对，都是他人的课题，你不应该操心，操心也没有用。而如果你操心了他人的课题，选择采取额外的工作或者改变来迎合他人，则只会增加自己的不满。另外，因为工作课题的分离，我们的责任也可以随着不干涉他人的课题一并减轻。</li><li>但是，有些人却对着这种所谓的责任存有留恋，并认为这种操心他人课题的责任能够有利于他人的成长。就像家长操心孩子的成长，干涉孩子的成长的课题，以是为了孩子好的理由，为其铺排好一切道路。是选择带着不满接受父母为其铺排好的可能较大几率有着较好前程的道路，还是自由地选择自己想要的道路，这取决于个人的选择，没法给出一个确定的答案。但前者的所谓较好前程，难道不是在满足他人的认可和期待吗？尽管如此，很多人可能还是会倾向于前者，因为不需要自己做出选择，可能是因为确实迷茫不知道如何选择，更有可能是因为前者不需要自己亲自做出选择，选择都不是我做的，如果结果不好的话，我能够有埋怨的对象，“都说了不这样”。</li></ul><h3 id="关于勇气"><a href="#关于勇气" class="headerlink" title="关于勇气"></a>关于勇气</h3><ul><li>被讨厌的勇气。我们不可能做到不被所有人讨厌，自由就是被别人讨厌。每个人都有寻求认可的倾向性，而从中寻求解脱就是获取自由。当否定了寻求他人的认可之后，必然会存在有人不认可你，进而产生讨厌的念头。我们对此无能为力，也无须担心。他人是否讨厌我，这是他人的课题，我操心不来，而如果为其改变了自己，则违背了工作课题分离的原则，徒增自身的麻烦。</li><li>人的一切烦恼皆来自于人际关系。即便如此，在我们的人生课题中，我们还是无法避免人际关系，尤其是我们在社会中其实均处于一个共同体当中。所谓的共同体，可以大至一个国家，也可以小至一个两人的家庭。我们应该主动参与到共同体当中，这也课题分离并不矛盾，共同体并不唯一，也不存在非加入不可的共同体。基于此，当我们在某一共同体中出现不满或者矛盾，我们可以及时离开这一个共同体，将目光转向更大的，别处的共同体。</li><li>不应该批判，也不应该表扬。因为批判和表扬很容易将自身和他人放入一种纵向的关系当中，我对你进行批判或表扬，暗含着我有这个能力，暗示着我比你高一等的感觉，我可以批判你，也可以表扬你，带有一种操纵干涉的味道在此。值得提倡的，是鼓励。鼓励，是站在横向关系的角度。大多数人并不是缺乏解决问题的能力，而是缺乏面对问题的勇气，而鼓励，正是帮助对方意识到问题的本质，帮助他人寻找面对的勇气。</li><li>每个人都会受到自我意识羁绊，不能无拘无束的活动。正如在他人的面前，我们会很小心自己的言行，生怕影响了在他人面前的印象，但是只有自己一个人独处的时候，就会将其压抑完全暴露。本质上，我们是缺乏暴露本真的自己在他人面前的勇气。为此，我们需建立共同体感觉，所谓共同体感觉，就是对自我的执着，转化为对他人的关心。建立共同体感觉，需要从下面三点做起：自我接纳，他者信赖，他者奉献。</li><li>所谓的自我接纳，正如其本身的意思，就是接纳真实的自我，意识到自己能做什么，做不到什么。这是一种肯定性的达观，对于无法改变的，淡然接受，可以改变的，勇敢地取面对它。所谓的他者信赖，即是在人际关系中需要建立无条件的信赖关系，信任遭到了背叛怎么办，还是需要保持这种无条件的信赖关系，是否背叛这个属于他人的课题，我们不应该操心，但是若果多次背叛你，使你不愿与其继续相处，可以及时断绝关系，进行分离。他者奉献，则是在向作为伙伴的他人奉献的过程中找到自己的价值，区别于寻求他人的认同，我们所做的事情是否有价值，不是由他人来评价的，而是由自己的内心来决定。这里要将贡献和作用区分开来，你做出的贡献，判断其是否具有作用，这是他人的课题，我们只需将目光集中在自己的贡献即可。我做了某些事，我觉得自己对他人，对共同体都是有奉献的就可以了。</li><li>犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。”如果我们总是将目光只集中在事物的部分来决定其总体，我们则无法获得人生的和谐。另外，只将目光集中在人生的特定侧面，也是如此，例如工作狂。</li></ul><h3 id="关于幸福"><a href="#关于幸福" class="headerlink" title="关于幸福"></a>关于幸福</h3><ul><li>相比于设定一个远大目标，然后当下一直为其进行铺排和准备，我们更应该活在当下，活在此时此刻。人生不应该是一条线，并不是设定一个个的目标点，就能将自身和人生中的一个个阶段，一个个目标点连接起来的。如果只为了所谓的远大目标，我们在目标达成前所做的一切都只是在忍受获得成功的痛苦，这样是不理智的，万一失败了，到达不了终点呢？当前的忍受皆是白费？我们应该将人生看成是一个个不连续的点，每一个不连续的点都是当下，只有集中于当下，专注于此时此刻所做的事情，不考虑过去与将来，我们才能够获得长久的幸福感。正如登山，从踏出的第一步就开始了个人的旅途，如果我们只是一心想着登到山顶，那么途中的一切乐趣就会丢失，还不如直接坐缆车到山顶。</li><li>专注于此时此刻，不考虑过去与将来，我们能够很自由地活在当下，享受当下，但是，我们可能会感到迷茫，如何选择人生的方向呢，也就是下一个此时此刻怎么选择？答案是他者奉献。无论你过着怎样的刹那，即使有人讨厌你，只要没有迷失“他者贡献”这颗引导之星，那么你就不会迷失，而且做什么都可以。即使被讨厌自己的人讨厌着也可以自由地生活。而且，我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26369699/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《被讨厌的勇气》&lt;/a&gt;通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。&lt;/p&gt;
&lt;p&gt;这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="心理学" scheme="http://scottyeung.club/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="幸福" scheme="http://scottyeung.club/tags/%E5%B9%B8%E7%A6%8F/"/>
    
      <category term="阿德勒" scheme="http://scottyeung.club/tags/%E9%98%BF%E5%BE%B7%E5%8B%92/"/>
    
      <category term="人生" scheme="http://scottyeung.club/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Some Notes About SQLAlchemy</title>
    <link href="http://scottyeung.club/2019/Some-notes-About-Sqlalchemy/"/>
    <id>http://scottyeung.club/2019/Some-notes-About-Sqlalchemy/</id>
    <published>2019-12-07T02:24:35.000Z</published>
    <updated>2019-12-07T04:00:53.159Z</updated>
    
    <content type="html"><![CDATA[<p>近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。</p><p>SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求：</p><ul><li>提供对数据库的常用操作：增删改查</li><li>提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据</li></ul><a id="more"></a><h2 id="数据库连接"><a href="#数据库连接" class="headerlink" title="数据库连接"></a>数据库连接</h2><p>SQLalchemy不能支持操作数据库，因而需要安装额外的数据库驱动，对于不同的数据库与驱动，有着不一样的配置URI，总体格式为<code>dbms://user:pwd@host/dbname</code>。这里用的Mysql+mysqlconnector，具体的连接代码如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">sql_connection = &apos;mysql+mysqlconnector://root:pwd@localhost:3306/database&apos;</span><br><span class="line">engine = create_engine(sql_connection)</span><br><span class="line"></span><br><span class="line"># 执行sql事务需要使用会话</span><br><span class="line">DBsession = sessionmaker(bind=engine)</span><br><span class="line">session = DBsession()</span><br><span class="line"></span><br><span class="line"># 结束前需要关闭session</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><h2 id="结构定义"><a href="#结构定义" class="headerlink" title="结构定义"></a>结构定义</h2><p>在SQLalchemy中，ORM通过定义对象进行数据库model的绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relation, sessionmaker</span><br><span class="line"></span><br><span class="line">Base = declarative_base()</span><br><span class="line"> </span><br><span class="line">class Movie(Base):</span><br><span class="line">    __tablename__ = &apos;movies&apos;</span><br><span class="line"> </span><br><span class="line">    id = Column(Integer, primary_key=True)</span><br><span class="line">    title = Column(String(255), nullable=False)</span><br><span class="line">    year = Column(Integer)</span><br><span class="line">    directed_by = Column(Integer)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    def __init__(self, title=None, year=None):</span><br><span class="line">        self.title = title</span><br><span class="line">        self.year = year</span><br></pre></td></tr></table></figure></p><ul><li>ORM的model类通过继承declarative_base进行定义，通过<code>__tablename__</code>绑定到对应的table</li><li>每一个Column属性为表中的一列，需要设置类型，类型必须要与数据库中列的类型对应，常用类型有Integer，Float， String（对应varchar），Text</li><li>必须设置一个属性/列为<code>primary_key</code></li><li>可以通过<code>Base.metadata.create_all(engine)</code>创建table</li></ul><h2 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h2><p>数据使用ORM进行操作，操作的基本单位为对象（也可以直接使用sql语句，但对于常用操作来说没有必要）。除查询外，对数据库有修改的操作都需要commit事务</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 = Movie(&quot;Star Trek&quot;, 2009)</span><br><span class="line">session.add(m1)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><ol><li>创建待插入的对象，添加相应的数据属性</li><li>添加进session中</li><li>提交session，提交事务</li></ol><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movies = session.query(Movie).all() # 获取所有数据</span><br><span class="line">movie = session.query(Movie).get(movie_id) # 获取单个记录</span><br><span class="line">filter_movie = session.query(Movie).filter(Movie.id == 1).one()</span><br></pre></td></tr></table></figure><ul><li>查询中query的参数为查询的table/返回的对象</li><li>filter等于where语句，可以对查询结果进行进一步筛选，one返回唯一行，all则返回所有行</li></ul><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>查询出来的数据，修改属性后重新提交事务即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">movie.year = 1999</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie = session.query(Movie).get(id)</span><br><span class="line">session.delete()</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><h2 id="some-problems"><a href="#some-problems" class="headerlink" title="some problems"></a>some problems</h2><h3 id="大批量数据插入"><a href="#大批量数据插入" class="headerlink" title="大批量数据插入"></a>大批量数据插入</h3><p>在使用的过程中，遇到一次需要插入三十多万条数据到数据库的情况。在此之前，我一直都是插完数据再一起commit的（几千/几百条），因为每次commit需要写入数据库，会比较慢（磁盘IO制约）。<br>但这次数量过多的话，提交的时候出现错误，提示mysql的连接丢失。估计是写入的时间太多，时间太长超出了其限制，进而断开了连接。于是我选择批量commit，在添加一定数量数据后提交一次（5000/1000/500/100/10），但是没有成功，插入一定量的记录后，提示某一条插入的记录的某一列过长（尽管我那一列是不限长度的Text），显然有问题。<br>上网搜索批量数据插入的方法，但内容基本都是千篇一律，全部都是转载/翻译StackOverflow上的一篇<a href="https://stackoverflow.com/questions/3659142/bulk-insert-with-sqlalchemy-orm" target="_blank" rel="noopener">回答</a>。给出了两种方法</p><ul><li>bulk_save_objects(objects)</li><li>add_all()</li></ul><p>都没有效果，最终还是采取了逐条添加并提交的方法，虽然慢了点，但是能work。</p><p>写这件事只是为了吐槽一下现在用Google搜索一些具体的技术问题是，内容严重同质化的现象，大家都抄来抄去，转来转去。像这一次的搜索，最开始的source是在StackOverflow上的提问，然后有网站翻译成了中文并发布（甚至初创，然后就流传于各个中文网站了，一搜，全是这些内容相同的网页，属实恶心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。&lt;/p&gt;
&lt;p&gt;SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提供对数据库的常用操作：增删改查&lt;/li&gt;
&lt;li&gt;提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://scottyeung.club/categories/Mysql/"/>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="生产力" scheme="http://scottyeung.club/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
      <category term="sql" scheme="http://scottyeung.club/tags/sql/"/>
    
      <category term="Mysql" scheme="http://scottyeung.club/tags/Mysql/"/>
    
      <category term="SQLAlchemy" scheme="http://scottyeung.club/tags/SQLAlchemy/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Automate the Boring Stuff with Python</title>
    <link href="http://scottyeung.club/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/"/>
    <id>http://scottyeung.club/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/</id>
    <published>2019-11-04T08:15:25.000Z</published>
    <updated>2019-11-12T14:48:29.983Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://automatetheboringstuff.com/#toc" target="_blank" rel="noopener">本书</a>是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。</p><p>作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。</p><a id="more"></a><p>本书结构分为三部分：</p><ol><li>开头首先解释了为什么可以用编程提高效率以及为什么选择Python</li><li>Python的学习</li><li>Python在日常生活/工作的具体使用</li></ol><p>鉴于笔者已经学习过Python，故直接跳过前两部分，进行阅读记录。</p><h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><ul><li>程序运行时，数据可以存储变量中，但若想持久地存储数据，则需存储在文件中</li><li>文件的表示由路径+文件名组成</li><li>Windows系统路径使用\进行分隔 而Linux/Mac使用/，为确保代码能统一运行，可使用<code>os.path.join</code>进行连接路径</li><li><code>os.path.getsize</code>获取文件大小</li><li><code>os.listdir</code>获取文件夹内容</li><li>文件按内容可分为文本文件和二进制文件</li></ul><h3 id="读写"><a href="#读写" class="headerlink" title="读写"></a>读写</h3><ul><li>过程<ol><li><code>open(path, mode=&#39;r&#39;)</code>打开文件返回<code>File</code>对象</li><li>通过<code>read</code>或<code>write</code>对文件对象进行读写</li><li><code>close</code>关闭文件对象</li></ol></li><li>文件打开分为读(r)，写(w)，追加(a)</li><li>read以字符串形式返回整个文件内容，readline逐行返回</li><li>可通过<code>shelve</code>模块进行变量的读取和保存</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><h4 id="随机生成测试文件"><a href="#随机生成测试文件" class="headerlink" title="随机生成测试文件"></a>随机生成测试文件</h4><p>地理老师打算给35个学生出一份关于美国50个州对应的城市的选择题，目标形式为35个测试题文件，35个对应的答案文件，要求是35份选择题不一样，其中题目顺序不一样，选择题选项不一样。</p><ol><li>将测试数据以<code>dict</code>的形式存储在文件中/输入代码中</li><li>创建测试文件和答案文件，并写入首部信息</li><li>随机函数打乱数据给出的州的顺序，选出对应的城市，在给出的城市数据中删去正确答案，随机选出3个作为错误答案</li><li>将3中得到的州以及选项城市写入测试文件和答案文件</li></ol><h4 id="多重剪贴板"><a href="#多重剪贴板" class="headerlink" title="多重剪贴板"></a>多重剪贴板</h4><p>当需要多次进行复制粘贴时，下次的复制内容会把上一次的内容给覆盖，这样当需要重复使用复制内容时就很不方便。因此，实现多重剪贴板的功能，可以记录过往的复制内容，便于重复使用。</p><ol><li>每次运行程序时通过<code>shelve</code>读取本地的变量数据</li><li>根据输入的参数判断执行的功能</li><li>当需要记录剪贴板时，调用<code>pyperclip.paste</code>获取当前剪贴板内容，并存至变量</li><li>当需要展示历史剪贴板内容时，将存储的变量列表或单个变量转化为字符串通过<code>pyperclip.copy</code>复制进剪贴板</li></ol><h2 id="整理文件"><a href="#整理文件" class="headerlink" title="整理文件"></a>整理文件</h2><p>批量处理文件，包括遍历，复制，重命名，移动或压缩。主要使用<code>shutil</code>模块</p><ul><li>复制：<ul><li>shutil.copy </li><li>shutil.copytree </li></ul></li><li>移动：<ul><li>shutil.move</li></ul></li><li>删除<ul><li>os.unlink</li><li>os.rmdir 空目录</li><li>os.retree 目录所有</li></ul></li><li>遍历 os.walk 返回迭代器关于 current_folder,sub_folders,files</li><li>压缩 zipfile模块</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><h4 id="文件名字转换"><a href="#文件名字转换" class="headerlink" title="文件名字转换"></a>文件名字转换</h4><p>将数千个文件的名字中的美式时间<br>(MM-DD-YYYY)改为欧式时间<br> (DD-MM-YYYY)</p><ol><li>构造正则表达式用于识别时间</li><li>遍历目录的名字 <code>os.listdir</code>，并通过正则表达式进行识别，并将其分割</li><li>若满足正则表达式，则通过shutil.move改名</li></ol><p>相关任务</p><ul><li>批量文件名字添加前缀</li></ul><h4 id="文件夹压缩"><a href="#文件夹压缩" class="headerlink" title="文件夹压缩"></a>文件夹压缩</h4><p>将指定文件夹及其下所有文件和文件夹压缩</p><ol><li>寻找一可用不重复的压缩路径+文件名</li><li>创建压缩文件</li><li>遍历目录，将所有文件和文件夹写入压缩文件</li><li>关闭压缩文件</li></ol><h2 id="WEB爬取"><a href="#WEB爬取" class="headerlink" title="WEB爬取"></a>WEB爬取</h2><p>设计模块</p><ul><li>webbrowser<ul><li>open 打开网页</li></ul></li><li>request<ul><li>get 获取资源</li><li>raise_for_status 判断是否就绪</li><li>iter_content 获取内容的迭代器</li></ul></li><li>Beautiful Soup 解析HTML文档<ul><li>select</li></ul></li><li>Selenium</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><h4 id="批量打开网页"><a href="#批量打开网页" class="headerlink" title="批量打开网页"></a>批量打开网页</h4><p>根据给出的地址批量打开Google Map的网页</p><ol><li>根据给出的地址生成URL地址</li><li>使用<code>webbrowser.open</code>打开URL地址的网页</li></ol><h4 id="搜索关键词"><a href="#搜索关键词" class="headerlink" title="搜索关键词"></a>搜索关键词</h4><p>根据关键词进行google搜索，并将搜索结果的每一个页面打开</p><ol><li>根据关键词使用<code>request.get</code><br>请求搜索结果页面</li><li>使用Beautiful Soup解析页面，找出所有搜索结果的超链接</li><li>使用<code>webbrowser.open</code>打开获取的超链接</li></ol><p>类似用途：</p><ul><li>打开购物页面所有商品的页面</li><li>打开商品的所有评价页面</li><li>获取搜索图片的所有结果</li></ul><h4 id="下载网页漫画"><a href="#下载网页漫画" class="headerlink" title="下载网页漫画"></a>下载网页漫画</h4><p>下载XKCD的漫画，下载完后下载上一页，直至下载完第一页后结束</p><ol><li>获取XKCD的网页，抽取漫画部分写入文件</li><li>找到上一页按钮的超链接，并获取上一页的漫画网页</li><li>重复1-2直至找不到上一页按钮</li></ol><h2 id="操作Excel"><a href="#操作Excel" class="headerlink" title="操作Excel"></a>操作Excel</h2><p>利用第三方模块<code>openpyxl</code>，进行excel文件的读写</p><ul><li>load_workbook</li><li>get_sheet_by_name</li><li>cell(row=1, column=2)</li><li>save</li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h3><h4 id="读取Excel并统计数据"><a href="#读取Excel并统计数据" class="headerlink" title="读取Excel并统计数据"></a>读取Excel并统计数据</h4><p>根据Excel文件的数据，进行聚类分析，分别进行聚类计数以及聚类求和。<br>事实上，Excel本身功能即可完成并且更加简单，故跳过。</p><h4 id="更新Excel文件中指定列"><a href="#更新Excel文件中指定列" class="headerlink" title="更新Excel文件中指定列"></a>更新Excel文件中指定列</h4><p>读取Excel文件，遍历每一行，如果该行为指定商品，则修改其价格</p><h2 id="操作PDF"><a href="#操作PDF" class="headerlink" title="操作PDF"></a>操作PDF</h2><ul><li>打开PDF文件并提取文本</li><li>PDF文档解密——输入密码</li><li>文档加密</li><li>创建pdf文件，添加页面</li><li>pdf页面合并——添加水印</li></ul><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h3><h4 id="多个PDF文档指定页面合并"><a href="#多个PDF文档指定页面合并" class="headerlink" title="多个PDF文档指定页面合并"></a>多个PDF文档指定页面合并</h4><p>选择目录下所有PDF文档的非首页按照字典序合并到一个新的PDF文档中</p><ol><li>获取当前目录所有文件名，并取出以.pdf结尾的文件名添加至数组</li><li>数组根据文件名排序</li><li>按顺序打开每一个PDF文档，每一个文档读取从第二页开始读取，添加至新文档</li><li>保存新文档</li></ol><h2 id="操作CSV和JSON"><a href="#操作CSV和JSON" class="headerlink" title="操作CSV和JSON"></a>操作CSV和JSON</h2><h3 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h3><p>通过csv模块，可以进行csv的读写。读取类似于一个二维数组，写可以通过write_row写入行。</p><h4 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a>实例</h4><p>读取目录下所有csv文件的数据，去除首部信息</p><ol><li>获取目录所有文件名，并进行遍历，非csv文件跳过</li><li>打开csv文件，读取csv数据，跳过第一行，其余的行添加进数组</li><li>将数组中的行以csv方式写入新文件</li></ol><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><p>Json为常用的一个数据格式，多用于API之间进行交互，但日常生活中用得比较少。通过json模块，可以将json格式的字符串转成dict。</p><h4 id="获取实时天气数据"><a href="#获取实时天气数据" class="headerlink" title="获取实时天气数据"></a>获取实时天气数据</h4><p>通过网上提过的天气服务接口，获取指定地点的实时天气情况</p><ol><li>通过命令行获取地点输入</li><li>将地点作为参数向指定天气服务API发送HTTP请求</li><li>解析返回的json数据，进行输出</li></ol><h2 id="操作Email"><a href="#操作Email" class="headerlink" title="操作Email"></a>操作Email</h2><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a>实例</h3><p>根据Excel表格中的会员数据情况，给其中尚未支付本月会籍费用的会员发送邮件进行提醒</p><ol><li>打开Excel文件读取会员数据，判断最后一列是否为paid，若是，则记录会员名与邮箱地址</li><li>通过模块smtplib登录邮箱，跟根据上一步记录的信息一一发送邮件</li></ol><h2 id="自动化操作鼠标和键盘"><a href="#自动化操作鼠标和键盘" class="headerlink" title="自动化操作鼠标和键盘"></a>自动化操作鼠标和键盘</h2><p>通过第三方模块pyautogui实现，可进行图形界面的相关操作：</p><ul><li>控制鼠标以指定速度移动</li><li>获取鼠标位置</li><li>鼠标进行交互操作<ul><li>点击</li><li>拖动</li><li>滚动</li></ul></li><li>截屏</li><li>图像识别</li><li>键盘按下/松开 指定键/组合键</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://automatetheboringstuff.com/#toc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本书&lt;/a&gt;是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。&lt;/p&gt;
&lt;p&gt;作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
      <category term="自动化" scheme="http://scottyeung.club/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="编程学习" scheme="http://scottyeung.club/tags/%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
      <category term="生产力" scheme="http://scottyeung.club/tags/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>summary of &lt;斯坦福高效睡眠法&gt;</title>
    <link href="http://scottyeung.club/2019/summary-of-%E6%96%AF%E5%9D%A6%E7%A6%8F%E9%AB%98%E6%95%88%E7%9D%A1%E7%9C%A0%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/summary-of-斯坦福高效睡眠法/</id>
    <published>2019-10-28T04:06:02.000Z</published>
    <updated>2019-11-12T14:48:29.984Z</updated>
    
    <content type="html"><![CDATA[<h2 id="睡眠的质比量重要"><a href="#睡眠的质比量重要" class="headerlink" title="睡眠的质比量重要"></a>睡眠的质比量重要</h2><h3 id="睡眠的长短"><a href="#睡眠的长短" class="headerlink" title="睡眠的长短"></a>睡眠的长短</h3><ul><li>睡眠的时间长短由基因决定，过长过短均不好</li><li>睡眠时间过长也没什么用</li><li>睡眠时间过短会导致睡眠债务，会引发<ul><li>肥胖/糖尿病/高血压等等疾病</li><li>突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险</li><li>影响寿命</li></ul></li><li>睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间</li></ul><a id="more"></a><h3 id="睡眠的质量"><a href="#睡眠的质量" class="headerlink" title="睡眠的质量"></a>睡眠的质量</h3><ul><li>睡眠分为REM与非REM阶段，后者为深层睡眠</li><li>睡眠的质量取决于入睡后90分钟的非REM阶段</li><li>better than nothing：马上行动改变</li></ul><h2 id="睡眠的重要性"><a href="#睡眠的重要性" class="headerlink" title="睡眠的重要性"></a>睡眠的重要性</h2><ul><li>睡眠的作用<ol><li>让大脑和身体休息</li><li>整理记忆</li><li>调节激素平衡</li><li>提高免疫力</li><li>排出大脑废弃物</li></ol></li><li>睡眠质量的认知<ul><li>失眠不只是睡的量的问题，更是质的问题</li><li>睡眠障碍（呼吸暂停）——腹式呼吸帮助</li></ul></li></ul><h2 id="睡眠法则"><a href="#睡眠法则" class="headerlink" title="睡眠法则"></a>睡眠法则</h2><ul><li>困了就睡</li><li>保证睡眠前90分钟的黄金时间<ul><li>尽快入睡进入深层睡眠</li><li>不被打扰</li></ul></li><li>体温开关：降低体表温度，缩小体表与体内温差</li><li>大脑开关：创造一个良好的睡眠环境，以营造一个睡眠的仪式感</li></ul><h2 id="高效睡眠法"><a href="#高效睡眠法" class="headerlink" title="高效睡眠法"></a>高效睡眠法</h2><ul><li>体温开关：营造体温下降这一过程，帮助入睡，具体一般为睡前先提高温度，再自然下降<ul><li>洗澡</li><li>足浴</li><li>调节室温</li></ul></li><li>脑部开关：切换到要睡觉的状态，大脑放空<ul><li>单调</li><li>数羊</li></ul></li><li>睡眠禁区：平常睡觉时间前两小时不想睡觉<ul><li>导致睡眠时间挪前难，一般只能一小时</li><li>需要早起时也不要强行早睡</li></ul></li></ul><h2 id="清醒战略"><a href="#清醒战略" class="headerlink" title="清醒战略"></a>清醒战略</h2><ul><li>清醒开关<ul><li>光：光遏制褪黑素 清醒 太阳光</li><li>体温：清醒时体温上升</li></ul></li><li>具体战略<ul><li>两个闹钟设在起床时间前后20-40分钟，避开在深度睡眠醒来</li><li>远离睡眠诱惑因素</li><li>光脚</li><li>冷水洗手</li><li>咀嚼</li><li>咖啡因</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;睡眠的质比量重要&quot;&gt;&lt;a href=&quot;#睡眠的质比量重要&quot; class=&quot;headerlink&quot; title=&quot;睡眠的质比量重要&quot;&gt;&lt;/a&gt;睡眠的质比量重要&lt;/h2&gt;&lt;h3 id=&quot;睡眠的长短&quot;&gt;&lt;a href=&quot;#睡眠的长短&quot; class=&quot;headerlink&quot; title=&quot;睡眠的长短&quot;&gt;&lt;/a&gt;睡眠的长短&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;睡眠的时间长短由基因决定，过长过短均不好&lt;/li&gt;
&lt;li&gt;睡眠时间过长也没什么用&lt;/li&gt;
&lt;li&gt;睡眠时间过短会导致睡眠债务，会引发&lt;ul&gt;
&lt;li&gt;肥胖/糖尿病/高血压等等疾病&lt;/li&gt;
&lt;li&gt;突发出现瞬间睡眠：突然走神进入睡眠状态若干秒，非常危险&lt;/li&gt;
&lt;li&gt;影响寿命&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;睡眠债务可以通过延长睡眠时间偿还，在坚持一段时间进行延长睡眠（睡过量的时间）后，睡眠的时间会回归正常，但需要很长时间&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="睡眠" scheme="http://scottyeung.club/tags/%E7%9D%A1%E7%9C%A0/"/>
    
      <category term="读书" scheme="http://scottyeung.club/tags/%E8%AF%BB%E4%B9%A6/"/>
    
      <category term="健康" scheme="http://scottyeung.club/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="生活质量" scheme="http://scottyeung.club/tags/%E7%94%9F%E6%B4%BB%E8%B4%A8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>如何克服过于在意别人想法的心理</title>
    <link href="http://scottyeung.club/2019/%E5%A6%82%E4%BD%95%E5%85%8B%E6%9C%8D%E8%BF%87%E4%BA%8E%E5%9C%A8%E6%84%8F%E5%88%AB%E4%BA%BA%E6%83%B3%E6%B3%95%E7%9A%84%E5%BF%83%E7%90%86/"/>
    <id>http://scottyeung.club/2019/如何克服过于在意别人想法的心理/</id>
    <published>2019-10-23T01:24:35.000Z</published>
    <updated>2019-11-12T14:48:29.988Z</updated>
    
    <content type="html"><![CDATA[<p>这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。</p><a id="more"></a><h2 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h2><p>过于在意他人看法的人，往往：</p><ul><li>会以别人的评判标准来看待自己，试图以此满足他人期待</li><li>别人的评价对自己情绪影响很大</li><li>不知道也不会表达自己的需求</li><li>一定程度的讨好别人的倾向</li></ul><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><ol><li>害怕得罪别人<ul><li>害怕起冲突</li><li>害怕无法满足他人的期待</li></ul></li><li>自卑</li><li>敏感。心理承受能力差</li><li>将自己与他人对比</li><li>不能接纳自我。我们应该拥有无条件自尊，有条件的自尊只是在用一个找到的标准安慰自己<ul><li>依赖性自尊。依靠别人的评判标准</li><li>独立性自尊。按照自己的标准要求</li><li>无条件自尊。无条件完全接纳和尊重自己</li></ul></li><li>试图成为别人</li></ol><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><ol><li><p>别人没那么在乎你。<br>过于在意别人的想法本质上是自己将别人的想法看得太重要，把别人想法的后果看得太重要。因此，我们需要意识到，并没有多少人再关注你，对你有什么看法。不妨换位思考，看看你对他人是否有想法，有想法又能维持多久，他人对你的这个想法又有什么影响。他人的想法是没有任何实质性的影响，即使有，也是因为自己在意而产生影响。所以，我们需要<strong>不在意他人的看法</strong>，而一个重要的前提是：能够客观地分析自己的行为，有自己正确的看法。</p></li><li><p>明确自己才是最重要的。<br>活着本身是为了自己，如果不能够为了自己而活，那么你的一生相当于白过。所以，为了自己而活，我们完全有权利自私，完全可以把自己放在首位。</p></li><li><p>将自己的需求放在第一位，不必为了成全别人委屈自己。<br>接上上一条，因为自己是最重要的，顺带自己的需求也是最重要的。很多时候我们会因为外在的很多因素而受到制约，默默忍受。例如有些时候尽管很生气，也不敢表达出来，害怕伤害到别人，伤害到两者之间的关系，只能自己生闷气。但这种制约你行为的枷锁其实是无理的，别人不遵守你遵守，只能是自己吃亏。</p></li><li><p>不要害怕得罪别人。<br>不要总是充当老好人的角色，一直和和气气顺从别人，害怕得罪别人。要懂得接受这个事实，不会刻意去得罪别人，但也不怕得罪别人，即使无意得罪了别人，也不会担惊受怕，是我错，便承担，无错则置之不理，甚至反抗。</p></li><li><p>放弃成为更好的人这种幻想。<br>我们不必被世俗的要求所约束，好的，坏的都不是重要的，最重要的是，你想要的。</p><blockquote><p> 整个社会，整个人类世界都在推崇和鼓励你要去努力，要变得更好。<br>于是你开始对自己不满意，你开始讨厌自己，你开始强烈的不能接纳自己。<br>于是你开始自我否定，开始去追逐社会规定的那些优秀的定义，开始试图去迎合别人的看法，你因此变得很焦虑，你被对自己的不满和自己驱使着不断地向前走，你以为只要达成那些目标你就能轻松了，你就到达终点了，你就圆满了。<br>但是这一刻却始终不能到来，而你却一直被一种焦虑感控制和驱使着，这样你变得越来越着急，你觉得必须尽快到达那个终点，只有到达那个终点，只有变得更优秀了你才能不再这么焦虑，于是这种着急和焦虑会令你变得越来越浮躁，你会发现你离那些目标越来越远。<br>而有那么一些人即便是侥幸到达了他所自以为的那个终点，但到达的那一刻他却发现自己好像并没有体会到想象中的那种喜悦和满足，他也并没有放轻松，焦虑与痛苦始终还是如影随形。而他这个时候所体会到的很可能只是一种无边的空虚。</p></blockquote></li></ol><h2 id="行动"><a href="#行动" class="headerlink" title="行动"></a>行动</h2><ol><li><p>记录他人的想法，并且采取相应的行动。<br>既然在意他人的想法，不妨记录下来，并且逆着他的想法来做，而不是停止做这些事。让自己意识到，他的想法不能改变你的行为。你不想做某件事的理由只有两个：不想做；完成不了。</p></li><li><p>尝试与他人起冲突，并且坚持自己的决定，不被说服。</p></li><li><p>尝试表达自己的需求</p><ul><li>自己想要什么/想做什么</li><li>自己的情感</li><li>拒绝别人</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天在分析自己做事情一直很怕被人看见的问题，得出的深层原因为自己很在意别人的想法。事实上，很在意别人想法和评价的这个现象，真的对我有着很多negative的影响，例如心里焦虑，对事情无信心等影响，遂将其当作近来需要克服的目标之一。在知乎看到一个很棒的相关回答，进行记录学习之。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.club/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
      <category term="心态" scheme="http://scottyeung.club/tags/%E5%BF%83%E6%80%81/"/>
    
      <category term="心理学" scheme="http://scottyeung.club/tags/%E5%BF%83%E7%90%86%E5%AD%A6/"/>
    
      <category term="overcome" scheme="http://scottyeung.club/tags/overcome/"/>
    
      <category term="他人评价" scheme="http://scottyeung.club/tags/%E4%BB%96%E4%BA%BA%E8%AF%84%E4%BB%B7/"/>
    
  </entry>
  
  <entry>
    <title>组会谈话启示录（一）</title>
    <link href="http://scottyeung.club/2019/%E7%BB%84%E4%BC%9A%E8%B0%88%E8%AF%9D%E5%90%AF%E7%A4%BA%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://scottyeung.club/2019/组会谈话启示录（一）/</id>
    <published>2019-10-16T07:50:35.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。</p><a id="more"></a><h2 id="About-Empirical-Study"><a href="#About-Empirical-Study" class="headerlink" title="About Empirical Study"></a>About Empirical Study</h2><ul><li>所谓的empirical study，其实就是对收集到的数据进行分析并report，关键是提出Research Question，类似于调查报告</li><li>基本流程为进行问题定义，范围局限，收集数据，分析数据，根据分析结果初步得出RQ/规律/特征，根据RQ重新修改/优化数据收集方式，report并回答RQ</li><li>非常适合新手进行科研入门，可通过此熟悉科研的流程</li><li>即使数据分析没有好的结果，如无规律/相关性，也可如实report成文</li><li>empirical study虽然简单，但是很重要<ul><li>科研入门</li><li>对assumption进行验证</li><li>后续的method/improvement需基于此</li><li>通过此进行数据收集</li></ul></li><li><p>虽然重要，但不能止于此</p><ul><li>实质性的东西？（report有什么用？</li><li>套路类似/方法雷同，难度递减</li></ul></li><li><p>how to start？在确定一个方向之后，拿出一张纸，依次写下研究的对象，定义，范围，数据收集/分析的方法/数据集，<strong>RQ</strong></p></li></ul><h2 id="About-Research"><a href="#About-Research" class="headerlink" title="About Research"></a>About Research</h2><ul><li>国外的PhD培养方案<ol><li>刚开始写一篇长篇的survey，借此了解当前该领域的研究背景/问题/方向</li><li>进行empirical study，收集数据，进行分析</li><li>利用前面的积累（数据，知识），进行creative的工作，如method/solution/improvement的提出或修改</li></ol></li><li>国内的现状则是大多数热衷于在3上面，一来就进行method上面的工作</li><li>国内博士的毕业情况还是要较好的，一般都能毕业（当然这个完全取决于导师<del>是否恶心</del></li></ul><hr><p>最后还是想吹一波现在的导师，真的感觉有一个好导师真是太重要了！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是组会结束之后的轻松时刻，本次组会由于人数较少，所以谈话内容也比较有针对性，收获颇大，但又由于只是干听，担心会很快忘却，遂打算重新回忆，记录下来，想到啥就写啥，通过输出进行再学习，同时，相信也能给刚踏上科研路的各位带来一点受益。&lt;/p&gt;
    
    </summary>
    
      <category term="科研" scheme="http://scottyeung.club/categories/%E7%A7%91%E7%A0%94/"/>
    
    
      <category term="summary" scheme="http://scottyeung.club/tags/summary/"/>
    
      <category term="科研" scheme="http://scottyeung.club/tags/%E7%A7%91%E7%A0%94/"/>
    
      <category term="paper" scheme="http://scottyeung.club/tags/paper/"/>
    
      <category term="经验" scheme="http://scottyeung.club/tags/%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Ultralearning</title>
    <link href="http://scottyeung.club/2019/Summary-of-Ultralearning/"/>
    <id>http://scottyeung.club/2019/Summary-of-Ultralearning/</id>
    <published>2019-10-15T12:51:31.000Z</published>
    <updated>2020-01-14T06:44:33.276Z</updated>
    
    <content type="html"><![CDATA[<p>本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：</p><blockquote><p>A <strong>strategy</strong> for acquiring skills and knowneledge that is both <strong>self-directed</strong> and <strong>intense</strong></p></blockquote><ul><li>strategy: 它是一种学习的策略（just a strategy而非必须</li><li>self-directed：自我导向性（自我安排/计划</li><li>intense：强度高的</li></ul><p>总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念</p><a id="more"></a><h2 id="Principle"><a href="#Principle" class="headerlink" title="Principle"></a>Principle</h2><p>纵观博主所遇到的各个ultralearner，是什么使他们在学习上取得如此成功呢？作者通过众多例子归纳出了具有指导作用的9条Principle，这也是全书的精华所在，解释了ultralearning所关联的重要性因素。</p><h3 id="1-meta-learning"><a href="#1-meta-learning" class="headerlink" title="1 meta-learning"></a>1 meta-learning</h3><p>从词根上来说，meta-可理解为元，meta-learning即元学习，类比于数据库中的mete-data，meta-data为描述数据的数据，meta-learning即为学习如何学习。此外，在书中的meta-learning还具有pre-learning的意思，即进行学习前进行的总体安排设计。</p><p>具体内容包括：</p><ul><li>如何高效地进行学习：学习能力的培养<ul><li>分析/搜索/计划</li><li>这个是最为总体也是最重要的内容，通用于所有项目</li></ul></li><li>所学知识的结构：组成/关系/规律</li><li>学习计划的设计/安排/执行</li><li>过往学习经历吸取经验</li></ul><p>针对具体的项目，meta-learning可以通过三个步骤开启</p><ol><li>why？ 仔细考虑为什么要学习这些内容？可考虑所学的目标是否符合下列因素之一<ul><li>利益/目标。所学的内容能给自身带来利益，如学习某技能能给自身带来提升机会/工资提升；或是能帮助自己达到某个目标，如通过考试/取得学位</li><li>兴趣爱好</li></ul></li><li>what？ 学习内容如何选择<ul><li>benchmarking。选择一个相近的基准作为自己的基准内容。如想进行CS相关的学习，可以找某些大学的CS学位的培养方案，选择一样的课程进行学习。这些内容可以来自网上/学校/专家/同辈</li><li>emphasize。选择感兴趣/重要的部分进行强化，增加比重</li><li>exclusive。相对不重要/不感兴趣的部分可以排除。</li></ul></li><li>how？ 进行学习计划的设计，主要考虑以下因素：<ul><li>学习内容选择。这里的内容指的是学习资源</li><li>目标。要学到一个什么程度</li><li>时间安排。</li></ul></li></ol><h3 id="2-Focus"><a href="#2-Focus" class="headerlink" title="2 Focus"></a>2 Focus</h3><p>专注，作为一种非常高效的状态，无论是在学习还是工作中，都是一个非常有用的工具。本章节主要从三个方面来讲专注：</p><ol><li>如何进入专注的状态？我们需要避免拖延。拖延主要来自于对即将开始需要专注事情的困难或带来的不适的恐惧和厌恶。因此，我们可以通过从事情的easy-part入手，到进入状态后再逐渐切换到困难部分。另外，我们可用采用5分钟原则，根据5分钟原则，无论事情多么困难，在5分钟之内都不会感到想要放弃，在5分钟之后，在通过减轻程度/切换目标来减缓不适感。</li><li>如何保持专注状态？<ul><li>进入<a href="https://en.wikipedia.org/wiki/Flow_(psychology" target="_blank" rel="noopener">flow状态</a>（但不必强求</li><li>避免干扰。<ul><li>环境/任务/mind</li><li>接受杂念，任其发展，观其起落</li></ul></li><li>时间。长度足以进入状态，但不能过度致使疲劳而低效</li></ul></li><li>如何优化？保持正确/creative while stuck</li></ol><p>除了把专注当作一个高效率的工具以外，我们也应当将其当作一种能力来锻炼。这种能力，最好是通过在日常的使用中进行锻炼，习惯专注，尽量专注。当无法专注时，不妨思考一下所处的状况；当无法进入专注时，可以尝试始于微处，从细微的地方入手开始。</p><h3 id="3-Directness"><a href="#3-Directness" class="headerlink" title="3 Directness"></a>3 Directness</h3><p>在定义中提到，ultralearning的其中一个特点，就是self-directed，所以很自然地，directness也是一个重要的指导原则。这个原则指导我们，学习需要有明确的导向性，学习的内容最好就是直接指向所需的目标。通俗来讲，就是learn-by-doing。若所学的是一门技能，那便直接上手尝试；若所学是一门用于交流的语言，则直接与他人交谈；而若目标是通过一门考试，则练习题/真题无疑是最好的工具。</p><p>为什么需要直接练习呢？最主要的原因是知识的迁移问题。通常来讲，不同的学习内容具有不用的应用上下文场景，这导致了知识在使用的过程中难以迁移，同一个知识点，在一个场景可能适用，但换一个场景，可能就毫无用处了。这也可以说是知识的局限性。因此，我们最好就是在一开始就面向目标学习。</p><p>这个指导原则说来简单，相信很多人都知道，并且觉得诧异：难道还会有人不是直接学习所需的目标内容吗？确实有。原因有二。一是间接学习大多更为简单，举个例子，像学习外语，本身的目的是为了和他人交流，那最直接的目标不应该是直接用外语和他人交流吗？但事实上，最多人选择的学习外语方法是背单词。原因无他，相比于用外语与他人交流所产生的不适感中，更多人愿意呆在背单词的舒适区中。二则是某些内容难以直接练习，或者找到练习的机会。如同外科医生对于手术的练习，他们基本都不能够通过实际的手术进行练习（这也是不被允许的），缺乏实际的练习机会，只能通过旁观和被指点的方式积累经验。</p><p>面对以上情况，书中给出了几个方法。</p><ol><li>基于项目进行学习。拿程序员为例，以做一个程序项目为目标，学一部分，做一部分。</li><li>构造沉浸式环境。语言学习/社区圈子交流</li><li>模拟。</li><li>overkill。到达极端/超出要求。</li></ol><h3 id="4-Drill"><a href="#4-Drill" class="headerlink" title="4 Drill"></a>4 Drill</h3><p>钻研。该原则指导我们在学习时应该有所侧重，侧重在明显影响学习速率的地方，例如技能的瓶颈区，最重要的地方，最困难的地方。当克服了这些部分，总体能有很大的提升。这个也算是一个比较显而易见的原则，我们的认知能力往往有所局限，无法兼顾所有部分，因而需要有所侧重地学习。钻研步骤可分成两步：首先需要寻找值得钻研的部分，我们可以通过分解与实验的方法找出最为重要/最为影响速率的部分；接着就是设计钻研的方案，有以下5个方法：</p><ol><li>时间片段练习。当所学习的内容能够按照时间划分成一个个片段，如某些技能（篮球的上篮动作），划分后重点练习某些片段。</li><li>认知资源偏重。如语言学习侧重在听说读写某一个方面。</li><li>复制。当只想练习某内容的其中一部分而另外部分仍需要完成时，可以复制他人的其它部分，自己只亲自动手，完成钻研部分。</li><li>放大镜。放大想重点钻研的部分的比重，增大投入的时间/精力。</li><li>前置学习。钻研部分的前置部分也好好学习。</li></ol><p>这个原则也与上一个原则——Directness对应上了，对于学习内容选择，我们先采用Directness选择了内容的总体，再进行分解，选择Drill部分，进行钻研，最后再组合起来。</p><h3 id="5-Retrieval"><a href="#5-Retrieval" class="headerlink" title="5 Retrieval"></a>5 Retrieval</h3><p>对于复习来说，相对于被动的阅读进行复习，抛开书本进行主动的回忆效果要好上很多。通过主动的回忆，我们可以对自己进行知识的测试，并且加深对所学知识的记忆和印象。大概的解释有三个：</p><ol><li>知识迁移。</li><li>反馈。</li><li>JOL(Judgement of Learning)。人们对自身学习情况难以正确地感知，判断自己学得怎么样了。</li></ol><p>至于如何练习这种主动的复习方法，书中给出以下途径：</p><ul><li>记忆卡片。</li><li>自由回忆。</li><li>以提问形式。</li><li>以挑战形式</li></ul><p>另外，书本还给出了若干相关的实验数据，告知我们主动回忆效果的一些因素，分别是：开始时间，不需要准备好才开始，时间太晚，知识容易忘却，时间太短，不如被动方法；难度，越难的内容，效果比被动方法更好</p><h3 id="6-Feedback"><a href="#6-Feedback" class="headerlink" title="6 Feedback"></a>6 Feedback</h3><p>学习过程中，需要适当地接受反馈。尽管接收反馈有时会让人感到不安与恐惧，但好的反馈能够给我们提供许多信息，包括表现评价，问题所在，改进建议，这些信息能够帮助我们更好地改进下一步的学习计划。</p><p>什么是好的反馈？</p><ol><li>能够提供有用的信息</li><li>正确的信息</li><li>能够被正确地接收，并能引起回应</li><li>有促进作用</li></ol><p>反馈的种类</p><ol><li>结果型反馈。只提供一个整体的结果，如成绩/评分</li><li>信息型反馈。提供了问题的定位</li><li>校正型反馈。提供了修改建议</li></ol><p>如何合理接收反馈/提高反馈的质量？</p><ol><li>忽略噪声</li><li>使结果不可预测（可通过提高难度实现</li><li>除了学习内容本身外，接受meta-learning的反馈（计划，日程安排，资源选择</li><li>营造一个高强度或沉浸式的环境</li></ol><h3 id="7-Retention"><a href="#7-Retention" class="headerlink" title="7 Retention"></a>7 Retention</h3><p>记忆在学习中也是一个很重要的部分，知识概念需要记忆，技能步骤也需要记忆，然而保持长久良好的记忆不是一个容易的事，原因在于每个人都无法避免的因素——遗忘。</p><p>遗忘主要有三个原因</p><ol><li>时间侵蚀记忆。时间越久，记忆越难以保存</li><li>记忆间干扰。新增记忆取代/冲突/混淆了旧记忆</li><li>记忆不可访问。虽然内容还记得，但找不到触发记忆的路径/因素</li></ol><p>因此，针对遗忘的原因，可以通过一些技巧来减少遗忘</p><ul><li>间距记忆。通过划分时间段和知识进行记忆，每次记忆部分，并时常进行重复。日常使用单词卡为一个典型的例子</li><li>步骤记忆。相对于纸面上的知识，需要实际动手的技能更难以忘却</li><li>over-learning。学多一点，学深一点</li><li>记忆术。通过专门的记忆方法进行记忆，如关键词法，联想法。但具有一定局限性，如适用范围较窄，回忆较费力</li></ul><h3 id="8-Intuition"><a href="#8-Intuition" class="headerlink" title="8 Intuition"></a>8 Intuition</h3><p>通过学习建立相关的直觉。所谓的直觉，可以理解为对于所遇到问题，能进行自动归纳分类，遇到新的问题时，能够自发地对问题进行分解/抓取核心/组合/联系，并且得出问题解决的范式。其中，对于概念，我们需要理解；对于问题，我们需要大量积累，并通过练习，总结，得出通用的解决模式。</p><p>帮助建立学习中的直觉方法有：</p><ol><li>增加难度。难度较大时更易于钻研。</li><li>通过证明来理解概念。</li><li>具体例子帮助理解与记忆。</li><li>多提问。dump问题也不应该避开。</li></ol><p>另外，我们还可以通过费曼技巧，帮助我们更好地理解/掌握。费曼技巧的核心，在于迫使自己以解释/教授的方式，进行知识的加工输出，一方面可以帮助自己更好地学习，另一方面也可检测自身的学习情况。具体的步骤为：</p><ol><li>选择一个概念/问题</li><li>对于概念，尝试以通俗的语言像一个没有基础的人讲解，并能够使其明白</li><li>对于问题，独立形成一个可行的解决方法</li></ol><h3 id="9-Experimentation"><a href="#9-Experimentation" class="headerlink" title="9 Experimentation"></a>9 Experimentation</h3><p>多做试验，ultralearning的过程是一个探索的过程，永远没有一个完全正确的方案，只有只为适合自己当前的方案，所以必须靠我们通过试验进行探索，验证哪个更好，更适合。具体试验的内容包括：资源，技巧，风格，已经水平层次。在学习的过程中，我们也需要一直保持着这种实验的心态，带着一种可成长的思维模式，而非一成不变的定式。</p><p>以下为一些在试验上面有所帮助的技巧：</p><ul><li>copy and create。最开始可以照搬他人的学习方案，并且根据自身情况适度修改</li><li>对比。不同方法/资源/条件/技巧的比较</li><li>添加新约束</li><li>混合</li><li>极端</li></ul><h2 id="How-to-Start-a-Ultralearning-Project"><a href="#How-to-Start-a-Ultralearning-Project" class="headerlink" title="How to Start a Ultralearning Project"></a>How to Start a Ultralearning Project</h2><ol><li>Research 搜集相关信息进行meta-learning<ul><li>将要学的目标领域及其范围</li><li>将要使用的资源</li><li>他人成功学习的方法规范标准借鉴</li><li>直接练习的活动</li><li>备份的学习资源及钻研部分</li></ul></li><li>计划时间 取决于自身时间安排/所学的预期程度/空闲时间等因素<ul><li>计划投入多少时间</li><li>计划投入什么时候的时间</li></ul></li><li>执行计划 在执行计划时时常用上述的指导原则向自己提问是否符合，并进行调整/优化</li><li>检查结果 分析计划及其结果，吸取经验</li><li>维持学习结果/进一步学习 为了不至于遗弃学习成果<ul><li>定期复习</li><li>重新学习</li><li>进一步学习</li></ul></li></ol><h2 id="ultralearnner的培养"><a href="#ultralearnner的培养" class="headerlink" title="ultralearnner的培养"></a>ultralearnner的培养</h2><p>本部分通过介绍波尔加三姐妹的例子来说明如何培养ultralearner。<br>因为暂时没有人要培养的缘故，所以没什么兴趣，遂只是简单地略读摘录了相关重点记录保存。</p><h3 id="Raise"><a href="#Raise" class="headerlink" title="Raise"></a>Raise</h3><ol><li>早开始。越早开始越好，儿童时大脑功能更好更适宜学习。</li><li>专注。可以有多种学习内容，但需有一个侧重点，并专注于侧重点。</li><li>寓教于玩。将学习/练习转化成游戏，增添兴趣与持久性。</li><li>正向强化。通过胜利、鼓励等方式给予正向强化。</li><li>拒绝强迫。强迫学习无用，需要引导进行学习。</li></ol><h3 id="Suggestion"><a href="#Suggestion" class="headerlink" title="Suggestion"></a>Suggestion</h3><ul><li>Inspiring Goal</li><li>Be Careful with competition</li><li>Make Learning a Priority</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是来自我非常欣赏的博主Scott Young的新书《Ultralearning》的读后总结，本书主要介绍了ultralearning的相关概念及方法原则。&lt;/p&gt;
&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h2&gt;&lt;p&gt;什么是ultraleaning？从单词上面来讲，就是ultra + learning，可以理解为超一般的学习。书中给出的定义为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A &lt;strong&gt;strategy&lt;/strong&gt; for acquiring skills and knowneledge that is both &lt;strong&gt;self-directed&lt;/strong&gt; and &lt;strong&gt;intense&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;strategy: 它是一种学习的策略（just a strategy而非必须&lt;/li&gt;
&lt;li&gt;self-directed：自我导向性（自我安排/计划&lt;/li&gt;
&lt;li&gt;intense：强度高的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来说，这个更像是一种学习方法观，天赋并非必须（当然有天赋必然会促使效果更好），每个人都能做到，并且通过此能够培养良好的学习方法/习惯/态度/观念&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.club/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="学习" scheme="http://scottyeung.club/tags/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="meta-learning" scheme="http://scottyeung.club/tags/meta-learning/"/>
    
      <category term="ultralearning" scheme="http://scottyeung.club/tags/ultralearning/"/>
    
      <category term="improvement" scheme="http://scottyeung.club/tags/improvement/"/>
    
      <category term="方法论" scheme="http://scottyeung.club/tags/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
      <category term="Scott H Young" scheme="http://scottyeung.club/tags/Scott-H-Young/"/>
    
  </entry>
  
  <entry>
    <title>保研之路</title>
    <link href="http://scottyeung.club/2019/%E4%BF%9D%E7%A0%94%E4%B9%8B%E8%B7%AF/"/>
    <id>http://scottyeung.club/2019/保研之路/</id>
    <published>2019-10-01T08:38:20.000Z</published>
    <updated>2020-01-14T07:23:40.792Z</updated>
    
    <content type="html"><![CDATA[<p>在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。</p><a id="more"></a><p><img src="/2019/保研之路/p1.JPG" alt="来自深夜的拟录取通知"></p><h2 id="开始阶段"><a href="#开始阶段" class="headerlink" title="开始阶段"></a>开始阶段</h2><p>最初诞生保研的想法是在大二上学期，那个时候我的一个同高中的直系学长刚好要保研到中科院软件所，在和他交谈时，我第一次接触到了保研这个概念，在此之前，我一直都是抱着早点跑去实习搬砖赚钱的想法的。后来我看到了学院的推免名单和细则出来后，我看好像主要还是看GPA，那些加分都比较无关紧要（在国软的细则里，一个奖项可能就加零点零零几或者零点几，还要在乘以一个百分之十，真的算是无关紧要）。结合我当时的绩点，以及刚进行的奖学金评比看到的成绩排名，觉得还是挺稳的，当时甚至还会时不时地幻想保研到哪个学校。不过还是没有下定很大的决心，内心还是想着就业的。<br>在这种背景下，似乎保研也不需要付出额外的力气来准备，继续保持当时的状态，继续好好学习，保持绩点就行了，同时，根据细则的要求，只看必修课的绩点，我还可以集中精力在必修课，可以减少在一些选修课的投入精力和时间。</p><h2 id="突生变化"><a href="#突生变化" class="headerlink" title="突生变化"></a>突生变化</h2><p>在大二下学期的时候，发生了一件挺突然的事情：我们学院（国际软件学院）和计算机学院合并了。在上学期的时候部分老师就在有意无意的放出风声，但是就是没有人给出一个确定的说法，我们也只是当一个谣言对待，然后最后就真合并了，而且最后也没有给出一个官方的说法。每次提起这件事，我的内心其实都有点不爽，不过结合在计院待的这一年来说，计院的行政也就是这样，无从吐槽。<br>合并了对保研有什么影响呢？首先推免细则变了，可能会按照计院的来执行；其次推免的名额可能会有变化；最后，换了一批行政人员，很可能使使事情变麻烦。当时我还挺天真的，心里想着改革不会也不应该影响到当前的学生。现在回看，当真是naive，<del>学校改革哪管学生死活</del>。抱着这种想法，我对保研的准备还是没什么变化，好好学习，好好准备必修课的考试，继续保持高绩点。<br>同时，在这一年了为了锻炼代码能力，尝试加入实验室/找老师做项目，但因为自身原因或老师原因，两次都无疾而终，甚至让我对实验室留下了一种不好的印象，对实验室有所抗拒，这导致了我在暑期实训时没有找老师进实验室，而选择跟学校实训。回顾这几次过程，大致可得出几个教训：</p><ol><li>机会是需要靠自己主动争取的。上面提到的几次机会都是我偶然看到的消息才去找的，这导致了可选择的选项不多，并且quit了之后就无事可做。</li><li>驱使你做选择的因素不应该是有无机会，更应该看机会是否适合，是否好。</li><li>好老师/好实验室的影响很大，同理如果不好，影响也很大。</li></ol><h2 id="关键阶段"><a href="#关键阶段" class="headerlink" title="关键阶段"></a>关键阶段</h2><p>进入大三之后，距离保研的夏令营就只剩不到一年时间，上学期可谓是关键阶段。在上学期，我把能修的课都修满了，提前就修完了专选课和公选课（但到了下学期还是有点担心部分学分而再修了额外的课）。那段时间可以说是最忙的时候了，几乎是满课，有时真的下午下课后吃完饭顶不住，回来需要睡上一觉，晚上再去上课。另外，为了丰富科研经历，我主动发了邮件给老师说要进实验室，那段经历也是挺可怕的，在此期间，我得了组会恐惧症，每次组会开始前我内心都很焦虑，一方面没做什么，而另一方面又要想怎么回复，导致每次组会结束后，我几乎都会去大吃大喝，缓解压力，最终也没有任何产出/收获。<br>另外，15级新的保研细则也出了，成绩计算还是只算必修课，但是变成了相对赋分，而加分也是，且增加了很多的加分项（如班干部任职，CCF认证等）。看到这个新的细则，内心有点慌，因为还没有任何加分，而在相对赋分的情况下，可以拉很多分（如绩点3.6+凭借加分第一名，3.5+第二名），但另一方面，保研名额似乎也变多了，最低裸绩点3.4都保上了。<br>最终，在大三上学期，除了把课程几乎修完以外，几乎没有任何收获。绩点也因为nc的暑期实训拉低了0.1，科研方面也没有任何产出，且没有后续了。</p><h2 id="最后冲刺"><a href="#最后冲刺" class="headerlink" title="最后冲刺"></a>最后冲刺</h2><p>到了大三下，课程基本不多，一周其实就两三天课，可谓是全力备战保研的时候了。在这个学期我因为担忧没有保研加分拿不到推免资格（其实是多余的焦虑），所以选择刷点加分。我选择的是CCF和全国大学生英语竞赛。前者我第一次近乎裸考就拿了270分，而300分就可以有加分。后者则是获奖比例高达80%。然而，前者出乎意料地翻车(<a href="http://scottyeung.club/2019/CCF-201903/">CCF-201903</a>)，后者则是在准备的时候就觉得自己已经没有希望了（虽然比例高，但基数小，参加的人都太厉害了），最终也没有拿到任何加分。<br>除了准备加分，我还在准备专业课知识的复习。专业课知识大体分为两部分，一部分是比较硬的，看重能力的，如数学，算法，这些需要的时间比较长，不太能速成；另一部分则是偏概念，偏背诵的。这个学期开始，我就在学堂在线刷数据结构和线性代数，并在五月底前完成。进入五月，开始收集各个学校的夏令营消息并准备相应的材料。六月份确定参加的夏令营后则根据网上查询到的信息进行针对性的准备与学习，最终只参加了本校和南大计科的夏令营，北航和南大软院也进了，拒了，而七月中的时候收到了软件所软件中心的面试通知，也没去。本校夏令营没做什么准备就拿到了比较靠前的优秀营员名额，而南大夏令营相关情况<a href="http://scottyeung.club/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/">可点此查看</a>，开放日结束过几天就被老师告知考核通过，可录学硕。</p><h2 id="最终结果"><a href="#最终结果" class="headerlink" title="最终结果"></a>最终结果</h2><p>开放日结束后，还需要回学校搬砖，做一个微信小程序，不知道什么时候能走。但因为手里已经拿到一个比较满意的offer，内心也已经放轻松了，就没有做后续的准备，包括软件所的考核以及九推的准备。唯一有点烦的，就是这个实训不知道什么时候结束，组员都不想做，但是又还没出分，不敢造次，担心影响到GPA。最终这个工作一直持续到开学，幸好给分还行。<br>开学第一周周五就进行推免申请工作，最终没有任何加分，GPA 3.85+，排名11，然后今年形势也非常有趣，科研加分最高也才13分，导致3分加分就大于0.1绩点，就等于当一年班干部就涨了0.1绩点，反正我也不准备九推，其实与我无关。我最终的综排18，也算还行，然后今年的名额暴涨，最低好像裸绩点3.4+也保上研了。所以前面的焦虑好像是多余的？</p><h2 id="经验教训"><a href="#经验教训" class="headerlink" title="经验教训"></a>经验教训</h2><p>前面说了如此多无聊的流水账，下面就说一点有用的干货弥补一下吧。</p><ul><li>成绩很重要。某个学长说过，成绩决定下限，从我本人的申请情况以及推免名额的获取情况来看，的确如此。部分学校筛人直接就根据排名筛掉，没有成绩直接就没有后续，除非你其它方面（科研/竞赛）特别强，我去体检的时候碰到一个弘毅班的老哥就说他一开始就因为排名被南大计科筛了。</li><li>科研/竞赛要有但不用多。有奖项或论文产出固然是好，但没有也不要紧，因为有的只是少数人，但相关的经历还是需要有的，这在面试中可是一个回答利器，一方面可能面试官会直接发问，另一方面，也可以通过这些经历展示你的相关技能，研究能力和研究兴趣。这些经历可以通过进入实验室获得。</li><li>尽早研究推免细则，寻找加分机会。很多的加分其实获得难度是很低的，如软考，CCF或是当班干部，这些不仅难度不高，而且需要时间也不长，另外，参加竞赛或者大创，这就需要早一点准备了，但其实也不算难。像大创，找对老师指导就保底一个校级大创了。</li><li>做好信息收集。信息收集非常重要，保研不同于高考，每个人考完根据分数排名投志愿就录取了。信息的收集影响到你学校院系的选择，考核内容的准备，实验室导师的选择。</li><li>做好自身实力定位，不妄自菲薄。所谓的实力定位，主要是看自己的成绩，看自己在哪一档，然后根据此可以选择同档次学校或高一档的学校。要记住机会总是有可能有的，不妨海投试试。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在国庆前夕，保研的事情尘埃落定，最终被南大计科录取，将进入软件质量研究所，内心的失学焦虑才得以缓解大部分。在国家推免系统接受拟录取的时候，我与绝大多数保研党一样，内心异常兴奋，而到了第二天之后，这种兴奋已经变成了平静以及后续事情的焦虑。为了以后不至于忘却这一件重大的事，遂打算写下一篇流水账来回顾一下这段保研的历程，抒发一下相关的情感，另外也可作为后来人的一点经验和参考。大家可以当作故事来看看（主要是给自己看看），不想看的可以跳到最后看看经验。&lt;/p&gt;
    
    </summary>
    
      <category term="保研经验" scheme="http://scottyeung.club/categories/%E4%BF%9D%E7%A0%94%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="流水账" scheme="http://scottyeung.club/tags/%E6%B5%81%E6%B0%B4%E8%B4%A6/"/>
    
  </entry>
  
  <entry>
    <title>云计算与软件工程</title>
    <link href="http://scottyeung.club/2019/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    <id>http://scottyeung.club/2019/云计算与软件工程/</id>
    <published>2019-08-08T04:23:26.000Z</published>
    <updated>2019-11-12T14:48:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>想找点云计算的网课来看看，无意中发现了这个不错的mooc：<a href="http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about" target="_blank" rel="noopener">CS169.1X 云计算与软件工程</a>。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。</p><a id="more"></a><p>如课程所讲，软件工程是一个需要终身学习的概念，这其实更应该是一个程序员的核心技能，但往往我们都对此忽视，往往注重于单一的技能的术，而忽视最根本的道，即使是软件工程专业课，也只是沦为简单的概念背诵。希望可以通过这个课程，这个笔记，时刻提醒自己勿忘核心。</p><h2 id="软件工程概论"><a href="#软件工程概论" class="headerlink" title="软件工程概论"></a>软件工程概论</h2><ul><li><p>SaaS: 软件即服务</p><ul><li>无需担心安装/环境配置</li><li>无需担心数据丢失</li><li>易于协作同样数据</li><li>中心化数据</li><li>统一硬件系统环境：兼容性</li><li>易于更新：中心化</li></ul></li><li><p>SOA：面向服务架构</p><ul><li>系统由能提供服务的独立模块组成，每个模块通过接口提供服务，模块间通过接口进行通信</li><li>设计时最先设计接口</li></ul></li><li><p>SaaS‘s Demand On infrastructure</p><ol><li>Communication: 服务可交互</li><li>Scalability：可扩展性（增加规模服务<ul><li>集群</li></ul></li><li>Dependability：可靠性</li></ol></li><li><p>软件质量</p><ul><li>遗留代码：遗留的功能可用的代码，质量差 不算失败</li><li>质量标准：可用/易于开发调试修改</li><li>测试<ul><li>检验与确认：do the thing right and do the right thing</li><li>黑盒测试与白盒测试</li><li>单元/模块/集成/系统测试</li><li>回归测试：测试修改部分</li><li>测试覆盖率：覆盖率高不等于测试好</li></ul></li></ul></li><li><p>生产力因素</p><ul><li>代码简洁<ul><li>代码简短易于阅读</li><li>抽象等级高：高级语言</li></ul></li><li>代码合成<ul><li>code by example</li></ul></li><li>复用<ul><li>复用函数</li><li>标准库</li><li>对象/类</li><li>设计模式</li></ul></li><li>自动化工具</li></ul></li></ul><h2 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h2><ul><li><p>plan-and-document</p><ul><li><p>模型</p><ul><li>瀑布模型</li><li>螺旋模型</li><li>RUP</li></ul></li><li><p>问题：</p><ul><li>需要强大的PM</li><li>沟通成本</li><li>文档驱动</li></ul></li></ul></li><li><p>敏捷开发</p><ul><li>四大宣言：个体协作/能用的软件/客户沟通/拥抱变化</li><li>极端编程：如果某个事是好的，则做到极致/最大化</li><li>测试驱动开发</li><li>行为驱动设计</li><li>Scrum开发<ul><li>team size</li><li>role：master PO</li><li>3个问题</li><li>解决冲突</li></ul></li></ul></li><li><p>结对编程</p><ul><li>driver</li><li>observer</li></ul></li></ul><h2 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h2><p>课程的核心内容为利用Rails on Ruby搭建SaaS服务，所以Ruby也是一个重点。因为个人而言，编程语言最好的学习方法还是动手去做，因而就没有记录笔记了。下面为一些可能会用到的链接和个人的一些见解。</p><h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>列举比较特别印象深刻的或者是其它没有的</p><ul><li>究极面向对象：一切变量皆对象，一切函数皆方法</li><li>诗歌式编程：因为调用均方法=&gt;可省略括号=&gt;像语句一样</li><li>字符串/正则良好支持</li><li>元编程与反射：<ul><li>元编程：编写代码的代码</li><li>反射：运行时动态获取对象属性方法</li><li><code>method_missing</code>当方法在类中未定义时，进入该方法</li></ul></li><li>函数式编程</li><li>duck-typing:  能响应相同方法的被视作相同的类<ul><li>Module：为实现特定方法的实例提供相应的方法</li></ul></li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><ul><li><p><a href="https://www.runoob.com/ruby/ruby-tutorial.html" target="_blank" rel="noopener">Ruby学习 菜鸟教程</a></p></li><li><p>课程编程作业</p><ol start="0"><li><p><a href>环境配置（待填坑</a> : 大坑！</p><ul><li>官方建议使用云端cloud9框架的IDE服务已被收归AWS并且停止原服务，使用还得绑定信用卡 </li><li>本地自行搭建的cloud9服务也无法按照官方仓库wiki配置方法进行配置</li><li>文档没有写清楚最重要的Ruby版本要求以及相关package的</li></ul></li><li><p><a href="https://github.com/yeung66/hw-ruby-intro" target="_blank" rel="noopener">hw-ruby-intro</a></p></li></ol></li></ul><h2 id="BDD和TDD"><a href="#BDD和TDD" class="headerlink" title="BDD和TDD"></a>BDD和TDD</h2><h3 id="BDD：行为驱动设计"><a href="#BDD：行为驱动设计" class="headerlink" title="BDD：行为驱动设计"></a>BDD：行为驱动设计</h3><ul><li>User Story：<ul><li>As role</li><li>to do what</li><li>So that achieve</li></ul></li><li>评价准则：SMART<ul><li>Specific &amp; Measurable：场景具体且易于测量/评价</li><li>Achievable：1轮迭代可实现</li><li>Relevant：具有实现价值</li><li>Timeboxed：具有时间界限</li></ul></li><li>流程：与用户交互生产user story card，并将其添加到待办项。根据优先级与难度选取用户故事进行实现</li><li>任务点数评价用户故事的难度，通常投票决定</li><li>使用Tracker可以追踪用户故事完成情况及开发速率</li></ul><h3 id="TDD：-测试驱动开发"><a href="#TDD：-测试驱动开发" class="headerlink" title="TDD： 测试驱动开发"></a>TDD： 测试驱动开发</h3><ul><li>FIRST原则：针对单元测试<ul><li>Fast</li><li>Independent</li><li>Repeatable</li><li>Self-Checking</li><li>Timely</li></ul></li><li>RSpec</li></ul><h2 id="SaaS应用结构"><a href="#SaaS应用结构" class="headerlink" title="SaaS应用结构"></a>SaaS应用结构</h2><ul><li>C/S结构</li><li>3层结构<ul><li>Web Server</li><li>App Server</li><li>Database<ul><li>ActiveRecord：model自己知道如何CRUD</li><li>DataMapper：通过mapper进行对象与数据库记录的映射</li></ul></li></ul></li><li>MVC<ul><li>view： template view | transform view</li><li>陷阱：fat controller/view</li></ul></li><li>RESTful</li></ul><h2 id="Rails"><a href="#Rails" class="headerlink" title="Rails"></a>Rails</h2><ul><li>MVC<ul><li>Model：ActionRecord</li><li>Controller：通过router转发到控制器</li><li>View：haml</li></ul></li><li>约定优于配置：符合约定不需配置文件，仅在不符合约定时配置文件</li><li>调试：RASP<ul><li>print</li><li>log</li><li>interactive</li></ul></li></ul><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><h3 id="质量度量"><a href="#质量度量" class="headerlink" title="质量度量"></a>质量度量</h3><ul><li>Code Smells</li><li>SOFA原则<ul><li>Short</li><li>One：代码只做一件事</li><li>Few Arguments</li><li>Abstract：抽象在同一等级</li><li>Reek工具可分析</li></ul></li><li>ABC评分：变量，分支，条件数量<ul><li>通过flog评分，超过20有问题</li></ul></li><li>通过路径数量评分</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;想找点云计算的网课来看看，无意中发现了这个不错的mooc：&lt;a href=&quot;http://www.xuetangx.com/courses/course-v1:BerkeleyX+CS169_1X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CS169.1X 云计算与软件工程&lt;/a&gt;。内容涵盖云计算概念，软件工程的相关理念，以及如何通过云计算满足软件工程的需求。遂打算深入学习一下，并做了如下笔记（持续更新）。&lt;/p&gt;
    
    </summary>
    
      <category term="课程笔记" scheme="http://scottyeung.club/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件工程" scheme="http://scottyeung.club/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="云计算" scheme="http://scottyeung.club/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>记2019南京大学计算机系开放日</title>
    <link href="http://scottyeung.club/2019/%E8%AE%B02019%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    <id>http://scottyeung.club/2019/记2019南京大学计算机系夏令营/</id>
    <published>2019-07-26T02:45:34.000Z</published>
    <updated>2020-01-14T07:30:13.148Z</updated>
    
    <content type="html"><![CDATA[<p>因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。</p><a id="more"></a><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>因为早早抱着保研的想法，在学期中段就有这复习专业课的计划了，大致复习了如下内容：</p><ul><li>数据结构（非常重要</li><li>离散数学</li><li>线性代数</li><li>概率论</li><li>操作系统</li><li>计组</li></ul><p>对于南大计算机系夏令营的准备，其实开始得比较晚，因为之前海投了挺多夏令营，而计算机系的开放日时间刚好夹在一堆夏令营之间，时间相冲，一开始是抱着放弃南大计算机系的夏令营的想法，然而其它夏令营要么没进，要么出得很晚，最终还是选择了南大计科。</p><p>南大的准备主要还是准备算法方面的机试，在六月份的时候把刘汝佳的<a href="https://book.douban.com/subject/25902102/" target="_blank" rel="noopener">紫书</a>过了一遍，并且在voj上把部分的题刷了一下（时间太短刷的其实不多），题单可以<a href="https://vjudge.net/article/45" target="_blank" rel="noopener">看此</a>。另外，在看完书后，每天都上voj找一两道题练练手感，主要是dp和dfs的题。根据往年的题目来看，题目难度大概在LeetCode中等，当然也有直接POJ的原题，如果时间充足找个题单把POJ刷刷还是不错的。</p><p>面试的准备，则是参营前几天随便准备了自我介绍，项目经历，兴趣爱好等面试常问话题，当时时间紧，其实都还没准备完，还想着机试完后再准备。</p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><p>开放日活动共三天</p><ol><li>上午报到，下午机试</li><li>面试。分成上下午两批，每批大概十个组，每组十多人</li><li>介绍参观+与老师交流</li></ol><p>其实就主要三个活动：机试，面试，找导师签字。</p><h2 id="机试"><a href="#机试" class="headerlink" title="机试"></a>机试</h2><p>机试的形式是OJ形式，两个小时，三道题，三百分，每道题十个测试样例，每个十分。<strong>机试非常重要！</strong> 这个在我从网上看到任何一个博客/经验帖里都这样说，甚至还有说面试只是走一个过场。<del>我联系的导师也是这样对我说的，面试给的分都差不多，而机试可能拉上百分。</del></p><p>可选择语言为C/C++ ， Java，提供的ide有Visual Studio和Eclipse。</p><h3 id="第一道题"><a href="#第一道题" class="headerlink" title="第一道题"></a>第一道题</h3><p>给一个不超过m(m&lt;=100)位的整数，从中移除k(k&lt;=m)位，使得剩下的整数最小。</p><p>当时的思路是每次移除最大的数字，然后有60分，但这个在后来做完其它题目回来重新想的时候已经发现有问题了，如对于<code>1032</code>，去掉3后显然没有去掉1小。当时考虑用dp重写，<code>dp(i,j)=min(10*dp(i-1,j)+num[i],dp(i-1,j-1))</code>,但没时间调试了。</p><p>现在搜索看到一个贪心的方法：每一步总是选择一个使剩下的数最小的数字删去，即按高位到低位的顺序搜索，若各位数字递增，则删除最后一个数字，否则删除第一个递减区间的首字符。具体链接为<a href="https://blog.csdn.net/C20190413/article/details/77368590" target="_blank" rel="noopener">C++贪心算法之最小新整数</a></p><h3 id="第二道题"><a href="#第二道题" class="headerlink" title="第二道题"></a>第二道题</h3><p>B个男孩，G个女孩，要求所有男孩女孩排成一队，连续的男孩个数不可以超过K个，有多少种排队方式</p><p>直接就DFS了，<code>dfs(b,g,k)</code></p><ul><li>当<code>b==B&amp;&amp;g==G</code>时，成功，计数</li><li>当<code>b&gt;B||g&gt;G||k&gt;K</code>时，失败，返回</li><li>否则两种递归<ul><li><code>dfs(b+1,g,k+1)</code></li><li><code>dfs(b,g+1,0)</code></li></ul></li></ul><p>最后超时，70分。当时已经很满意了，直接跳过放弃优化。</p><h3 id="第三道题"><a href="#第三道题" class="headerlink" title="第三道题"></a>第三道题</h3><p>给出一个二叉树的前序遍历序列和后序遍历序列，问可能的二叉树有多少种</p><p>也是dfs解决<code>dfs(preorder,postorder)</code>，直接AC了</p><ul><li>如果是叶子，返回1</li><li>找子树<ul><li>如果有两个子树，则返回子树的dfs乘积</li><li>如果只有一个子树，则返回2*子树的dfs</li></ul></li></ul><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>因为机试考得比较不错，加上前一晚准备时差不多是跟同房的同学吹了一晚水，面试准备得比较一般，晚上看了看英文wiki准备一下计算机学科相关话题，以及完善一下自我介绍与项目经历。</p><p>面试当天，探听到每个人的面试的形式基本一样，基本是自我介绍+专业/算法/项目问题+性格测试，而内容与难度则根据不同的组别可以有很大的差别，但感觉总体面试都不会为难学生，不会的问题老实说不会，也不会继续追问。本人的面试内容如下：</p><ul><li>中文自我介绍，没说时间</li><li>专业问题<ul><li>数据挖掘是统计还是概率</li><li>买桃问题：一个桃多少钱，三个桃核换一个桃，给定钱能有多少桃</li><li>立方体不借助工具怎么倒出一半水</li><li>最小生成树算法</li><li>单链表怎样在常数空间复杂度查有没有环</li></ul></li><li>项目相关<ul><li>聚类算法的结果是什么（第一个问题就踩雷，然后就没有后续了</li></ul></li><li>英语提问<ul><li>大学期间最感兴趣/擅长的课程</li></ul></li><li>性格相关<ul><li>喜欢跟什么样的人相处</li><li>遇到不好相处的人怎么办</li><li>遇到压力/挫折怎么办</li></ul></li></ul><p>面试时间规定是在十分钟内，但是这个基本都是由面试的老师来控制，我面试的时候没吃午餐+等了太久+有点紧张，我觉得发挥得挺一般的，有些能答出来的题都没答出来（那个单链表的题我还在LeetCode刷过，也没答出来，勉强给了个线性空间复杂度的解法），实在可惜。不过好像从最后的结果来看好像影响也不大？</p><h2 id="导师"><a href="#导师" class="headerlink" title="导师"></a>导师</h2><p>在挺早的时候，我院的一个老师帮忙宣传一个实验室时，我就发了简历给我联系的导师的实验室，然后在参加开放日之前几天，我又发了一封邮件联系，沟通得也不错。面试之后就找他聊一聊，顺带签字了。联系导师其实也不算难，我觉得不提前联系其实也是没什么问题，除去那些很热门的实验室和导师外，导师都还是很乐意为你签字。跟我一起去的同学，面试当天才联系导师签字，一气呵成。</p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li>住：本次学生的住宿分成两批，一个是就在计算机系楼旁的国际会议中心，另一个是步行三十分钟左右的中公汇悦酒店。两者规格差不多，远的就麻烦一点，有行李可以坐公车。</li><li>食：看往年的帖子都说是发饭卡，还可以到超市买东西，而今年则只有指定饭堂的五张饭票，每张饭票当15元使用，只能单次使用，有点麻烦。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为没有找到曾经参加南大计算机系夏令营的学长学姐（好像也没有去找过），参加夏令营前的准备基本都是靠着网上搜到的各种资料，通过看他人的经历与记录，了解夏令营相关考核的内容和侧重点，从而作出针对性的准备。说实话，从前人的博客记录中，我感到获益良多，在参加夏令营时，就想着也要记录一下，留作后人参考，这也可算是一种传承吧。&lt;/p&gt;
    
    </summary>
    
      <category term="保研" scheme="http://scottyeung.club/categories/%E4%BF%9D%E7%A0%94/"/>
    
    
      <category term="南京大学" scheme="http://scottyeung.club/tags/%E5%8D%97%E4%BA%AC%E5%A4%A7%E5%AD%A6/"/>
    
      <category term="计算机系" scheme="http://scottyeung.club/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB/"/>
    
      <category term="夏令营" scheme="http://scottyeung.club/tags/%E5%A4%8F%E4%BB%A4%E8%90%A5/"/>
    
      <category term="开放日" scheme="http://scottyeung.club/tags/%E5%BC%80%E6%94%BE%E6%97%A5/"/>
    
      <category term="算法" scheme="http://scottyeung.club/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>枚举排列</title>
    <link href="http://scottyeung.club/2019/%E6%9E%9A%E4%B8%BE%E6%8E%92%E5%88%97/"/>
    <id>http://scottyeung.club/2019/枚举排列/</id>
    <published>2019-07-03T02:21:44.000Z</published>
    <updated>2019-11-12T14:48:29.991Z</updated>
    
    <content type="html"><![CDATA[<p>如何按字典序从小到大输出前n个数的所有排列？</p><a id="more"></a><h2 id="递归调用"><a href="#递归调用" class="headerlink" title="递归调用"></a>递归调用</h2><p>将数字分成两部分：</p><ul><li>已确定前缀序列</li><li>待定元素</li></ul><p>每次移除一个待定元素添加到前缀序列末尾，进行下一次递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_permutation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>* A, <span class="keyword">int</span> cur)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == n) &#123; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//尝试在A[cur]中填各种整数i</span></span><br><span class="line">    <span class="keyword">int</span> ok = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cur; j++)</span><br><span class="line">        <span class="keyword">if</span>(A[j] == i) ok = <span class="number">0</span>; <span class="comment">//如果i已经在A[0]~A[cur-1]出现过，则不能再选</span></span><br><span class="line">        <span class="keyword">if</span>(ok) &#123;</span><br><span class="line">            A[cur] = i;</span><br><span class="line">            print_permutation(n, A, cur+<span class="number">1</span>); <span class="comment">//递归调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="直接生成"><a href="#直接生成" class="headerlink" title="直接生成"></a>直接生成</h2><p>该方法直接获取到排列序列</p><ol><li>将元素排序，记录初始序列。</li><li>将当前首元素记录。</li><li>每次将记录的元素右移1位（交换位置），生成一个排列</li><li>直到元素移到最右边，回到步骤2</li><li>当出现了初始序列时，排列生成完毕</li></ol><p>具体代码可以参照std标准库里面的方法<code>next_permutation</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt; //包含next_permutation</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, p[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;p[i]);</span><br><span class="line">        sort(p, p+n); <span class="comment">//排序，得到p的最小排列</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">"%d "</span>, p[i]); <span class="comment">//输出排列p</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">while</span>(next_permutation(p, p+n)); <span class="comment">//求下一个排列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何按字典序从小到大输出前n个数的所有排列？&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="排列组合" scheme="http://scottyeung.club/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://scottyeung.club/2019/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://scottyeung.club/2019/并查集/</id>
    <published>2019-06-19T03:59:22.000Z</published>
    <updated>2019-11-12T14:48:29.989Z</updated>
    
    <content type="html"><![CDATA[<p>在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。</p><p>有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作:</p><ul><li>Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。</li><li>Union：将两个子集合并成同一个集合。</li></ul><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>开数组记录每个元素的从属情况，find操作返回元素从属情况，union操作修改其中一个元素的从属情况，将其合并</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="最简单模板"><a href="#最简单模板" class="headerlink" title="最简单模板"></a>最简单模板</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">set</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i&lt;<span class="number">0</span>;i&lt;<span class="built_in">size</span>;i++) <span class="built_in">set</span>[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x==<span class="built_in">set</span>[x]?x:<span class="built_in">set</span>[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>[x] = y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的情况下没有任何优化，易退化成链状查询，查询复杂度到达$O(n)$</p><h3 id="优化模板"><a href="#优化模板" class="headerlink" title="优化模板"></a>优化模板</h3><p>添加路径压缩，减少查询时间</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span><span class="comment">//使用递归写find函数，同时有路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    a=x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">set</span>[a]!=a)<span class="comment">///循环方法查找前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        a=<span class="built_in">set</span>[a];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i=x,j;</span><br><span class="line">    <span class="keyword">while</span>(i!=a)<span class="comment">///路径压缩,修改历经的前导点</span></span><br><span class="line">    &#123;</span><br><span class="line">        j=<span class="built_in">set</span>[i];<span class="comment">///记录x的前导结点</span></span><br><span class="line">        <span class="built_in">set</span>[i]=a;<span class="comment">///将i的前导结点设置为r的根节点.</span></span><br><span class="line">        i=j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b;</span><br><span class="line">    a=Find(x);<span class="comment">///x的根节点为a</span></span><br><span class="line">    b=Find(y);<span class="comment">///y的根节点为b</span></span><br><span class="line">    <span class="keyword">if</span>(a!=b)<span class="comment">///如果a,b不是相同的根节点，则说明ab不是连通的</span></span><br><span class="line">    &#123;</span><br><span class="line">        pre[a]=b;<span class="comment">///将a,b连接，将a的前导点设置为b</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul><li>图的连通性问题：将所有节点合并邻接节点，判断是否属于同一集合</li><li>重复数据合并/关联<ul><li><a href="https://leetcode-cn.com/problems/accounts-merge/submissions/" target="_blank" rel="noopener">Leetcode 721 Accounts Merge</a>:</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在计算机科学中，并查集是一种树型的数据结构，用于处理一些不交集（Disjoint Sets）的合并及查询问题。&lt;/p&gt;
&lt;p&gt;有一个联合-查找算法（union-find algorithm）定义了两个用于此数据结构的操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Find：确定元素属于哪一个子集。它可以被用来确定两个元素是否属于同一子集。&lt;/li&gt;
&lt;li&gt;Union：将两个子集合并成同一个集合。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="集合" scheme="http://scottyeung.club/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Windows快捷键</title>
    <link href="http://scottyeung.club/2019/Windows%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://scottyeung.club/2019/Windows快捷键/</id>
    <published>2019-06-13T12:07:11.000Z</published>
    <updated>2019-11-12T14:48:29.984Z</updated>
    
    <content type="html"><![CDATA[<p>无意中在油管看到的快捷键集锦视频，有些还是挺有用的，遂记录之。</p><p>原视频<a href="https://www.youtube.com/watch?v=VeAK7Bv4F1o" target="_blank" rel="noopener">可点此</a></p><a id="more"></a><ul><li>打开新的虚拟桌面 <code>Win + Ctrl+ d</code></li><li>虚拟桌面切换 <code>Win + Ctrl + 方向键左/右</code></li><li>最小化所有应用并返回桌面 <code>Win + M</code></li><li>临时切回桌面 <code>Win + ,</code></li><li>最大化/最小化当前程序<code>Win + 方向键上/下</code></li><li>打开/收回任务栏中程序 <code>Win + 数字键</code></li><li>当前程序快速分屏 <code>Win + 方向键</code></li><li>查看所有程序 <code>Win + Tab</code> 或 <code>Win + Ctrl + Tab</code></li><li>任务管理器 <code>Ctrl +Shift +Esc</code></li><li>开启新的文件管理器 <code>Win + e</code></li><li>快速截图 <code>Win + PrintScreent</code></li><li>打开侧边栏 <code>Win + a</code></li><li>打开设置 <code>Win + i</code></li><li>快速锁电脑 <code>Win + l</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;无意中在油管看到的快捷键集锦视频，有些还是挺有用的，遂记录之。&lt;/p&gt;
&lt;p&gt;原视频&lt;a href=&quot;https://www.youtube.com/watch?v=VeAK7Bv4F1o&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;可点此&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.club/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="Windows" scheme="http://scottyeung.club/tags/Windows/"/>
    
      <category term="shortcut" scheme="http://scottyeung.club/tags/shortcut/"/>
    
  </entry>
  
  <entry>
    <title>如何减少焦虑</title>
    <link href="http://scottyeung.club/2019/%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E7%84%A6%E8%99%91/"/>
    <id>http://scottyeung.club/2019/如何减少焦虑/</id>
    <published>2019-06-07T09:20:09.000Z</published>
    <updated>2020-02-16T12:25:07.065Z</updated>
    
    <content type="html"><![CDATA[<p>在最近的公众号推送中看到的一篇Scott H. Young的关于减少焦虑的博文推送，感觉方法还不错，刚好这段时间常常因为保研的事情而感到焦虑，遂打算写一篇文章学习一下其中的方法。不过微信推送当中的中文翻译实在有一点让人摸不着头脑，遂上官网找了<a href="https://www.scotthyoung.com/blog/2019/05/14/worry-less/" target="_blank" rel="noopener">原文</a>重新阅读并进行记录。</p><a id="more"></a><p>每个人都会产生焦虑，如担心犯错，担心收到批评，担心事业失败，担心社交出现问题，可以说焦虑的类型有很多。大多数的时间中，焦虑只是存在于脑海中，可以被人为地忽视掉而不受其影响，但当焦虑程度过深之后，它便可能跳出你的脑海，影响到你的实际行动。所以，我们必需采取方法来减少焦虑。</p><h1 id="减轻焦虑"><a href="#减轻焦虑" class="headerlink" title="减轻焦虑"></a>减轻焦虑</h1><p>焦虑的消除并不复杂，但是却是一个顽固的问题，我们可能需要一遍又一遍的解决同样的问题，但是焦虑的问题很少会完全消失。</p><h2 id="旁观者心态"><a href="#旁观者心态" class="headerlink" title="旁观者心态"></a>旁观者心态</h2><p>对于我们脑海中的思想，我们通常会认为它就是我们自身的一部分，思想的出现，是我们创造的原因，并且思想也是我们可以控制的东西。但是，按照这种理论的话，当我们无法摆脱焦虑的时候，我们就很容易对自身的能力产生怀疑，感到焦虑，毕竟担心焦虑的出现和控制也是一种焦虑。</p><p>所以，我们可以以一种旁观者的心态来对待这些思想，任其发生，只将其当作一种感官体验，虽然思想是来自你的脑海内部，但也可将其当成来自外部世界感受到的感觉一样，通过这种旁观者的角度，便不会轻易纠结于想要控制焦虑这种想法，使得焦虑加深，相反，对其抱着一种漠视的旁观者心态，逐渐可对其置之不理，减轻其影响。</p><p>如何练习这种旁观者心态呢？冥想是一个很好的手段。冥想本身也是一种观察自身思想的过程。同时，这种心态也可以联系到佛学中的无我思想，本质可以归结为，对于过往经历过的每件事，回顾并能承认自己无法控制。（个人对于佛学基本没有了解，原文给出的<a href="https://en.wikipedia.org/wiki/Anatta" target="_blank" rel="noopener">维基链接</a>感兴趣可以了解一下）</p><h2 id="远离社交-社交媒体"><a href="#远离社交-社交媒体" class="headerlink" title="远离社交/社交媒体"></a>远离社交/社交媒体</h2><p>焦虑是可以传播的，只要有消息的传播，就可能导致焦虑的传播。本人觉得最为典型的例子是：考完试后，往往会有人聚在一起讨论试题与答案，然而大多数人对本次考试都有着自己的焦虑，例如某道题的做法或答案是否正确，他们或许企图通过对答案来获取他人的确认来消除焦虑，但实际上，往往无法如愿，焦虑却因此而传播：对方也会开始考虑这个问题自己的答案是否正确。</p><p>有了社交媒体后，消息传播就变得更为便捷，可谓是无处不在了。刚考完的考试，课程群里马上就有考试题目或给分等相关的讨论，看到群里讨论的一系列问题，你的内心很自然地会产生对刚刚考试的联想，从而引起焦虑。</p><p>所以，我们应该根据你的承受力，恢复力等相关状况，挑选你的合适的环境，远离那些会传播焦虑的环境。但非常可惜的是，虽然我们明知某些社交媒体环境会传播焦虑，但很多时候我们还是忍不住参与到其中。正如上面所说的课程群，虽然考前你就知道会有相应的讨论，考后你还是忍不住点进去。那怎么办呢？这就涉及到自制力的提高问题了。</p><h2 id="找到最为焦虑的问题并直面"><a href="#找到最为焦虑的问题并直面" class="headerlink" title="找到最为焦虑的问题并直面"></a>找到最为焦虑的问题并直面</h2><p>焦虑分为两种，一种是单一的，可能是因为过往的某次事件而引发，如说了不当的话；另外一种是持续的问题，会反反复复的地出现，如对于事业，学习的焦虑。</p><p>对于前者，随着时间的推移便会逐渐减轻，而后者的话，则必须直面问题，找到一个持久有效的解决方法，学习如何去面对该问题。</p><p>原文这一点讲得较为笼统，而且我也觉得是一个知易行难的方法，便不继续展开。</p><h2 id="停止试图解决焦虑"><a href="#停止试图解决焦虑" class="headerlink" title="停止试图解决焦虑"></a>停止试图解决焦虑</h2><p>当你感到焦虑时，你往往倾向于向他人寻求安慰，而他人面对你的焦虑情况时，往往也只能对你给予安慰。虽然这样短时间之内会让你感到更好，但从长远来看这会让事情变得更糟糕。使用安慰来回应焦虑的思维模式，实际上会通过负强化增强了这种焦虑的思维模式。</p><p>在心理学的理论中，焦虑是一种动机，具有明确的目标，焦虑是为了识别出威胁并形成解决方案。当你因为某件事情感到焦虑时，若他人的安慰使你暂时变好了，当再出现类似问题时，你便倾向于再次陷入焦虑来解决问题。所以，越解决焦虑，越容易在未来其它事情上引发焦虑。</p><p>此处给出了一个心理学家的建议：面对焦虑，抑制住解决问题的冲动，虽然这会使你焦虑更加严重，但因为没有形成解决方案，焦虑的思维模式被削弱了，当目标没有实现时，下次的回应便会减弱。</p><p>这个方法对我而言是一个挺有创新性的方法，个人感觉不错，值得学习。光看标题，还以为是类似方法一那一种忽视焦虑的方法。但其实不是，这个方法是从行为模式的角度出发，通过行为模式的效果反馈抑制行为模式的出现。通俗点说，就是让自己意识到焦虑无用后便不会焦虑，但这也使我想到一个问题：焦虑是为了发现问题解决问题，削弱了这种行为模式后，对于问题的感官敏锐性会否也相应下降，如果这种敏锐性随之下降的话，虽说不焦虑了，但是对问题也已经没有感觉，发现不了问题。不过还是值得去尝试该方法的。</p><h2 id="分析可行性而非合理性"><a href="#分析可行性而非合理性" class="headerlink" title="分析可行性而非合理性"></a>分析可行性而非合理性</h2><p>在陷入焦虑时，我们经常会通过试图将焦虑分类，找出合理的焦虑，忽视不合理的焦虑，从而减轻焦虑。但这事实上是不可行的，大多数的焦虑，都有其合理的基础，你的担心也不是一无是处，你会发现所有的焦虑似乎都是合理的，不可忽视。</p><p>所有，与其纠结于焦虑的可行性，不如切实地分析焦虑的源头问题，判断问题是否可行。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在最近的公众号推送中看到的一篇Scott H. Young的关于减少焦虑的博文推送，感觉方法还不错，刚好这段时间常常因为保研的事情而感到焦虑，遂打算写一篇文章学习一下其中的方法。不过微信推送当中的中文翻译实在有一点让人摸不着头脑，遂上官网找了&lt;a href=&quot;https://www.scotthyoung.com/blog/2019/05/14/worry-less/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文&lt;/a&gt;重新阅读并进行记录。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.club/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="状态调节" scheme="http://scottyeung.club/tags/%E7%8A%B6%E6%80%81%E8%B0%83%E8%8A%82/"/>
    
      <category term="焦虑" scheme="http://scottyeung.club/tags/%E7%84%A6%E8%99%91/"/>
    
      <category term="心理" scheme="http://scottyeung.club/tags/%E5%BF%83%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>C++ std::set</title>
    <link href="http://scottyeung.club/2019/C-std-set/"/>
    <id>http://scottyeung.club/2019/C-std-set/</id>
    <published>2019-05-21T04:40:46.000Z</published>
    <updated>2019-11-12T14:48:29.973Z</updated>
    
    <content type="html"><![CDATA[<p>集合作为一个比较重要的数据结构，具有不含重复元素的性质，在许多算法中实现去重操作时，都需要用到集合这个数据结构。在近来使用c++刷题，用集合踩过较多的坑以后，决定写篇东西记录一下标准库中的集合。</p><a id="more"></a><p>集合一般通过二分搜索树实现。集合内元素保持严格弱序性质</p><h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><ul><li>Associative：元素不是靠决定位置访问的</li><li>Ordered：容器内元素保持严格顺序</li><li>Set：元素的值通过元素的键标识</li><li>Unique keys：元素没有相同的键</li></ul><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>集合的初始化有两种形式</p><ol><li>直接给出模板类型初始化集合<code>set&lt;template&gt; s;</code></li><li><p>给出模板类型以及比较对象</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">template</span>,Compare&gt; s;</span><br></pre></td></tr></table></figure><p> 其中Compare类为谓词类，需重载<code>()</code>运算符，在其中判断元素顺序</p></li></ol><p>对于基本类型而言，方法1足以解决一起，但是对于自定义结构体，则需进行额外的工作，以帮助集合组织元素以及判断元素是否相同。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>额外的工作其实就是两个元素的比较，通过一下两种方式可以实现</p><ul><li>重载<code>&lt;</code>运算符</li><li>谓词类重载<code>()</code>运算符</li></ul><p>元素的比较需满足对于两个相等的元素a，b有<code>a&lt;b</code>和<code>b&lt;a</code>都不成立。以一个坐标点的结构体为例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Point &amp;p)<span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x==p.x?y&lt;p.y:x&lt;p.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="常用成员函数"><a href="#常用成员函数" class="headerlink" title="常用成员函数"></a>常用成员函数</h2><ul><li><code>insert(value)</code>:插入元素</li><li><code>find(value)</code>：查找元素并返回迭代器,不存在时返回<code>set::end</code></li><li><code>erase</code>:取出迭代器位置元素/某值元素</li><li><code>count</code>：返回某元素的数量</li><li><code>empty/size</code>：判断元素数量是否为0/返回元素数量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;集合作为一个比较重要的数据结构，具有不含重复元素的性质，在许多算法中实现去重操作时，都需要用到集合这个数据结构。在近来使用c++刷题，用集合踩过较多的坑以后，决定写篇东西记录一下标准库中的集合。&lt;/p&gt;
    
    </summary>
    
      <category term="C++" scheme="http://scottyeung.club/categories/C/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="std" scheme="http://scottyeung.club/tags/std/"/>
    
  </entry>
  
  <entry>
    <title>判断二分图</title>
    <link href="http://scottyeung.club/2019/%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/"/>
    <id>http://scottyeung.club/2019/判断二分图/</id>
    <published>2019-05-17T02:40:52.000Z</published>
    <updated>2019-11-12T14:48:29.987Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><p>给定一个无向图，判断这个图是否二分图。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><a id="more"></a><p>graph将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在0到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code>中不存在i，并且<code>graph[i]</code>中没有重复的值。</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><h2 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h2><ul><li>graph 的长度范围为 [1, 100]。</li><li>graph[i] 中的元素的范围为 [0, graph.length - 1]。</li><li>graph[i] 不会包含 i 或者有重复的值。</li><li>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。</li></ul><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>问题核心为如何判断一个图为二分图，似乎是在离散数学里面学过相关知识，但已经早已忘却。与二分图相关的资料可看<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E5%9B%BE" target="_blank" rel="noopener">维基百科</a>。</p><p>我们可以通过二分图测试，在线性时间内判断一个图是否二分图。具体思路为：深度优先进行图遍历，在遍历的过程中对图进行二染色，即给相邻节点染上不同的颜色，当发现二染色时后有相邻节点颜色相同，即可判断不是二分图。</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><ol><li>初始化染色数组。染色数组包含三种状态：未染色（-1），0，1。</li><li>每一个节点深度遍历。若该节点未染色则进行染色，递归地对相邻节点进行染色，当发现相邻节点染色与当前节点相同，返回<code>false</code></li></ol><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;colors,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> color = colors[i]==<span class="number">-1</span>?<span class="number">0</span>:colors[i];</span><br><span class="line">            <span class="comment">// if(colors[i]==-1)</span></span><br><span class="line">        <span class="keyword">auto</span> adjs = graph[i];</span><br><span class="line"></span><br><span class="line">        colors[i]=color;</span><br><span class="line">        <span class="keyword">bool</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> j=<span class="number">0</span>;j&lt;adjs.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(colors[adjs[j]]==color) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(colors[adjs[j]]==<span class="number">-1</span>) &#123;</span><br><span class="line">                colors[adjs[j]]=<span class="number">1</span>-color;</span><br><span class="line">                <span class="keyword">if</span>(!dfs(graph,colors,adjs[j])) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=graph.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; colors (n,<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(graph,colors,i)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;p&gt;给定一个无向图，判断这个图是否二分图。&lt;/p&gt;
&lt;p&gt;如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="C++" scheme="http://scottyeung.club/tags/C/"/>
    
      <category term="LeetCode" scheme="http://scottyeung.club/tags/LeetCode/"/>
    
      <category term="图论" scheme="http://scottyeung.club/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>异常检测</title>
    <link href="http://scottyeung.club/2019/%E2%80%9C%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B%E2%80%9D/"/>
    <id>http://scottyeung.club/2019/“异常检测”/</id>
    <published>2019-05-03T05:30:38.000Z</published>
    <updated>2019-11-12T14:48:29.985Z</updated>
    
    <content type="html"><![CDATA[<p>一般的异常检测问题为：对于给定的一系列样本，给出一个新的测试样本，判断该测试样本是否属于这系列已知样本/该样本是否异常样本。异常检测为无监督学习方法。</p><p>例如：对于一批正常的引擎，监测带有一系列的数据（散热，震动强度），对于一个新的引擎，测得相关的数据，判断其是否异常引擎。</p><a id="more"></a><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>利用统计学知识，建立数据分布模型，并用已知样本进行参数估计。然后利用分布模型继续概率估计。一般选择使用高斯分布。</p><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>单元高斯分布<br>$$p(x;\mu;\sigma)={1\over \sqrt{2\pi \sigma}}e^{(x-\mu)^2\over 2\sigma^2}$$</p><ul><li>$\mu$为平均值，影响分布的对称轴</li><li>$\sigma^2$为方差，影响图形的胖瘦</li></ul><h3 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h3><ul><li>$\mu = {1\over m}\sum_{i=1}^mx^{(i)}$</li><li>$\sigma^2= {1\over m}\sum_{i=1}^m(x^{(i)}-\mu)^2$</li></ul><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><ol><li>对于给定的训练集，从中选择能够反映出是否异常的特征</li><li>对于每一个特征，进行参数估计</li><li>得出模型$$p(x)=\prod_{j=1}^n p(x_j;\mu_j;\sigma_j)=\prod_{j=1}^n{1\over \sqrt{2\pi \sigma_j}}e^{(x-\mu_j)^2\over 2\sigma_j^2}$$</li><li>对于测试样本，如果$p(x)&lt;\varepsilon$,则为异常</li></ol><h2 id="选择特征"><a href="#选择特征" class="headerlink" title="选择特征"></a>选择特征</h2><ol><li>满足高斯分布，不满足的可以通过变形生成满足高斯分布的特征</li><li>由异常样本出发找特征</li><li>相关的特征可以构造新特征</li></ol><h1 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h1><p>同一般的机器学习，我们将样本分成训练集、CV集、测试集，其中训练集不含异常样本。</p><h2 id="评估指标"><a href="#评估指标" class="headerlink" title="评估指标"></a>评估指标</h2><p>因为样本为偏斜集（skewed class)，所以不能直接计算准确率，我们采用<br>$$F_1score={PR\over P+R}$$</p><ul><li>P:Precision 预测的准确率</li><li>R:Recall 召回率=真阳性/实际阳性</li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><p>因为其在测试时使用了带label的数据，类似于监督学习。</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><p>异常检测：</p><ul><li>异常样本数量很少，正常样本数量多</li><li>异常的类型很多</li><li>未来的异常类型不确定</li></ul></li><li><p>监督学习：</p><ul><li>正常异常样本都很多</li><li>异常样本数量足够多到能够了解异常样本是什么样的</li></ul></li></ul><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li>异常检测<ul><li>欺诈检测</li><li>制造业</li><li>监控设备</li></ul></li><li>监督学习<ul><li>垃圾邮件过滤</li><li>天气预测</li><li>癌症分类</li></ul></li></ul><h1 id="多元高斯分布"><a href="#多元高斯分布" class="headerlink" title="多元高斯分布"></a>多元高斯分布</h1><p>$$p(x;\mu;\Sigma)={1\over {(2\pi)^{n\over2} |\Sigma|^{1\over 2}}}e^{(x-\mu)^T\Sigma^{-1} (x-\mu)}$$</p><p>多元高斯分布可以直接得出特征之间的相关性</p><h2 id="对比-1"><a href="#对比-1" class="headerlink" title="对比"></a>对比</h2><ul><li>多元高斯分布可以直接得出特征之间的相关性</li><li>计算复杂</li><li>必须满足$m&gt;n$,且$\Sigma$可逆</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般的异常检测问题为：对于给定的一系列样本，给出一个新的测试样本，判断该测试样本是否属于这系列已知样本/该样本是否异常样本。异常检测为无监督学习方法。&lt;/p&gt;
&lt;p&gt;例如：对于一批正常的引擎，监测带有一系列的数据（散热，震动强度），对于一个新的引擎，测得相关的数据，判断其是否异常引擎。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://scottyeung.club/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>春秋古筮法</title>
    <link href="http://scottyeung.club/2019/%E6%98%A5%E7%A7%8B%E5%8F%A4%E7%AD%AE%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/春秋古筮法/</id>
    <published>2019-04-20T03:18:35.000Z</published>
    <updated>2019-11-12T14:48:29.990Z</updated>
    
    <content type="html"><![CDATA[<p>第一次接触春秋古筮法是在大二上名为中国术数文化的公选课上。当时因为需要按类别选课，不得不选择中国与全国类别的公选课，恰好一直以来都对玄学有着谜之兴趣，就选了这门公选课。当时十几周的课程，现在我的印象就剩下春秋古筮法了，最终也能叫有所收获？</p><p>到了寒假，不知为什么又重新想到了春秋古筮法，然而大体以及忘记了，在重新复习了相关的方法后，为了不至于忘却，我萌生了开发一个春秋古筮法占卜的应用，然后在这个学期里大概花了两个星期的时间，上线了WEB版本，<a href="http://divi.scottyeung.club:8080/" target="_blank" rel="noopener">点此可体验</a>（因为服务器没有备案，所以暂且不能直接上80端口）。在基本完成之后的现在，打算写点东西记录一下。</p><a id="more"></a><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在谈什么是古筮法之前，我们先来谈谈，是什么？</p><p>所谓的“占”，指的是解读兆象吉凶，也就是我们现在说的铁口直断的断。</p><p>据《周礼》记载，古代的占法主要有三项：占卜、占筮、占梦。占卜是通过灼烧龟壳得出兆象，占筮则是通过蓍草演算出卦象，占梦则是根据梦境来预测吉凶。然而其中的占卜和占梦的方法都已经失传，现在从周朝流传下来的占法就只有占筮，这就是流传下来的春秋古筮法</p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>传统的方法使用的是蓍草，在我们的实操中，使用纸牌也行（课堂上用的就是纸牌）</p><ol start="0"><li>初始选择49张纸牌</li><li>将其随意分成2堆</li><li>随意从1堆中拿出1张单独放置</li><li>两堆牌分别4张4张地数，记录余数，余数为0时记作4</li><li>将余数的牌取出来弃置</li><li>将两堆牌合并后，回到步骤1，合共重复3次</li><li>三次变化之后，牌数除以四，就得出9、8、7、6中的一个，此为一卦六爻中的一爻，分别是变爻阳爻，阴爻，阳爻，变爻阴爻。其中阳爻为<code>-</code>,阴爻为<code>--</code></li><li>上述步骤重复六次，分别得到六爻，此为卦象。卦象中爻的顺序自下到上</li></ol><p>每一爻需要3次变化，求出6爻共需要18次变化，此所谓“十有八变而成卦”。</p><h1 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h1><p>当得出卦象后，我们可以根据《周易》来断卦。周易共分为64节，每一节对应一个卦象，小节中包含卦义卦辞，及各爻爻辞。周易的卦象爻辞解释网上随处可以找到，这里就不直接给出。</p><p>根据卦象变卦数量情况，可分为：</p><ul><li>无变爻：看卦辞卦义</li><li>单变爻：看本卦变爻爻辞</li><li>三变爻：本卦和变卦的卦辞卦义</li><li>五变爻：变卦的卦辞卦义</li></ul><p>以上的规则都是古书里的春秋筮例中归纳出来的，并没有什么确定性的表述或规则，所以如果你问为什么要这样看，或者为什么不那样看，我不能回答你，估计也没有人能回答你。</p><h1 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>整个古筮法分为得出卦象，解卦两方面。<br>碍于变爻需要根据特定情况的分析，且找到的周易卦象解释了没有具体的爻辞解析，所以整个程序忽略的变爻，并直接使用卦象本身卦辞卦义作为解释。</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>卦象数据的来源为<a href="https://www.eee-learning.com/" target="_blank" rel="noopener">易学网</a>，感觉是一个非常专业而全面的易经学习网站。我使用爬虫爬取了64卦的卦文，运程分析等相关资料。</p><p>卦象的生成为六爻的随机生成组合。并根据相应的卦象返回相应的解读。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一次接触春秋古筮法是在大二上名为中国术数文化的公选课上。当时因为需要按类别选课，不得不选择中国与全国类别的公选课，恰好一直以来都对玄学有着谜之兴趣，就选了这门公选课。当时十几周的课程，现在我的印象就剩下春秋古筮法了，最终也能叫有所收获？&lt;/p&gt;
&lt;p&gt;到了寒假，不知为什么又重新想到了春秋古筮法，然而大体以及忘记了，在重新复习了相关的方法后，为了不至于忘却，我萌生了开发一个春秋古筮法占卜的应用，然后在这个学期里大概花了两个星期的时间，上线了WEB版本，&lt;a href=&quot;http://divi.scottyeung.club:8080/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此可体验&lt;/a&gt;（因为服务器没有备案，所以暂且不能直接上80端口）。在基本完成之后的现在，打算写点东西记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.club/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="玄学" scheme="http://scottyeung.club/tags/%E7%8E%84%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>CCF 201903</title>
    <link href="http://scottyeung.club/2019/CCF-201903/"/>
    <id>http://scottyeung.club/2019/CCF-201903/</id>
    <published>2019-04-18T03:34:47.000Z</published>
    <updated>2019-11-12T14:48:29.974Z</updated>
    
    <content type="html"><![CDATA[<p>最后一次的认证，事前准备了差不多一个月，都觉得没什么问题了，考的时候还做出了四道题，觉得三百分是稳的。然后一查成绩，居然比第一次基本没怎么准备还低（第一次270），不甘心，又无奈。</p><p>于是等到网上出了题后，把当时提交的题重新做一遍，提交一遍，重新看看问题在哪，写一写题解。也不是想要证明什么，只是觉得努力不应该被白费？<br>代码链接<a href="https://github.com/yeung66/codesAboutCCF/tree/master/201903" target="_blank" rel="noopener">点此</a><br><a id="more"></a></p><h2 id="小中大"><a href="#小中大" class="headerlink" title="小中大"></a>小中大</h2><p>题目为有序序列中找最大值，最小值和中位数，并按大到小的顺序输出。</p><p>非常简单，最大最小值直接按索引取值即可，中位数则需要根据个数的奇偶性判断要不要取均值。</p><p>然而，第一道题的输入样例就给错了，样例2的输入并不是有序的，这就引发了我一个非常关键的问题：最值怎么取？是根据他说的原本有序取两侧，还是取实际的最值？我当时想的是前者，这就又引发出了另一个问题，中位数可能比最大值大或者比最小值小，所以三者又做了额外的排序，耽误了一定的时间。</p><p>最后直到我第二题都差不多做完，才通知说题目有误，改了样例。而我上面的代码一样符合它的思路，只是做多了额外功夫，测试了一下新样例就完事了。</p><p>最后这题拿了100分</p><h2 id="二十四点"><a href="#二十四点" class="headerlink" title="二十四点"></a>二十四点</h2><p>题目为根据输入表达式判断结果是否等于24。</p><p>对于有着eval的Python的选手来说，非常简单，处理一下输入调用<code>eval</code>即可。考试时注意到除法为整除，而Python3已经将整除变为<code>//</code>所以先用replace替换一下除号即可。</p><p>然而这道题我拿了40分，考后提交发现运行错误。细看题，发现题目中给出的乘号居然是小写字母<code>x</code>来表示。为什么会发现不了？当时因为第一题题目本身有问题，耽误了一点时间，所以做得比较快，而且最关键的是，<strong>这一次全部题面都用了图片，包括输入样例！！！</strong>我们只能一个个手敲输入样例，因为是手敲样例的缘故，自己就直接先入为主当成*号了，发现不了看错题的情况，血崩。</p><p>发现问题后对乘法做一个处理，将x替换成*，问题解决，100分。</p><h2 id="损坏的RAID5"><a href="#损坏的RAID5" class="headerlink" title="损坏的RAID5"></a>损坏的RAID5</h2><p>麻烦模拟题</p><p>待续</p><h2 id="消息传递接口"><a href="#消息传递接口" class="headerlink" title="消息传递接口"></a>消息传递接口</h2><p>一个比较典型的死锁问题，感觉可以用信号量去解决。</p><p>当时跳了这道题没做，现在估计也不会去做。</p><h2 id="317号子任务"><a href="#317号子任务" class="headerlink" title="317号子任务"></a>317号子任务</h2><p>多源点最短路径问题</p><p>题目要求给出图中每一个点到k个特定类型的点的最短路径和。</p><p>对于图论题我一直都是抱着能拿分就拿分的态度，超时的话一般都不考虑，于是直接采用最为暴力直接的方法——弗洛伊德算法，直接求出多源点最短路径，复杂度为$O(n^3)$，求出后直接找每个点到特定点的距离，排序后取前k个求和即可。</p><p>考试时，这道题我得了0分，现在重新提交，显示运行超时。运行超时我并不感到意外，但是超时到连第一个样例都过不了？？？重新看数据规模，发现这里第一档的数据（30%的数据），点的规模就已经到了500，重新翻了翻以往的图论题，别的单源最短路径或者最小生成树的问题第一档数据规模一般都是$10$,今年因为放到了第五题，强行通过数据规模提高难度，也是醉了。但是即使如此，现在的模拟提交因为时间只有1秒超时，在考试的时候时间上限是10s，10s也不能跑完第一档的数据？很奇怪。</p><p>换用了C++重新写了一个C++版本的弗洛伊德算法，还是超时0分。上网搜了一下，相关题解只有<a href="https://www.cnblogs.com/brainm/p/10548893.html" target="_blank" rel="noopener">一个</a>，而且也是用弗洛伊德算法。将其直接复制提交，提示错误，这次不超时了，但是时间也接近界限了。一样的方法为什么它可以不超时？我一直贴近它的代码修改我的，可是我的代码还是一直超时，莫得办法。看它的代码，没有考虑重边和自环。修改后还是错误。暂时只能放弃。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最后一次的认证，事前准备了差不多一个月，都觉得没什么问题了，考的时候还做出了四道题，觉得三百分是稳的。然后一查成绩，居然比第一次基本没怎么准备还低（第一次270），不甘心，又无奈。&lt;/p&gt;
&lt;p&gt;于是等到网上出了题后，把当时提交的题重新做一遍，提交一遍，重新看看问题在哪，写一写题解。也不是想要证明什么，只是觉得努力不应该被白费？&lt;br&gt;代码链接&lt;a href=&quot;https://github.com/yeung66/codesAboutCCF/tree/master/201903&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点此&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>循环体中局部变量的小坑</title>
    <link href="http://scottyeung.club/2019/%E5%BE%AA%E7%8E%AF%E4%BD%93%E4%B8%AD%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%B0%8F%E5%9D%91/"/>
    <id>http://scottyeung.club/2019/循环体中局部变量的小坑/</id>
    <published>2019-04-12T11:37:42.000Z</published>
    <updated>2020-01-14T06:29:56.453Z</updated>
    
    <content type="html"><![CDATA[<p>前几晚看《The Go Progromming Language》时，在<a href="https://yar999.gitbooks.io/gopl-zh/content/ch5/ch5-06.html" target="_blank" rel="noopener">匿名函数</a>的最后一小节中，发现了一个比较有趣的小坑。<br>大概的场景为：首先创建一些目录，然后对于每一个目录，分别声明一个匿名函数删除目录，样例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rmdirs []<span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    os.MkdirAll(dir, <span class="number">0755</span>)</span><br><span class="line">    rmdirs = <span class="built_in">append</span>(rmdirs, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        os.RemoveAll(dir) </span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以先自行考虑一下，有没有什么问题，效果会是怎样</p><a id="more"></a><h1 id="警告：捕获迭代变量"><a href="#警告：捕获迭代变量" class="headerlink" title="警告：捕获迭代变量"></a>警告：捕获迭代变量</h1><blockquote><blockquote><p>（颇为中二的标题名字是从书上搬过来的</p></blockquote></blockquote><p>上面的代码是有问题的，运行后<code>rmdirs</code>中每一个函数的效果都是删除最后一个目录。</p><p>为什么没有出现我们预期的效果呢？原因在于循环变量的作用域。</p><blockquote><p>在上面的程序中，for循环语句引入了新的词法块，循环变量dir在这个词法块中被声明。在该循环中生成的所有函数值都共享相同的循环变量。需要注意，函数值中记录的是循环变量的内存地址，而不是循环变量某一时刻的值。以dir为例，后续的迭代会不断更新dir的值，当删除操作执行时，for循环已完成，dir中存储的值等于最后一次迭代的值。这意味着，每次对os.RemoveAll的调用删除的都是相同的目录。</p></blockquote><p>正确的代码应该如下修改，通过在块级中声明一个局部临时变量，将其代替循环变量放入匿名函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, dir := <span class="keyword">range</span> tempDirs() &#123;</span><br><span class="line">    dir := dir <span class="comment">// declares inner dir, initialized to outer dir</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这个修改是可行的？原因很简单，我们在匿名函数内部使用的是一个局部的临时变量，因为是临时的，块级代码结束时，变量地址指向内容很可能要回收，所以不能存储地址，只能够存储变量的值。<br>那为什么前者的代码匿名函数值中记录的就是变量的内存地址？循环变量不也属于这个词法块吗？还真不太一样。循环变量虽说也是由循环词法块被声明，但是相对于词法块内的代码，它实质上是一个全局变量的地位，它对于代码块的每一次执行都是一样的地位，一样的地址,所以实际存储的是变量的地址。</p><h1 id="JavaScript中的循环变量"><a href="#JavaScript中的循环变量" class="headerlink" title="JavaScript中的循环变量"></a>JavaScript中的循环变量</h1><p>当时看到书，我第一时间就想到了JavaScript中也有着同样的情况，我之前还遇到过类似的问题：给一系列的控件绑定事件触发函数，每个函数中根据循环变量设定条件，然后出现了相似的问题。当时采用的解决方法是提到了参数处理的，治标不治本。</p><p>看到这里后，我马上就用JavaScript复现了这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    arr.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">f</span>)=&gt;</span>&#123;f()&#125;)</span><br></pre></td></tr></table></figure><p>结果就如同预期一样，输出了5个4，没有达到预期。然后用跟在Go一样的思路，在循环体内部中使用一个临时局部变量代替，运行后出现预期效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = []</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">    <span class="keyword">let</span> j=i</span><br><span class="line">    arr.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;<span class="built_in">console</span>.log(j)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">arr.forEach(<span class="function">(<span class="params">f</span>)=&gt;</span>&#123;f()&#125;)</span><br></pre></td></tr></table></figure><p>注意到这里用的是<code>let</code>而不是<code>var</code>。使用 let 语句声明一个变量，该变量的范围限于声明它的块中。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前几晚看《The Go Progromming Language》时，在&lt;a href=&quot;https://yar999.gitbooks.io/gopl-zh/content/ch5/ch5-06.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;匿名函数&lt;/a&gt;的最后一小节中，发现了一个比较有趣的小坑。&lt;br&gt;大概的场景为：首先创建一些目录，然后对于每一个目录，分别声明一个匿名函数删除目录，样例代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; rmdirs []&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; _, dir := &lt;span class=&quot;keyword&quot;&gt;range&lt;/span&gt; tempDirs() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    os.MkdirAll(dir, &lt;span class=&quot;number&quot;&gt;0755&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rmdirs = &lt;span class=&quot;built_in&quot;&gt;append&lt;/span&gt;(rmdirs, &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        os.RemoveAll(dir) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;大家可以先自行考虑一下，有没有什么问题，效果会是怎样&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="http://scottyeung.club/categories/Go/"/>
    
    
      <category term="GO" scheme="http://scottyeung.club/tags/GO/"/>
    
      <category term="JavaScipt" scheme="http://scottyeung.club/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>图论常见题目及算法</title>
    <link href="http://scottyeung.club/2019/%E5%9B%BE%E8%AE%BA%E5%B8%B8%E8%A7%81%E9%A2%98%E7%9B%AE%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <id>http://scottyeung.club/2019/图论常见题目及算法/</id>
    <published>2019-03-14T13:00:07.000Z</published>
    <updated>2019-11-12T14:48:29.988Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>近来都在刷CCF的题，准备认证考试。最近几天开始刷其中的第四题，一般而言，CCF的第四题都是图论题。对于我这样之前没怎么刷题的人来说，图论题看上去就感觉很难，主要是感觉到很陌生，因为在实际的开发过程中比较少用到图这样的数据结构，都是线性的数据结构，连树都比较少用。</p><p>但是在刷得比较多的图论题后，发现其实图论题好像也就那么回事，也不是说简单，主要感觉来来去去都是考那几个东西，如果是没有接触过或者不会做的话，可能有点难，但是只要接触过相似的，直接套板子修改就行了（当然也有可能是我还接触的不够多XD），另外，就是感觉没有什么题是DFS/BFS不能破，只是会不会超时，能拿多少的分的问题（对于CCF认证只想拿300分而言，有几十分就够了），其实很多算法的核心也就是DFS与BFS。</p><p>所以在今晚刷完了CCF往年所有的第四题后，总结一下最近接触的图论问题及解法。</p><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先，在解决问题之前，我们要先做好图论输入的模拟，图可以分为有向无向，有无权值。一般是以邻接矩阵或者邻接表的形式表示。</p><ul><li>邻接矩阵 :<code>graph = [[INF/False for _ in range(n+1)] for _ in range(n+1)] #带权值或无权图</code></li><li>邻接表：<code>graph = [{}/[] for _ in range(n+1)] # 带权值或无权图</code></li></ul><p>一般来说，邻接矩阵表示比较简单，但是时间空间成本都比较高，选用邻接表比较好，不过在CCF的认证似乎差别不大（样例水</p><h1 id="问题及解法"><a href="#问题及解法" class="headerlink" title="问题及解法"></a>问题及解法</h1><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><ul><li><p>问题：给一个无向带权图，选取其中一定数量的边生成一个包含所有点的树，且权值最小</p></li><li><p>方法：</p><ul><li>Prim算法：优先队列+BFS 每次弹出距生成树距离最小的未加入生成树的点</li><li>Kruskal算法：边排序+并查集</li></ul></li><li><p>实例：</p><ol><li>最优灌溉</li><li>数据中心</li></ol></li></ul><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><ul><li>对于一个图，指定两点间的最短距离，或者是指定一点的最长路径长度</li><li><p>方法：</p><ul><li><p>迪杰斯特拉算法：优先队列 每次弹出到源点距离最小的点，并修改邻接的未确定点，记录确定情况</p></li><li><p>spfa：队列 将源点入队列，每次弹出点后，修改邻接的点的距离，若修改且未入队则加入队列，记录入队列情况</p></li><li><p>floyd算法：求多源最短路径问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,n+<span class="number">1</span>):</span><br><span class="line">            dis[i][j]=min(dis[i][j],dis[i][k]+dis[k][j])</span><br></pre></td></tr></table></figure></li></ul></li><li><p>变形：</p><ul><li>最短路径中对特殊点有数量限制：spfa中将数量记录放入队列 开二维dp数组</li><li>大路小路问题（小路的权值为连续小路权值的平方）：floyd算法生成新的小路边 开两个dp数组进行spfa</li></ul></li></ul><h2 id="强连通分量"><a href="#强连通分量" class="headerlink" title="强连通分量"></a>强连通分量</h2><ul><li><p>在有向图中，两个点互相可达称为强连通，任意两点均为强连通的子图称为强连通分量</p></li><li><p>方法：</p><ul><li><p>Tarjar算法：记录节点访问时间及最短时间，深度遍历邻接点并入栈，更新最短时间。当出现访问时间等于最短时间时，栈顶到该节点构成一个强连通分量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tarjan</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ans,time</span><br><span class="line">    time+=<span class="number">1</span></span><br><span class="line">    DNF[i]=LOW[i]=time</span><br><span class="line">    stack.append(i)</span><br><span class="line">    instack[i]=<span class="literal">True</span></span><br><span class="line">    visited[i]=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> edges[i]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> visited[j]:</span><br><span class="line">            tarjan(j)</span><br><span class="line">            LOW[i]=min(LOW[j],LOW[i])</span><br><span class="line">        <span class="keyword">elif</span> instack[j]:</span><br><span class="line">            LOW[i]=min(LOW[j],LOW[i])</span><br><span class="line">    <span class="keyword">if</span> DNF[i]==LOW[i]:</span><br><span class="line">        count=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            instack[node]=<span class="literal">False</span></span><br><span class="line">            </span><br><span class="line">            count+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> node==i:<span class="keyword">break</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>变形：</p><ul><li>如果只是求强连通的点的对数，也可直接每一个点分别BFS/DFS，确定单向可达性</li></ul></li></ul><h2 id="树的直径"><a href="#树的直径" class="headerlink" title="树的直径"></a>树的直径</h2><ul><li>在树中，任意两个叶子节点的最长路径为树的直径</li><li>方法：当成图两次BFS，第一次任一点开始，第二次由第一次结果开始</li><li>实例：<ul><li><a href="http://scottyeung.club/2019/03/14/CCF201503-4-%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6/">网络延时</a></li></ul></li></ul><h2 id="欧拉路径"><a href="#欧拉路径" class="headerlink" title="欧拉路径"></a>欧拉路径</h2><ul><li><p>一个图如果能从一个点出发，每条边都经过一次后回到起始点，则这个图为欧拉图，这个遍历的路径为欧拉路径</p></li><li><p>方法：</p><ol><li>检查连通性：并查集 find union 检测是否每一个点都属于同一集合</li><li>检查是否存在欧拉路径：每个点的度数均为偶数，或只有两个点度数为奇数且这两个点为起点终点</li><li>确定存在欧拉路径后，直接DFS遍历，记录访问过的边</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;近来都在刷CCF的题，准备认证考试。最近几天开始刷其中的第四题，一般而言，CCF的第四题都是图论题。对于我这样之前没怎么刷题的人来说，图论题看上去就感觉很难，主要是感觉到很陌生，因为在实际的开发过程中比较少用到图这样的数据结构，都是线性的数据结构，连树都比较少用。&lt;/p&gt;
&lt;p&gt;但是在刷得比较多的图论题后，发现其实图论题好像也就那么回事，也不是说简单，主要感觉来来去去都是考那几个东西，如果是没有接触过或者不会做的话，可能有点难，但是只要接触过相似的，直接套板子修改就行了（当然也有可能是我还接触的不够多XD），另外，就是感觉没有什么题是DFS/BFS不能破，只是会不会超时，能拿多少的分的问题（对于CCF认证只想拿300分而言，有几十分就够了），其实很多算法的核心也就是DFS与BFS。&lt;/p&gt;
&lt;p&gt;所以在今晚刷完了CCF往年所有的第四题后，总结一下最近接触的图论问题及解法。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="图论" scheme="http://scottyeung.club/tags/%E5%9B%BE%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CCF201503-4 网络延时</title>
    <link href="http://scottyeung.club/2019/CCF201503-4-%E7%BD%91%E7%BB%9C%E5%BB%B6%E6%97%B6/"/>
    <id>http://scottyeung.club/2019/CCF201503-4-网络延时/</id>
    <published>2019-03-14T10:35:19.000Z</published>
    <updated>2019-11-12T14:48:29.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一个公司的网络，由<em>n</em>台交换机和<em>m</em>台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。<br>　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含两个整数<em>n</em>, <em>m</em>，分别表示交换机的台数和终端电脑的台数。<br>　　第二行包含<em>n</em> - 1个整数，分别表示第2、3、……、<em>n</em>台交换机所连接的比自己上一层的交换机的编号。第<em>i</em>台交换机所连接的上一层的交换机编号一定比自己的编号小。<br>　　第三行包含<em>m</em>个整数，分别表示第1、2、……、<em>m</em>台终端电脑所连接的交换机的编号。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示消息传递最多需要的步数。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 2<br>1 1 3<br>2 1</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下，其中圆圈表示交换机，方框表示电脑：<br><img src="/2019/CCF201503-4-网络延时/network1.png" alt="img"><br>　　其中电脑1与交换机4之间的消息传递花费的时间最长，为4个单位时间。</p><h2 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入"></a>样例输入</h2><p>4 4<br>1 2 2<br>3 4 4 4</p><h2 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出"></a>样例输出</h2><p>4</p><h2 id="样例说明-1"><a href="#样例说明-1" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　样例的网络连接模式如下：<br><img src="/2019/CCF201503-4-网络延时/network2.png" alt="img"><br>　　其中电脑1与电脑4之间的消息传递花费的时间最长，为4个单位时间。</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　前30%的评测用例满足：<em>n</em> ≤ 5, <em>m</em> ≤ 5。<br>　　前50%的评测用例满足：<em>n</em> ≤ 20, <em>m</em> ≤ 20。<br>　　前70%的评测用例满足：<em>n</em> ≤ 100, <em>m</em> ≤ 100。<br>　　所有评测用例都满足：1 ≤ <em>n</em> ≤ 10000，1 ≤ <em>m</em> ≤ 10000。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>问题的本质比较简单，就是求树中任意两个叶子节点的最大路径。求单一个节点的最大路径，可以使用DFS或者BFS暴搜，于是马上想到了一个版本，对所有的叶子节点DFS，分别求出其最大路径，然后取其中的最大值。</p><h2 id="Version-1"><a href="#Version-1" class="headerlink" title="Version 1"></a>Version 1</h2><p>明确了直接暴力DFS的方法后，接下来的任务就是读取数据创建数据结构。看到题面给出的图示，很明显可以看到这里描述的是一个树结构，然后想当然地就建立了树节点，构建树结构。读取数据，建立相应的树节点，并将其添加到相应的父节点下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.children=[]</span><br><span class="line">        <span class="comment">#self.level = 0 </span></span><br><span class="line">        self.no = <span class="number">0</span></span><br><span class="line">        self.type = <span class="number">0</span> <span class="comment">#是计算机还是交换机</span></span><br><span class="line">        self.parent = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>核心的DFS思路为对于当前节点，如果访问过直接退出，否则判断其是否叶子节点，是则结算路径长度，若大于最大路径，则更新。不是叶子节点，则往下递归搜索其子节点。搜完后再往上搜父节点。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(node,count,visited)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> visited[node]:<span class="keyword">return</span></span><br><span class="line">    visited[node]=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> isLeaf(node):</span><br><span class="line">        <span class="keyword">if</span> count&gt;ans:ans=count</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> node.children:</span><br><span class="line">            dfs(c,count+<span class="number">1</span>,visited)</span><br><span class="line">        <span class="keyword">if</span> node.parent:dfs(node.parent,count+<span class="number">1</span>,visited)</span><br></pre></td></tr></table></figure><p>接下来则主要根据读取的数据确定哪些是叶子节点，然后从叶子节点开始dfs即可，最终提交得分40分，显示运行错误。个人猜测可能是爆了递归空间（然而规模还在40个点内，存疑）。</p><h2 id="Version-2"><a href="#Version-2" class="headerlink" title="Version 2"></a>Version 2</h2><p>上网搜了一下这个题，发现了一个新的概念——树的直径。树的直径定义为树中两个叶子节点的最大距离，其实也就是我们题目中所求的东西。对于树的直径，可以有一个比较简单的方法计算：</p><ol><li>从任意一个节点s开始，通过DFS或者BFS找出该节点的最长路径以及路径另一端的节点u</li><li>从1求出的节点u开始DFS或者BFS找出最长路径u-t，这个最长路径则为整个树中的任意两节点的最长路径</li></ol><p><a href="https://blog.csdn.net/forever_dreams/article/details/81051578" target="_blank" rel="noopener">这方法很好证明</a>，在第一步中，我们任意一个节点s开始的DFS找到的最长路径的另一端节点u必然是最长路径的一个端点，因为</p><ul><li>若s在最长路径上，搜索结果必然是最长路径的端点</li><li>若s不在最长路径上，使用反证法，可分为<ul><li>最长路径与2结果有交点</li><li>最长路径与2结果无交点</li></ul></li></ul><p>因此，根据上述的方法引入，直接可以修改版本1的代码，在dfs函数中，添加对最长路径端点的记录，即可将dfs的规模降低至只需两次dfs，再次提交，只有60分，也是显示运行错误，郁闷。</p><h2 id="Version-3"><a href="#Version-3" class="headerlink" title="Version 3"></a>Version 3</h2><p>因为此前提示的都是运行错误而不是超时，考虑可能是超出递归的空间限制，睡醒后决定重新写一个BFS的版本。在上午查阅别人代码时，发现大家都是直接用图来表示树结构，仔细想了一下，确实是可以的</p><ul><li>首先，树就是一个无向图</li><li>其次，在求最大路径长度时，其实是不需要考虑它判断它是否叶子节点，如果路径的端点不是叶子，则一定其子节点的路径长度一定比它大</li><li>另外，题目给出的是交换机和计算机，看上去有区别，我在第一个版本也将其分开了，但是其实两个都还是一样的节点，并不需要区别</li></ul><p>然后原理还是利用版本2中求两次最大长度的方法，不过这一次我选择使用BFS，用队列循环代替递归，防止运行错误。核心BFS代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs_count</span><span class="params">(i)</span>:</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(i)</span><br><span class="line">    node = <span class="number">0</span></span><br><span class="line">    visited[i]=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> e <span class="keyword">in</span> graph[node]:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> visited[e]:</span><br><span class="line">                queue.append(e)</span><br><span class="line">                dis[e] = dis[node]+<span class="number">1</span></span><br><span class="line">                visited[e]=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> dis[node]</span><br></pre></td></tr></table></figure><p>重新提交后，获得100分，用时也比上面的短。</p><p><a href="https://github.com/yeung66/codesAboutCCF/blob/master/201503/network.py" target="_blank" rel="noopener">详细代码点此</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　给定一个公司的网络，由&lt;em&gt;n&lt;/em&gt;台交换机和&lt;em&gt;m&lt;/em&gt;台终端电脑组成，交换机与交换机、交换机与电脑之间使用网络连接。交换机按层级设置，编号为1的交换机为根交换机，层级为1。其他的交换机都连接到一台比自己上一层的交换机上，其层级为对应交换机的层级加1。所有的终端电脑都直接连接到交换机上。&lt;br&gt;　　当信息在电脑、交换机之间传递时，每一步只能通过自己传递到自己所连接的另一台电脑或交换机。请问，电脑与电脑之间传递消息、或者电脑与交换机之间传递消息、或者交换机与交换机之间传递消息最多需要多少步。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CCF201612-4 压缩编码</title>
    <link href="http://scottyeung.club/2019/CCF201612-4-%E5%8E%8B%E7%BC%A9%E7%BC%96%E7%A0%81/"/>
    <id>http://scottyeung.club/2019/CCF201612-4-压缩编码/</id>
    <published>2019-03-12T06:15:57.000Z</published>
    <updated>2019-11-12T14:48:29.979Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　给定一段文字，已知单词<em>a</em>1, <em>a</em>2, …, <em>an</em>出现的频率分别<em>t</em>1, <em>t</em>2, …, <em>tn</em>。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。<br>　　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：<br>　　<em>L</em>=<em>a</em>1的编码长度×<em>t</em>1+<em>a</em>2的编码长度×<em>t</em>2+…+ <em>an</em>的编码长度×<em>tn</em>。<br>　　定义一个前缀编码为字典序编码，指对于1 ≤ <em>i</em> &lt; <em>n</em>，<em>ai</em>的编码（对应的01串）的字典序在<em>ai</em>+1编码之前，即<em>a</em>1, <em>a</em>2, …, <em>an</em>的编码是按字典序升序排列的。<br>　　例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度<em>L</em>为3×1+3×3+2×4+2×2+2×5=34。<br>　　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。<br>　　在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。<br>　　请找出一个字典序编码，使得文字经过编码后的长度<em>L</em>最小。在输出时，你只需要输出最小的长度<em>L</em>，而不需要输出具体的方案。在上面的例子中，最小的长度<em>L</em>为34。</p><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入的第一行包含一个整数<em>n</em>，表示单词的数量。<br>　　第二行包含<em>n</em>个整数，用空格分隔，分别表示<em>a</em>1, <em>a</em>2, …, <em>an</em>出现的频率，即<em>t</em>1, <em>t</em>2, …, <em>tn</em>。请注意<em>a</em>1, <em>a</em>2, …, <em>an</em>具体是什么单词并不影响本题的解，所以没有输入<em>a</em>1, <em>a</em>2, …, <em>an</em>。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　输出一个整数，表示文字经过编码后的长度<em>L</em>的最小值。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>5<br>1 3 4 2 5</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>34</p><h2 id="样例说明"><a href="#样例说明" class="headerlink" title="样例说明"></a>样例说明</h2><p>　　这个样例就是问题描述中的例子。如果你得到了35，说明你算得有问题，请自行检查自己的算法而不要怀疑是样例输出写错了。</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　对于30%的评测用例，1 ≤ <em>n</em> ≤ 10，1 ≤ <em>ti</em> ≤ 20；<br>　　对于60%的评测用例，1 ≤ <em>n</em> ≤ 100，1 ≤ <em>ti</em> ≤ 100；<br>　　对于100%的评测用例，1 ≤ <em>n</em> ≤ 1000，1 ≤ <em>ti</em> ≤ 10000。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>乍一眼看上去似乎跟霍夫曼编码相关，虽然题目明确了霍夫曼编码结果不一定是满足字典序的，但估计解法应该是霍夫曼编码的变形。然而还是没什么头绪，上网一搜，发现这是一个经典的dp问题——<a href="https://blog.csdn.net/acdreamers/article/details/18039073" target="_blank" rel="noopener">石子问题</a>。石子问题描述为：有n堆石子，每次合并2堆，合并花费为两堆石子之和，求合成的最小花费。问题可分为三种类型：</p><ol><li>每次任意合并两堆石子（则变成霍夫曼树构造</li><li>每次合并相邻两堆石子（通过确保只合并相邻石子确保满足字典序</li><li>每次合并相邻两堆石子，且石子环形排列（2的升级版</li></ol><p>这里，我们只讨论第二种情况。状态转移方程如下，<code>dp[i][j]</code>表示合并第i堆到第j堆石子的花费（编码第i个单词到第j个单词的长度花费），<code>sums[i]</code>为前i堆石子（单词）的总花费。实际上是在区间i到j之间寻找一个最优的分界点，左右分别合并，再加上总体的花费。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=<span class="number">0</span><span class="comment">#i==j</span></span><br><span class="line">dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+<span class="number">1</span>][j]+sums[j]-sums[i<span class="number">-1</span>])<span class="comment">#i!=j and i&lt;=k&lt;=j</span></span><br></pre></td></tr></table></figure><p>容易分析，需要三层循环（i，j，k），时间复杂度为$O(n^3)$。提交后能有60分，显示运行超时，但这个是非Python的操作用时，估计实际考试也能过。针对这种情况，上面博文提到可以使用<a href="https://baike.baidu.com/item/%E5%9B%9B%E8%BE%B9%E5%BD%A2%E4%B8%8D%E7%AD%89%E5%BC%8F?fr=aladdin" target="_blank" rel="noopener">平行四边形优化</a>(百科里写得很烂)，对于像上面的状态转移方程，可设<code>p[i][j]</code>为区间i到j中最优的k值，则有<code>p[i][j-1]&lt;=p[i][j]&lt;=p[i+1][j]</code>因此，我们可以缩小k的遍历范围，可证其复杂度降低了一个数量级，为$O(n^2)$，修改后提交能够获得100分。</p><p>详细代码可<a href="https://github.com/yeung66/codesAboutCCF/blob/master/201612/compresscode.py" target="_blank" rel="noopener">点此</a></p><h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p><img src="/2019/CCF201612-4-压缩编码/捕获.JPG" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　给定一段文字，已知单词&lt;em&gt;a&lt;/em&gt;1, &lt;em&gt;a&lt;/em&gt;2, …, &lt;em&gt;an&lt;/em&gt;出现的频率分别&lt;em&gt;t&lt;/em&gt;1, &lt;em&gt;t&lt;/em&gt;2, …, &lt;em&gt;tn&lt;/em&gt;。可以用01串给这些单词编码，即将每个单词与一个01串对应，使得任何一个单词的编码（对应的01串）不是另一个单词编码的前缀，这种编码称为前缀码。&lt;br&gt;　　使用前缀码编码一段文字是指将这段文字中的每个单词依次对应到其编码。一段文字经过前缀编码后的长度为：&lt;br&gt;　　&lt;em&gt;L&lt;/em&gt;=&lt;em&gt;a&lt;/em&gt;1的编码长度×&lt;em&gt;t&lt;/em&gt;1+&lt;em&gt;a&lt;/em&gt;2的编码长度×&lt;em&gt;t&lt;/em&gt;2+…+ &lt;em&gt;an&lt;/em&gt;的编码长度×&lt;em&gt;tn&lt;/em&gt;。&lt;br&gt;　　定义一个前缀编码为字典序编码，指对于1 ≤ &lt;em&gt;i&lt;/em&gt; &amp;lt; &lt;em&gt;n&lt;/em&gt;，&lt;em&gt;ai&lt;/em&gt;的编码（对应的01串）的字典序在&lt;em&gt;ai&lt;/em&gt;+1编码之前，即&lt;em&gt;a&lt;/em&gt;1, &lt;em&gt;a&lt;/em&gt;2, …, &lt;em&gt;an&lt;/em&gt;的编码是按字典序升序排列的。&lt;br&gt;　　例如，文字E A E C D E B C C E C B D B E中， 5个单词A、B、C、D、E出现的频率分别为1, 3, 4, 2, 5，则一种可行的编码方案是A:000, B:001, C:01, D:10, E:11，对应的编码后的01串为1100011011011001010111010011000111，对应的长度&lt;em&gt;L&lt;/em&gt;为3×1+3×3+2×4+2×2+2×5=34。&lt;br&gt;　　在这个例子中，如果使用哈夫曼(Huffman)编码，对应的编码方案是A:000, B:01, C:10, D:001, E:11，虽然最终文字编码后的总长度只有33，但是这个编码不满足字典序编码的性质，比如C的编码的字典序不在D的编码之前。&lt;br&gt;　　在这个例子中，有些人可能会想的另一个字典序编码是A:000, B:001, C:010, D:011, E:1，编码后的文字长度为35。&lt;br&gt;　　请找出一个字典序编码，使得文字经过编码后的长度&lt;em&gt;L&lt;/em&gt;最小。在输出时，你只需要输出最小的长度&lt;em&gt;L&lt;/em&gt;，而不需要输出具体的方案。在上面的例子中，最小的长度&lt;em&gt;L&lt;/em&gt;为34。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>CCF201412-3 集合竞价</title>
    <link href="http://scottyeung.club/2019/CCF201412-3-%E9%9B%86%E5%90%88%E7%AB%9E%E4%BB%B7/"/>
    <id>http://scottyeung.club/2019/CCF201412-3-集合竞价/</id>
    <published>2019-03-06T02:13:48.000Z</published>
    <updated>2019-11-12T14:48:29.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>　　某股票交易所请你编写一个程序，根据开盘前客户提交的订单来确定某特定股票的开盘价和开盘成交量。<br>　　该程序的输入由很多行构成，每一行为一条记录，记录可能有以下几种：</p><ol><li>buy p s 表示一个购买股票的买单，每手出价为p，购买股数为s。</li><li>sell p s 表示一个出售股票的卖单，每手出价为p，出售股数为s。</li><li>cancel i表示撤销第i行的记录。<br>  如果开盘价为p0，则系统可以将所有出价至少为p0的买单和所有出价至多为p0的卖单进行匹配。因此，此时的开盘成交量为出价至少为p0的买单的总股数和所有出价至多为p0的卖单的总股数之间的较小值。<br>  　　你的程序需要确定一个开盘价，使得开盘成交量尽可能地大。如果有多个符合条件的开盘价，你的程序应当输出最高的那一个。</li></ol><a id="more"></a><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>　　输入数据有任意多行，每一行是一条记录。保证输入合法。股数为不超过108的正整数，出价为精确到恰好小数点后两位的正实数，且不超过10000.00。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>　　你需要输出一行，包含两个数，以一个空格分隔。第一个数是开盘价，第二个是此开盘价下的成交量。开盘价需要精确到小数点后恰好两位。</p><h2 id="样例输入"><a href="#样例输入" class="headerlink" title="样例输入"></a>样例输入</h2><p>buy 9.25 100<br>buy 8.88 175<br>sell 9.00 1000<br>buy 9.00 400<br>sell 8.92 400<br>cancel 1<br>buy 100.00 50</p><h2 id="样例输出"><a href="#样例输出" class="headerlink" title="样例输出"></a>样例输出</h2><p>9.00 450</p><h2 id="评测用例规模与约定"><a href="#评测用例规模与约定" class="headerlink" title="评测用例规模与约定"></a>评测用例规模与约定</h2><p>　　对于100%的数据，输入的行数不超过5000。</p><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>分析问题，需要找出使成交量最大的开盘价，我们只需遍历所有的价格，找出其中成交量最大的即可。所有可能的价格集合，其实就是买卖记录中出现的价格，结合输入的行数不超过5000，规模不大，直接暴力算出就行，看上去很简单。然而，这道题却搞了我一个晚上，提交过程一波三折，分数从30到50，再到90，最后才AC。</p><h2 id="版本迭代"><a href="#版本迭代" class="headerlink" title="版本迭代"></a>版本迭代</h2><h3 id="30分版本"><a href="#30分版本" class="headerlink" title="30分版本"></a>30分版本</h3><p>在有了上面算法的大体思路后，主要的实现其实就是读取输入，存取买卖记录，根据记录撤销记录。一开始，我使用的是两个数组来分别存储买卖交易记录，然后用一个whole的数组来记录第i条记录在哪里，当要撤销记录时，才whole数组找到记录实际位置并取消。</p><p>提交后提示运行错误，30分</p><h3 id="50分版本"><a href="#50分版本" class="headerlink" title="50分版本"></a>50分版本</h3><p>分析30分版本的代码，会出现运行错误，无非是撤销记录出了问题，修改测试用例，加入了多条撤销指令，运行结果异常，撤销了非指定的记录。仔细分析后，发现问题在于，我通过whole数组来存储要撤销的指令在哪个数组（买还是卖）以及其索引，但在撤销指令删除某一条记录后，记录在买卖数组中的索引<strong>可能（当要撤销的记录前有已经被撤销的记录）</strong>会发生变化，而这种索引的变化并没有更新到whole数组，所以会导致撤销了错误的记录，甚至导致索引越界的错误。</p><p>于是，考虑直接重写这部分的代码，这次我放弃了此前的一次循环一步到位读取输入，直接变成了三步：</p><ol><li>读取输出，添加到数组</li><li>根据撤销指令撤销相关的指令：这里我是直接将要撤销的指令和撤销指令本身设为<code>None</code></li><li>将指令去除<code>None</code>后分开为<code>buy</code>和<code>sell</code>数组，存储买卖记录</li></ol><p>但在实现撤销记录的过程中，又想到了另一个问题：如果我撤销的记录是一条撤销记录呢？纠结了一下好不好发生这种情况，回去细看问题描述，<code>cancel</code>也是一种记录，而<code>cancel i</code>的作用是撤销第i条记录。所以说，这种情况是有可能出现的。撤销了撤销记录的效果会怎样呢？按照字面意思来说，撤销第i行的记录，就应该是<code>cancel</code>记录无效了，为此，想到了一个比较巧妙的实现方法，将上面的第二步改为倒序遍历记录，实现撤销记录。</p><p>提交后错误，50分</p><h3 id="90分版本"><a href="#90分版本" class="headerlink" title="90分版本"></a>90分版本</h3><p>上面只有50分，非常的奇怪，内心觉得应该是上面纠结的撤销撤销记录的问题。改了一下，待撤销的记录是撤销记录的话就不撤销了，重新提交后，90分，说明前面关于撤销<code>cancel</code>记录的理解是错的。很是难受，难受不是因为说这一题错了，卡住了我，更关键的是，我这个理解是认真读题目描述，仔细分析字面意思，完完全全是根据题目得出来的理解，这也错了。上网搜了一圈，发现大多数人也是在吐槽这个设定。也算是一个自我安慰？</p><h3 id="100分版本"><a href="#100分版本" class="headerlink" title="100分版本"></a>100分版本</h3><p>分析上面的代码，还有10分丢在了哪里？通常错一个用例来说，都是卡在了特殊用例上面，有什么特殊用例呢？会不会是没有成交量？但很快就否定了，如果成交量为0，那里价格就可以取到无限高了（因为多个价格取值成交量相同时，取最高价格）。翻了一下别人的代码，发现有人直接用了浮点数也过了，但是我考虑到精度的问题，选择的是将读取的浮点数乘以100再转成整数处理，最后输出再转回去。于是我修改了测试用例，加入了一条两位小数的记录，果然输出异常了，当我输入一条价格为10.12的记录时，浮点数读取是10.12，乘以100后却变成了1011.99999999而不是设想的1012.0，然后还是直接取整，出事了。改成直接浮点数后，AC了，将取整改成<code>round</code>也能过。</p><h3 id="最终AC代码"><a href="#最终AC代码" class="headerlink" title="最终AC代码"></a>最终AC代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">buy = []</span><br><span class="line">sell = []</span><br><span class="line">records = []</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        inp = input()</span><br><span class="line">        records.append(inp)</span><br><span class="line"><span class="keyword">except</span> EOFError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">i = len(records)<span class="number">-1</span></span><br><span class="line"><span class="keyword">while</span> i&gt;=<span class="number">0</span>:</span><br><span class="line">    r = records[i]</span><br><span class="line">    <span class="keyword">if</span> r <span class="keyword">and</span> r.startswith(<span class="string">'cancel'</span>):</span><br><span class="line">        row = int(r.split()[<span class="number">1</span>])<span class="number">-1</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> records[row].startswith(<span class="string">'cancel'</span>):</span><br><span class="line">            records[row]=<span class="literal">None</span></span><br><span class="line">        records[i]=<span class="literal">None</span></span><br><span class="line">    i-=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">records = filter(<span class="literal">None</span>,records)</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> records:</span><br><span class="line">    r = r.split()</span><br><span class="line">    price,count = float(r[<span class="number">1</span>]),int(r[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">if</span> r[<span class="number">0</span>]==<span class="string">'buy'</span>:</span><br><span class="line">        buy.append((price,count))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sell.append((price,count))</span><br><span class="line"></span><br><span class="line">all_prices = [i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> sell]</span><br><span class="line">all_prices.extend([i[<span class="number">0</span>] <span class="keyword">for</span> i <span class="keyword">in</span> buy])</span><br><span class="line">all_prices = set(all_prices)</span><br><span class="line">ans_price,ans_count = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> price <span class="keyword">in</span> all_prices:</span><br><span class="line">    buy_count,sell_count=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> p,c <span class="keyword">in</span> buy:</span><br><span class="line">        <span class="keyword">if</span> p&gt;=price:buy_count+=c</span><br><span class="line">    <span class="keyword">for</span> p,c <span class="keyword">in</span> sell:</span><br><span class="line">        <span class="keyword">if</span> p&lt;=price:sell_count+=c</span><br><span class="line">    count = min(buy_count,sell_count)</span><br><span class="line">    <span class="keyword">if</span> count&gt;ans_count:ans_price,ans_count=price,count</span><br><span class="line">    <span class="keyword">elif</span> count==ans_count:ans_price=max(ans_price,price)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'%.2f'</span>%(ans_price),ans_count)</span><br></pre></td></tr></table></figure><p>提交结果如下图（中间的C++实现是测试网上其它人的代码</p><p><img src="/2019/CCF201412-3-集合竞价/1551842146877.png" alt="1551842146877"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Problem&quot;&gt;&lt;a href=&quot;#Problem&quot; class=&quot;headerlink&quot; title=&quot;Problem&quot;&gt;&lt;/a&gt;Problem&lt;/h1&gt;&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;　　某股票交易所请你编写一个程序，根据开盘前客户提交的订单来确定某特定股票的开盘价和开盘成交量。&lt;br&gt;　　该程序的输入由很多行构成，每一行为一条记录，记录可能有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;buy p s 表示一个购买股票的买单，每手出价为p，购买股数为s。&lt;/li&gt;
&lt;li&gt;sell p s 表示一个出售股票的卖单，每手出价为p，出售股数为s。&lt;/li&gt;
&lt;li&gt;cancel i表示撤销第i行的记录。&lt;br&gt;  如果开盘价为p0，则系统可以将所有出价至少为p0的买单和所有出价至多为p0的卖单进行匹配。因此，此时的开盘成交量为出价至少为p0的买单的总股数和所有出价至多为p0的卖单的总股数之间的较小值。&lt;br&gt;  　　你的程序需要确定一个开盘价，使得开盘成交量尽可能地大。如果有多个符合条件的开盘价，你的程序应当输出最高的那一个。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.club/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="CCF" scheme="http://scottyeung.club/tags/CCF/"/>
    
      <category term="Python" scheme="http://scottyeung.club/tags/Python/"/>
    
  </entry>
  
</feed>
