<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YeungYeah 的乱写地</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://scottyeung.top/"/>
  <updated>2020-07-30T03:41:17.833Z</updated>
  <id>http://scottyeung.top/</id>
  
  <author>
    <name>YeungYeah</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C# 爽点记录-1</title>
    <link href="http://scottyeung.top/2020/csharp-merit-1/"/>
    <id>http://scottyeung.top/2020/csharp-merit-1/</id>
    <published>2020-07-30T03:11:06.000Z</published>
    <updated>2020-07-30T03:41:17.833Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。</p><a id="more"></a><p>使用的场景为，需要对数组里面的不同元素分别进行计数，如：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;&#123;<span class="string">"cat"</span>, <span class="string">"bat"</span>,<span class="string">"rat"</span>,<span class="string">"dog"</span>,<span class="string">"cat"</span>,<span class="string">"cat"</span>,<span class="string">"rat"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> count = CountEle(arr);</span><br><span class="line"><span class="comment">// should return</span></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   "cat": 3,</span></span><br><span class="line"><span class="comment">//   "bat": 1,</span></span><br><span class="line"><span class="comment">//   "rat": 2,</span></span><br><span class="line"><span class="comment">//   "dog": 1</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>最为常规的方法当然就是遍历计数了 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="keyword">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="keyword">var</span> word <span class="keyword">in</span> arr)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(result.ContainsKey(word)) result[word]++;</span><br><span class="line">      <span class="keyword">else</span> result.Add(word,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的方法简单直接，但是我对于在遍历时里面还要对于是否包含元素进行一次判断，要多写一个判断，多写一个语句感到不爽，就想着搜搜有没改进的办法，像是在 Python 里面，就可以通过 setdefault 或者 get 方法来避免键值还不存在的情况。</p><p>然后发现了 Linq 的方法，起飞。Linq 的方法思路大概就是将可遍历的元素用 Sql 的方法来处理，还是挺爽挺直观的。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Dictionary&lt;<span class="keyword">string</span>,<span class="keyword">int</span>&gt; <span class="title">CountEle</span>(<span class="params">List&lt;<span class="keyword">string</span>&gt; arr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> groups = arr.GroupBy(s =&gt; s)</span><br><span class="line">      .Select(s =&gt; <span class="keyword">new</span> &#123;</span><br><span class="line">        Word =&gt; s.Key,</span><br><span class="line">        Count =&gt; s.Count()</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> groups.ToDictionary(s=&gt;s.Word,s=&gt;s.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后送上一个 Python 版本更加 tricky 的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountEle = <span class="keyword">lambda</span> arr: &#123;i:arr.count(i) <span class="keyword">for</span> i <span class="keyword">in</span> set(arr)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚无意间想到 Leetcode 刷道题，因为太久没刷就随便挑了道 Easy 的题来玩玩，顺便用用 C#。在这个过程中试了试 C# 中的 Linq 特性，果然好用到爆。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="C#" scheme="http://scottyeung.top/tags/C/"/>
    
      <category term="Linq" scheme="http://scottyeung.top/tags/Linq/"/>
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>稳定性与新特性</title>
    <link href="http://scottyeung.top/2020/stability-and-features/"/>
    <id>http://scottyeung.top/2020/stability-and-features/</id>
    <published>2020-07-19T02:39:31.000Z</published>
    <updated>2020-07-19T08:04:26.029Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。</p><a id="more"></a><p>以前的我，一直都不喜欢更新软件，无论是手机还是电脑。新手机拿到，第一时间就是关闭应用商店里面的自动更新，即使更新提示里面的数字到达了 99+，也完全不为所动，除非是当前版本的软件不能用了，或者是新出的版本出了一些大家都在用的现象级的新特性，我才会跟上。当时的我对于更新的印象，还是非常刻板的，觉得：</p><ul><li>更新会占硬盘 / 存储空间</li><li>更新后更吃性能导致卡顿</li><li>更新带来的新特性新功能没有多大的用途</li><li>更新带来的新交互方式设计让自己不习惯</li></ul><p>当然现在回想起来，其实这些印象还是挺可笑的，前两条现象确实存在，不过最主要还是局限于当时的手机硬件配置以及软件设计实现上面，而后两者其实还是为前面所找的理由，没有多大用途 != 没有用途，而新的交互方式设计，不深入体验过也难以获得最为真实的体验，习惯之后，可能会觉得更好。现在手机的配置上来了，我会隔一段时间就自觉地打开应用商店，批量选取软件进行更新，以往觉得会不习惯，没什么用的新特性，现在往往是我所寻找的新体验。包括电脑也是，准时更新系统以及各种软件，想要获取最好最新的体验。甚至我还想着加入 Windows Insider，想着提前试用新特性，获取新体验。</p><img src="/2020/stability-and-features/200719.png"><center style="font-size:14px;color:#C0C0C0;text-decoration:underline">尽管加入了 Windows Insider，但是设备不支持也升级不了（好像有特定设备的 bug</center><p>新特性新体验很美好，但随之而来的，还有各种各样的小问题。新的版本没有经过足够多的使用和测试，很可能就有一些莫名其妙的小问题，稳定性不够好。这也是预料之中，早早体验新版本新功能，本身也是当作一个 beta 版来测试，但是某些时候，我们真的能够接受这些稳定性不足带来的问题吗？或者说，能够接受用多少的稳定性来换取新特性呢？</p><p>新的 Windows 2004，带来了新的开始界面 UI，WSL2 以及其它的新特性，对我来说虽说不是刚需，但还是挺想体验一下的，官方通知在 5 月底的时候正式推送，但是因为设备兼容的原因，直到 7 月中还没有收到升级通知。于是就萌生出加 Windows Insider 的想法，想着加入预览版本应该能够收到升级通知，能够自动升级，当然结果就如上图，最终没有成功，我也干脆就关了 Windows Insider。</p><p>没能成功更新的原因似乎是<a href="https://support.microsoft.com/zh-cn/help/4568129/issue-with-some-storage-spaces-configurations-after-updating-to-window" target="_blank" rel="noopener">磁盘管理相关问题</a>，某些设备上面分区可能会被错误识别，可能会导致数据丢失，暂时还没好的解决方法。这个 issue 是 7 月份才提出来的，之后才禁止相关的设备更新。换而言之，如果早点加入了预览版本，在该 issue 提出之前升级到了对应版本，可能我的设备就遇上了这个问题，我的数据也可能会丢失。作为当前的主力机，出问题丢数据几乎是不能接受的事情，即使有 OneDrive 做了一些最基础的备份。</p><p>想到此内心其实是有一些后怕，也是因为这个问题，我才开始对于稳定性与新特性的权衡有了一点不一样的理解。新特性固然是好，但也仅仅是好，不是必须要的，而为了追求这些可以没有的新特性而把稳定性破坏了，搞出问题影响到基本的使用，就非常难受了，尤其是当前基本所有的工作都在我的唯一主力机上进行，它出了问题就等于我出问题了 <span class="github-emoji" data-alias="cry" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f622.png?v8">😢</span></p><p>所以还是稳一点好，电脑关掉了预览版重新等待漫长的更新推送，手机上 MIUI 的开发版也回刷回去稳定版了，而软件上面的更新还是会及时去更新升级，毕竟软件挂了出问题可以删了重来，系统出问题可能就直接把数据都搞挂了（尤其是之前我还为了囤空间把分区只剩下一个 C 盘了）。</p><p>仅以此文来对自己做一个提醒，以后要时刻考虑稳定性的问题。<del>本文开始时间太久了很多想法都不清楚了<span class="github-emoji" data-alias="joy" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;对于一个软件来说，版本迭代的更新是必不可少的，可能是功能添加，可能是内容修改，可能是体验优化，也可能是问题的修复。为此，各家软件厂商对于自家产品的更新推广可谓是费尽心力，尤其是手机上的 App，隔三岔五就推个要软件升级的通知给你，不可谓不努力。尽管如此，还是有不少人会选择不升级，要不是当前版本的软件不能用了，绝不升级，包括以前的我也是如此。尤其是某些软件的升级，一直被人吐槽，最为著名的就是 Win10 的更新了，就我所知道的，不少人装完系统后第一时间就是直接禁掉自动更新。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="软件" scheme="http://scottyeung.top/tags/%E8%BD%AF%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>不同系统环境下的换行符</title>
    <link href="http://scottyeung.top/2020/%E4%B8%8D%E5%90%8C%E7%B3%BB%E7%BB%9F%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E6%8D%A2%E8%A1%8C%E7%AC%A6/"/>
    <id>http://scottyeung.top/2020/不同系统环境下的换行符/</id>
    <published>2020-06-18T08:11:46.000Z</published>
    <updated>2020-07-16T16:28:17.518Z</updated>
    
    <content type="html"><![CDATA[<p>这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。</p><a id="more"></a><h2 id="换行符">换行符</h2><p>一般会使用转义字符作为换行字符，包括 <code>\n \r \r\n</code>。</p><p>在不同的操作系统的文件系统中，会使用不同的字符作为换行符：</p><ul><li>Linux：<code>\n</code> LF(Line Feed)</li><li>Mac OS：<code>\r</code> CR(carriage return)</li><li>Windows: <code>\r\n</code> CR/LF</li></ul><p>当然这些对于换行符识别的差异主要还是出现文件系统对于文件的识别当中，实际的 coding 过程中一般都还是全部使用 <code>\n</code> 作为字符串当中的换行符。</p><h2 id="踩坑">踩坑</h2><p>记录一下因为换行符不同所踩的坑。</p><h3 id="javascript-油猴脚本解析">JavaScript 油猴脚本解析</h3><p>因为比较经常使用 Google Translate 翻译所看的文档，有挺多的复制待翻译内容到网页端上进行翻译的使用场景，但是 PDF 文档复制时会被换行符也一并复制，所以粘贴的时候原本成句的内容会被分成几段，当作几句话来处理，内容很可能不正确，需要手动删除。一两次还好，次数多了就很麻烦，于是写了一个油猴脚本，捕获 Google Translate 中的粘贴内容，把想要粘贴的内容去除换行符。</p><p>想法很简单，就在输入框元素中监听 paste 事件，当出现 paste 事件时，获取粘贴的内容，阻断粘贴的操作，并把输入框的值改为去除换行符后的粘贴内容。</p><p>第一次尝试没有效果，就在代码里面添加一些 log，来进行 debug，从控制台的输出看到脚本是可以捕获到要粘贴的内容，然后去除换行符后的输出内容也是正常的，但是这个去除换行符后的内容重新复制并粘贴到控制台输入时，却仍然会有换行现象。如果是在控制台中获取元素，用同样的语句移除换行符的话，功能也是正常的。</p><p>最终发现问题就在换行符上面，我从 pdf 中复制的文字中，换行符为 <code>\r\n</code>，而我去除换行符的操作为 <code>replace('\n',' ')</code>。当我去除了 <code>\n</code> 之后，网页端的解析还是当有换行符，在控制台的输入上面也还是有换行的作用，最终把去除换行符的语句改为 <code>replace(/(\r\n|\r|\n)/g, ' ')</code>，套了个正则匹配所有类型的换行符，问题解决。</p><h3 id="cmakelist">CMakeList</h3><p>打算使用 LLVM 在 GitHub 中的代码仓库拉下来的源代码进行构建，在使用 CMake 的时候出现问题，提示问题在 <code>cmake/config.guess</code> 文件中，但是又完全没有说是什么问题，而且它提示的行号基本全是空行。搜了一下，发现这个问题出现得还挺多，不过别人的提示信息更多，提示是字符 <code>\r</code> 出问题，说的大概就是换行符不一致，给的方法是将文件的换行符转成 unix 的换行符即可。</p><p>下了一个工具 <code>dos2unix</code> 可以直接将文本文件的换行符转成 unix下的换行符，转换之后，cmake 就可正常运行，生成构建文件了。（尽管直到现在过了我都还没有成功 build 好 llvm 及其配套工具。）</p><h3 id="git">Git</h3><p>这个是之前遇到的问题了，在 Windows 系统下通过 Git 提交的文件，在使用 WSL 打开时，会提示每一个文件都有修改。在本地中同样的 repo，同样的历史记录，当前状态显示不一样。</p><p>这个可以通过设置 <code>core.autocrlf</code> 来解决，打开了这个选项之后，在提交时会把所有的 CR/LF 换行符转成 LF 换行符，在 checkout 代码时又会把文件中的 LF 换行符转成 CR/LF。本质就是统一在提交记录里使用 LF 作为换行符。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这两天连续遇到了两个因为在不同操作系统中换行符不同所带来的问题，导致花费了一定的时间和精力。虽然之前就一直知道不同操作系统使用的换行符不一样，但是当实际遇上这些差异带来的问题时，才会发现学习的必要性。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="Linux" scheme="http://scottyeung.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>用于外链的资源库构建</title>
    <link href="http://scottyeung.top/2020/%E7%94%A8%E4%BA%8E%E5%A4%96%E9%93%BE%E7%9A%84%E8%B5%84%E6%BA%90%E5%BA%93%E6%9E%84%E5%BB%BA/"/>
    <id>http://scottyeung.top/2020/用于外链的资源库构建/</id>
    <published>2020-05-30T14:37:11.000Z</published>
    <updated>2020-07-16T16:28:17.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="background">Background</h2><p>在升级本博客的 hexo 和主题之前，是曾经搞过一个用 Aplayer 实现的外链播放器的，但因为当时播放过程会被在博客中的页面跳转而刷新页面，导致播放被打断而暂停，体验较差，所以在升级主题版本之后一直没有添加回来。在之后的某次逛 Github 的时候，偶然发现 PJAX 可以实现博客内页面跳转使用 AJAX 不刷新页面。于是又再次把 Aplayer 添加回来。</p><p>有了播放器，最重要的还是要有音乐，有歌曲。原本想着简单地从网上那些外链播放搜索网站，搜索抓取从各大音乐平台的外链，确实能找到，当时也能用，不过好像一般都会有有效期，过了一天就不能用了。为此，参考别人在 GitHub 开启 Repo 作为图床的想法，我也打算在 GitHub 开个 Repo 来存放图片或音频资源，提供外链。</p><a id="more"></a><h2 id="methods">Methods</h2><h3 id="gtihub-repo">GtiHub Repo</h3><p>想法比较简单，在 GitHub 上面开一个公共的 Repo，通过其单个文件下载的链接作为外链使用。</p><p>以创建的 <a href="https://github.com/yeung66/resources" target="_blank" rel="noopener">yeung66/resources</a> 仓库为例，我在 music 文件下面的音乐文件，其下载链接为 <code>https://raw.githubusercontent.com/yeung66/resources/master/music/恋爱为何物.mp3</code>，其映射关系还是很直接很简单的。当场生成放到博客测试一下，也能够正常使用，没有什么问题。</p><p>然而过了一会儿我在手机上访问时，就发现播放器出现异常，歌曲无法正常播放，在手机上直接访问了一下音乐的外链，无法访问。上网一看才发现，<strong>域名 <code>raw.githubusercontent.com</code> 被 DNS 污染了</strong>，没有梯子的话不能正常访问，而我在电脑上一直挂着梯子，而且这个网址也在我的 PAC 上面（好像还是我手动添加的），而手机非需要使用时都不会开代理工具。考虑到我的多数访客并不会挂着梯子进来，只能放弃这个方法。</p><h3 id="gitee-repo">Gitee Repo</h3><p>既然 GitHub 的资源域名被墙了，那就考虑使用国内的替代品 Gitee 码云。思路也还是一样的，来一个公共 Repo，通过文件的下载链接作为外链使用，大概映射关系为 music 文件夹下的 a.mp3 的下载链接为 <code>https://gitee.com/yeungyeah/resources/raw/master/music/a.mp3</code>。放到博客的播放器中可用，似乎没有问题。</p><p>然而今天手机打开测试又再次播放失败了，在电脑上换了电脑测试访问，发现原因居然是<strong>访问的资源大小超过 1M 时需要登录</strong>，所以使用外链播放时，如果没有登录过的话，会不断重定向到登录链接，然后就一直失败，真的小气。（我专门到 GitHub 上面试了一下，不需要登录也可）。之前我在上去创建仓库的时候，登陆过，所以测试时一起正常。</p><h3 id="github-coding-pages">GitHub / Coding Pages</h3><p>突发奇想，虽然 GitHub 中 Repo 的文件直接下载链接被 DNS 污染了，但是它提供的 GitHub Pages 是可以正常访问的，而其中的静态文件也是能够直接访问的，那干脆就直接将他们当成 Pages 发布，这样就可以直接使用了，音乐文件甚至能够直接链接打开播放（直接通过 Github Repo 的文件下载链接是可以下载但是不能在线播放的）。在 GitHub 开启了 Pages 测试一下，能访问，但速度实在感人，播一秒卡两秒。然后想到了现在博客正在托管的 Coding.net 平台（自换域名之后我将所有的解析到解到这里了，国内访问速度满分，但好像 Google AdSense 访问不到了），打开速度非常满意。</p><p>于是，我将我的资源 Repo 传到了 Coding.net 平台，开启 Pages 服务，提供资源外链使用。这两者还可以绑定域名，我就顺手绑了个二级域名，爽得直接起飞。</p><h2 id="thinking">Thinking</h2><p>自说自话一下。</p><p>其实感觉原本是个很简单的问题，但断断续续搞了差不多三四个晚上应该有，最主要的原因还是考虑得不够细致，测试得不够细致，导致总有些问题没有考虑到，疏忽了。过个一天才发现问题，才重新找原因，想解决方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;background&quot;&gt;Background&lt;/h2&gt;
&lt;p&gt;在升级本博客的 hexo 和主题之前，是曾经搞过一个用 Aplayer 实现的外链播放器的，但因为当时播放过程会被在博客中的页面跳转而刷新页面，导致播放被打断而暂停，体验较差，所以在升级主题版本之后一直没有添加回来。在之后的某次逛 Github 的时候，偶然发现 PJAX 可以实现博客内页面跳转使用 AJAX 不刷新页面。于是又再次把 Aplayer 添加回来。&lt;/p&gt;
&lt;p&gt;有了播放器，最重要的还是要有音乐，有歌曲。原本想着简单地从网上那些外链播放搜索网站，搜索抓取从各大音乐平台的外链，确实能找到，当时也能用，不过好像一般都会有有效期，过了一天就不能用了。为此，参考别人在 GitHub 开启 Repo 作为图床的想法，我也打算在 GitHub 开个 Repo 来存放图片或音频资源，提供外链。&lt;/p&gt;
    
    </summary>
    
      <category term="方法" scheme="http://scottyeung.top/categories/%E6%96%B9%E6%B3%95/"/>
    
    
      <category term="工具" scheme="http://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="博客" scheme="http://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="GitHub" scheme="http://scottyeung.top/tags/GitHub/"/>
    
      <category term="静态资源" scheme="http://scottyeung.top/tags/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>vim 常用命令记录</title>
    <link href="http://scottyeung.top/2020/vim-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>http://scottyeung.top/2020/vim-常用命令记录/</id>
    <published>2020-05-06T15:26:53.000Z</published>
    <updated>2020-07-16T16:28:17.427Z</updated>
    
    <content type="html"><![CDATA[<p>开始学习想学很久（或者说是说了很久要学的）的 vim 文本编辑器。虽然说接触了很久，好像从大一开始接触 Linux 系统就不得不与其打交道，但是对于其了解程度一直都处在 &quot;存活期&quot;。所以终于想要进一步学习，进入感觉良好期，甚至是更快更好更强的阶段。于是记录一下一些有用的命令，顺便练一下手，没错本篇博客就是用 vim 写的（完全就是瞎折腾，还发现了不少我觉得是 bug 的问题）。</p><a id="more"></a><h2 id="学习阶段">学习阶段</h2><h3 id="能用">能用</h3><p>所谓的存活期，就是能用，知道怎么编辑，怎么保存。（<del>好像这种地步就已经领先一大批人了，当然我也停滞在这里很久了</del>) 基本上我们只要知道，怎样编辑，怎样保存，就可以用它来作为能用的文本编辑器了。包括下面的内容</p><ul><li>模式<ul><li>Normal 模式：用于执行命令或者跳转。文件需要在该模式进行保存。</li><li>Insert 模式：进行文本输入。按 i 进入，按 Esc 退出到 Normal 模式。</li></ul></li><li>命令<ul><li><code>i</code>: 在 Normal 模式下进行 Insert 模式</li><li><code>x</code>：在 Normal 模式删除光标所在字符</li><li><code>:wq</code>: 保存退出</li><li><code>dd</code>: 删除当前行，并将内容保存到剪贴板</li><li><code>p</code>：将剪贴板内容粘贴出来</li><li><code>hjkl</code>：在 Normal 模式下左下上右d移动光标（也可以使用方向键）</li></ul></li></ul><h3 id="好用">好用</h3><p>能用之后就可以通过学习一下好用且常用的快捷键来提高使用快感和效率。</p><ul><li>插入模式<ul><li><code>a</code> : 光标后插入字符</li><li><code>o</code> ：光标下一行插入空行</li><li><code>O</code> ：光标上一行插入空行</li><li><code>cw</code> ：光标后至行末的字符被替换成空白</li></ul></li><li>光标跳转<ul><li><code>0</code> ：行首</li><li><code>^</code> ：行首第一个非空字符</li><li><code>$</code> ：行末</li><li><code>g_</code>：行末第一个非空字符</li><li><code>/pattern</code> ：搜索 pattern，支持正则表达式，n 可以到下一个</li><li><code>nG</code> ：跳转到第 n 行</li><li><code>G</code> ：跳转到最后一行</li></ul></li><li><code>yy</code> ：复制当前行内容</li><li><code>u</code> ：撤回操作</li><li><code>ctrl + b / ctrl + f</code>: 上一页/下一页</li><li>复制粘贴多行<ul><li>将光标移动到要复制的文本开始的地方，按 v 进入可视模式</li><li>将光标移动到要复制的文本的结束的地方，按y复制。 此时vim会自动将光标定位到选中文本的开始的地方，并退出可视模式。</li><li>移动光标到文本结束的地方，按 p 粘贴。</li></ul></li></ul><p>暂时先稳固在这一个阶段，基本都够熟悉很久了。</p><h2 id="配置">配置</h2><p>在 Windows 上面的配置文件位于 $HOME_vimrc</p><ul><li>设置行号： <code>set number</code></li><li>vim-plug：vim 的插件管理系统</li></ul><h2 id="issues-on-powershell">Issues on Powershell</h2><p>在 Powershell 里面使用 vim 总是会有一些奇奇怪怪的问题。</p><h3 id="编辑">编辑</h3><ul><li>退格键（Backspace）和删除键（Delete）偶尔失灵。常见于删除换行符的时候，尤其是删除空行。空行还可以使用命令 <code>dd</code> 来删除当前行。但是如果是删除之间两行的换行符使两行合并成一行时，就很尴尬。找到的解决方法是在配置文件中添加下面的退格设置，暂时问题不再出现。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set nocp</span><br><span class="line">set backspace&#x3D;2</span><br></pre></td></tr></table></figure></li><li>在中文输入的时候，键盘上的某些字符输入无效，需要切成英文输出才能输入。如符号`，中文的引号和双引号。暂时还不知道怎么解决，使用英文符号凑合一下 <span class="github-emoji" data-alias="joy" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f602.png?v8">😂</span></li><li>中文输入的时候莫名会多打一些字母出来。</li></ul><h3 id="git-的提交问题">Git 的提交问题</h3><p>因为是 Windows 系统，我使用的是 Git on Bash, 它是内置了一个 MINGW 的类 Unix 终端，里面也自带了 vim。当我们设置 Git 的提交编辑器为 vim 时，它会默认打开内部自带的 vim，而不是在 Windows 系统安装的 vim。本来这也没什么，但是它似乎是还扫描到了我在 Windows 系统上面的 vim 的配置文件，这就出问题了。我在 Windows 上面的 vim 安装了 vim-plug 插件管理，安装方式是直接下载配置脚本到目录下的 autoload 目录中，而 Git Bash 自带的 vim 没有这个文件，自然无法识别配置文件中的插件配置项，导致每次调用都会出错。大概的提示就是说载入配置文件的时候在插件配置那里出错了。</p><p>问题其实可以转化为：如何将 Git Bash 里面使用的 vim 换成本地 Windows 系统上面的 vim。搜索看了很多网页，看到的方法基本都不可行，包括：</p><ul><li>设置 alias 让 vim 指向 Windows 系统的 vim <code>alias vim &quot;/c/Program\ Files \(x86\)/vim/vim82/vim.exe&quot;</code> （这里路径的空格和括号都需要转义）。这样在 Git Bash 命令行调用 vim 确实调用到了 Win 上面的 vim，但 git commit 还是调用回自身的 vim</li><li>设置 git config 里面的编辑器选项。默认使用 vim 的话编辑器设置是直接设成了 vim，但有人说可以设成一个路径，指向想要指向的 vim 程序。尝试后连 vim 都打不开了，添加一些选项也无果。</li><li>环境变量中设置 EDITOR 变量。</li></ul><p>最终我选择的方法是移除了 Git Bash 里面的 vim 程序（其所在路径为 <code>/usr/bin/vim.exe</code>），然后添加一个软连接 <code>ln -s '/path/to/your/vim' /usr/bin/vim</code>。因为在 Git Bash 里面调用的 vim 实际上是在调用 <code>/usr/bin/vim</code> ，而这个路径时间上映射到了 Git 安装路径中的 <code>/usr/bin/vim.exe</code> 。我通过移除原有的 vim 程序，建立新的软链接调用目标的 vim 程序，问题解决。在 Git Bash 中调用 vim 和在 git commit 开启编辑器都能成功开启 Windows 的 vim 程序而没有出错。但是有一个小问题，就是原生提供的 Git Bash 开启不了 vim，提示不是 Cygwin 能运行的版本，不过我现在都是在 Windows Terminal 上面使用，而 Windows Terminal 上面使用没有问题。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开始学习想学很久（或者说是说了很久要学的）的 vim 文本编辑器。虽然说接触了很久，好像从大一开始接触 Linux 系统就不得不与其打交道，但是对于其了解程度一直都处在 &amp;quot;存活期&amp;quot;。所以终于想要进一步学习，进入感觉良好期，甚至是更快更好更强的阶段。于是记录一下一些有用的命令，顺便练一下手，没错本篇博客就是用 vim 写的（完全就是瞎折腾，还发现了不少我觉得是 bug 的问题）。&lt;/p&gt;
    
    </summary>
    
      <category term="生产力" scheme="http://scottyeung.top/categories/%E7%94%9F%E4%BA%A7%E5%8A%9B/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
      <category term="vim" scheme="http://scottyeung.top/tags/vim/"/>
    
      <category term="工具" scheme="http://scottyeung.top/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>WSL环境安装配置</title>
    <link href="http://scottyeung.top/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>http://scottyeung.top/2020/WSL环境安装配置/</id>
    <published>2020-05-04T02:56:45.000Z</published>
    <updated>2020-07-16T16:28:17.487Z</updated>
    
    <content type="html"><![CDATA[<p>早在大三上系统级程序设计课程的时候，就通过老师的演示了解到 Windows 的新产品—— Windows Subsystem for Linux(WSL), 可以在 Windows 系统下运行 Linux 系统的程序或命令。不过当时我的旧电脑上装了 Ubuntu 的双系统，所以一直没有尝试。现在换了新电脑之后，一直没有装回 Linux 系统，一是怕麻烦不太想折腾，二是不太想划分硬盘空间。于是干脆就装一个 WSL 吧，尽管现在还没实际使用 Linux 系统的需要，不过就暂时当一个玩具吧。</p><a id="more"></a><h2 id="优点">优点</h2><p>WSL 还是挺爽的，还没用就感觉优点满满：</p><ol type="1"><li>安装简单。简直是傻瓜式的操作，就在系统设置中开启一下，在商店中搜索下载即可，跟在应用商店下个 app 差别不大，而且 Windows Store 的下载速度惊人，非常快就能装好。另外，也不需要考虑任何的驱动兼容问题，少了很多奇奇怪怪的问题。</li><li>空间友好。我下的 Ubuntu 系统才 200+MB, 相比于普通的带 GUI 的 Linux 操作系统，可谓是不占空间一样。另外最关键的一点是，WSL 系统的所有文件都是放在系统盘中，不需要自己另行划分磁盘空间来放置系统。这个点我觉得太赞了，之前装 Linux 双系统最为麻烦的一点就是要专门划分空间，从原有的磁盘中分出空闲空间来专门服务于 Linux 系统，怎么分，分多少，都需要一番思考和设置。分得多吧又感觉浪费，分得少又会不够，到时加空间比较麻烦。</li><li>协同方便。因为 WSL 系统在 Windows 当中，两系统当中的文件都能够轻易地传输使用。之前的话，Linux确实可以通过挂载的方式访问 Windows 的文件，但反过来却不行，而且操作还有<a href="http://scottyeung.top/2018/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%93%8D%E4%BD%9C%E6%96%87%E4%BB%B6%E5%AF%BC%E8%87%B4NTFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%87%E4%BB%B6%E4%B8%A2%E5%A4%B1/">风险</a>。当时有访问跨系统文件的需要时，还需要专门重启一下切换系统，又或者通过网页微信传输文件到手机作为中转。</li></ol><h2 id="安装">安装</h2><p>安装还是挺简单的，只要本机的 Windows 版本支持 WSL功能即可。</p><ol type="1"><li><p>打开“启用或关闭 Windows 功能”，开启适用于 Linux 的 WIndows 子系统。这个可以通过在开始菜单搜索启用（qiyong）的拼音就出现了。<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504120230327.png" alt="image-20200504120230327"></p></li><li><p>打开 Microsoft Store，搜索 WSL 则可以看到支持的所有 Linux 版本。选择其中一个，获取安装即可。安装后可以在开始菜单找到并打开，会自动开启该系统下的 bash 命令行界面。</p></li></ol><h2 id="配置">配置</h2><p>一个完美的开发运行系统，最关键的还是各种的软件或系统的配置，参考了网上的各种各样的文章，主要有下面的方面需要配置。我使用的是 Ubuntu 系统，不同的系统可能配置的具体方式会有出入。</p><h3 id="软件源更新">软件源更新</h3><p>Ubuntu 软件安装/更新源均在国外，下载速度感人，所以可以将所有软件源更换为国内的镜像。这里选择的是阿里云的源。首先将原来的源文件备份，然后更改源文件，将内容换成阿里云的源链接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list  /etc/apt/sources.list.bak</span><br><span class="line">sudo vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>通过 vim 修改源文件，将文件内容更改为下面内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse </span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiverse </span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>保存后更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h3 id="nodejs">Nodejs</h3><p>安装方法可以参考<a href="https://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">这里</a>。Linux 上面有三个方法，一是直接下载编译后的包来使用，下载后建立链接；二是通过下载源代码来编译构建；三则是使用 apt-get 命令直接安装。我当然是选择了最简单的 apt-get 命令安装大法。两行命令搞定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install nodejs</span><br><span class="line">sudo apt-get install npm</span><br></pre></td></tr></table></figure><p>安装后可以通过查看版本号测试是否成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v0.10.25</span><br><span class="line"></span><br><span class="line">$ npm -v</span><br></pre></td></tr></table></figure><p>我的 node 的确成功安装并测试，但是 npm 却没有，输入命令时提示如下，似乎是命令调用错误，通过 which 命令查看时发现调用的是在 Windows 系统的 npm，着实奇怪。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ npm -v</span><br><span class="line">: not foundjs//npm: 3: /mnt/d/nodejs//npm:</span><br><span class="line">: not foundjs//npm: 5: /mnt/d/nodejs//npm:</span><br><span class="line">/mnt/d/nodejs//npm: 6: /mnt/d/nodejs//npm: Syntax error: word unexpected (expecting <span class="string">"in"</span>)</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">which</span> npm</span><br><span class="line">/mnt/d/nodejs//npm</span><br></pre></td></tr></table></figure><p>网上搜索了一下也很多人有类似的问题，GitHub 上面也很多人提了 issue，尝试无果，最终选择换了个方式重新安装，随后解决。</p><ul><li><p><a href="https://github.com/microsoft/WSL/issues/1512#issuecomment-303517504" target="_blank" rel="noopener">GitHub issue</a> ：这里提到的方法主要是修改环境变量的顺序，确保先查找 WSL 安装的 npm 先被搜索到，尝试了一下没有用，which 命令测试也没有变化。</p></li><li><p>StackOverflow 上的<a href="https://stackoverflow.com/questions/45853530/npm-install-error-not-foundram-files-nodejs-npm-3-mnt-c-program-files-nodejs" target="_blank" rel="noopener">重装大法</a> ：将旧的移除后，用新建源的方法重新使用 apt-get 来安装。重新安装后测试成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get --purge remove nodejs</span><br><span class="line"></span><br><span class="line">curl -sL https://deb.nodesource.com/setup_10.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">sudo apt-get install -y build-essential</span><br></pre></td></tr></table></figure></li></ul><h3 id="zsh-and-oh-my-zsh">zsh and oh-my-zsh</h3><p>之前各种的 Linux 系统，无论是服务器还是桌面系统，都是使用自带的 bash，但是大家都说别的 shell 终端更好，于是就干脆试试大家都在推荐的 zsh。</p><ol type="1"><li>可以通过命令<code>cat /etc/shells</code>查看本机是否有 zsh，有的话可以直接跳到 3</li><li>如果没有的话，使用 apt-get 安装即可 <code>sudo apt-get install zsh</code></li><li><code>chsh -s /usr/bin/zsh</code> 通过命令切换到 zsh，重启终端即可</li><li>初次进入 zsh 会提示你需要进行配置文件的创建与配置，我们这里使用 oh-my-zsh 来提供配置</li></ol><p>获取 oh-my-zsh 的方法则比较简单，通过 curl 或者 wget 的方式获取 shell 脚本后执行即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>但这里我怎么也搞不下来，两种方式都不能建立链接，获取不到这个脚本，自然无法进行后续的安装处理。原因似乎是国内的网络环境因为你懂的原因无法访问这个网址 ，估计走代理的话应该可以解决。所以我采用的方法是在 WIndows 系统下好这个 shell 脚本，然后在 WSL 里面运行，问题解决。之后就可以通过在配置文件 <code>~/.zshrc</code>里面设置主题里，可选的主题及效果可以<a href="https://github.com/ohmyzsh/ohmyzsh/wiki/Themes" target="_blank" rel="noopener">点此选择</a>。</p><p>我选的是 ys，这里要吐槽一句，不知道为什么网上看到的预览图片，跟我实际使用的效果相差太大了，有些甚至对使用造成了影响，例如主题 agnoster ，显示的实际颜色与下面的样例图出入太大了，在 WSL 里面打开就是目录显示的是深蓝色，深到看不清楚里面的字那种，尽管我挺喜欢这种风格的，但因为影响到实际使用了，只能放弃。</p><p>官方网站以及大多数经验分享文章中的 agnoster 主题效果 <img src="https://cloud.githubusercontent.com/assets/2618447/6316862/70f58fb6-ba03-11e4-82c9-c083bf9a6574.png"></p><p>这是我用主题 agnoster 的效果图。<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504173113601.png" alt="image-20200504173113601"></p><p>这是我最终选择的主题 ys 的效果<img src="/2020/WSL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/image-20200504173241135.png" alt="image-20200504173241135"></p><hr><p>发现了为啥我的颜色跟网上看到的不一致，原来是需要设置额外的配色，将某些颜色映射为其它色号。我用的是 Windows Terminal，设置配色比较简单，只要在配置文件的 <code>schemes</code> 属性中添加配色主题，再在想要设置配色的终端设置 <code>color-scheme</code> 即可。配色主题可以到这个 <a href="https://github.com/mbadolato/iTerm2-Color-Schemes#windows-terminal-color-schemes" target="_blank" rel="noopener">GitHub repo</a> 上面挑选。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="comment">// powershell 的设置项</span></span><br><span class="line">   <span class="attr">"guid"</span>: <span class="string">"&#123;61c54bbd-c2c6-5271-96e7-009a87ff44bf&#125;"</span>,</span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"Windows PowerShell"</span>,</span><br><span class="line">   <span class="attr">"commandline"</span>: <span class="string">"powershell.exe"</span>,</span><br><span class="line">   <span class="attr">"fontFace"</span>:  <span class="string">"Cascadia Code PL"</span>,</span><br><span class="line">   <span class="attr">"colorScheme"</span>: <span class="string">"OneHalfDark"</span>, <span class="comment">//选择的配色名称</span></span><br><span class="line">   <span class="attr">"hidden"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#123;  <span class="comment">//使用的配色主题, 有些颜色觉得不太行就注释掉，也可以自行修改</span></span><br><span class="line">   <span class="attr">"name"</span>: <span class="string">"OneHalfDark"</span>,</span><br><span class="line">   <span class="comment">// "black": "#282c34",</span></span><br><span class="line">   <span class="attr">"red"</span>: <span class="string">"#e06c75"</span>,</span><br><span class="line">   <span class="attr">"green"</span>: <span class="string">"#98c379"</span>,</span><br><span class="line">   <span class="attr">"yellow"</span>: <span class="string">"#e5c07b"</span>,</span><br><span class="line">   <span class="attr">"blue"</span>: <span class="string">"#61afef"</span>,</span><br><span class="line">   <span class="attr">"purple"</span>: <span class="string">"#c678dd"</span>,</span><br><span class="line">   <span class="attr">"cyan"</span>: <span class="string">"#56b6c2"</span>,</span><br><span class="line">   <span class="attr">"white"</span>: <span class="string">"#dcdfe4"</span>,</span><br><span class="line">   <span class="comment">// "brightBlack": "#282c34",</span></span><br><span class="line">   <span class="attr">"brightRed"</span>: <span class="string">"#e06c75"</span>,</span><br><span class="line">   <span class="attr">"brightGreen"</span>: <span class="string">"#98c379"</span>,</span><br><span class="line">   <span class="attr">"brightYellow"</span>: <span class="string">"#e5c07b"</span>,</span><br><span class="line">   <span class="attr">"brightBlue"</span>: <span class="string">"#61afef"</span>,</span><br><span class="line">   <span class="attr">"brightPurple"</span>: <span class="string">"#c678dd"</span>,</span><br><span class="line">   <span class="attr">"brightCyan"</span>: <span class="string">"#56b6c2"</span>,</span><br><span class="line">   <span class="attr">"brightWhite"</span>: <span class="string">"#dcdfe4"</span>,</span><br><span class="line">   <span class="attr">"background"</span>: <span class="string">"#282c34"</span>,</span><br><span class="line">   <span class="attr">"foreground"</span>: <span class="string">"#dcdfe4"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="oh-my-zsh插件">oh-my-zsh插件</h4><p>自带的插件只需要在配置文件中添加即可，我这里添加了：</p><ul><li>z：路径自动推测跳转 <code>z dir</code></li><li>extract：解压所有类型文件 <code>x file</code></li><li>git：简化了 git 的常用命令</li><li>npm：npm 命令的自动补全</li></ul><p>额外下载的插件则需要下载源代码到 <code>${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins</code>目录下面</p><ul><li>zsh-syntax-highlighting：自动语法高亮</li><li>zsh-autosuggestions：自动补全建议</li><li>git-open：打开 git remote</li></ul><h3 id="代理">代理</h3><h4 id="simple">Simple</h4><p>因为我国的独特网络环境，在访问某些网站的时候速度比较感人，有些时候甚至还不能访问，因而需要一些比较科学的方法来访问互联网，这里设置的代理，本质还是让网络请求通过本机（Windows 系统）的工具进行网络请求。在 zsh 的配置脚本<code>~/.zshrc</code>中添加下面别名即可，里面的端口和协议根据自己的工具具体设置。设置后添加别名 proxy 开启，通过 unproxy 关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">'export http_proxy=socks5://127.0.0.1:1080; export https_proxy=socks5://127.0.0.1:1080'</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">'unset http_proxy; unset https_proxy'</span></span><br></pre></td></tr></table></figure><p>添加后通过<code>source  ~/.zshrc</code>激活，输入 proxy 后即可打开某些不可访问的网站测试一下。</p><h4 id="zsh-proxy">zsh-proxy</h4><p>在实际使用中发现，上面这样的简单的方式在某些地方虽然可行，但是有些地方在实际使用上面却会有问题，例如我在使用 wget 获取网络资源时会提示 socks5 识别不了，说是 wget 并不支持 socks 协议。另外，一些需要频繁访问网络的命令，如 git，npm 等似乎有着自己独特的代理设置方式。没办法，一个 wget 就逼着不得不改变。搜了几个方法之后，最终选择了一个 zsh 插件<a href="https://github.com/SukkaW/zsh-proxy" target="_blank" rel="noopener">zsh-proxy</a>来实现代理功能。</p><p>使用方法很简单</p><ol type="1"><li><p>将插件脚本 clone 到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/sukkaw/zsh-proxy.git ~/.oh-my-zsh/custom/plugins/zsh-proxy</span><br></pre></td></tr></table></figure></li><li><p>在配置文件<code>~/.zshrc</code>的插件项中添加插件 zsh-proxy</p></li><li><p>激活配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure></li><li>通过命令<code>init_proxy</code>进行初始化配置，按照提示输入自己的 http 代理和 socks5 代理即可</li><li>配置完成后通过命令操作即可<ul><li>proxy: 开启</li><li>noproxy: 关闭</li><li>myip: 查看代理的 ip</li></ul></li></ol><hr><p>走代理的速度还是挺爽的，我用 wget 下载 Miniconda，虽然才 80 多兆，但不走代理才 30-40Kb 每秒，开启代理每秒 3M 多，半分钟不到就下完。</p><h3 id="python">Python</h3><p>以前的人都说，Python 在 Linux 环境不需要折腾这么多官方，而我在 Windows 下面进行 Python 项目的开发也确实或多或少地遇到一些小问题，尤其是 package 的安装和管理，使用 pip 的时候莫名其妙地就失败。不过这些问题在开始的时候折腾过后一般就不再发生，尤其是我使用 conda 进行包管理之后，基本很少发生。</p><p>除了可能有奇奇怪怪的的错误之外，使用 Linux 系统开发的好处就是能够接近实际的部署生产环境。因为现在使用的服务器大多都是使用 Linux系统，在相似的环境下开发，部署起来更加方便。</p><p>我也试过跑到 Linux 下面进行 Python 的软件开发，有着 Pycharm 的支持，开发效率也还不错。不过主要的问题是，非开发工具的效率和便利性确实不行。<del>就像是简单地从别人那接收一个 QQ 发过来的文件，我需要从手机 QQ 中接收保存下来，再通过微信发送给在 Linux 系统中登录的网页微信。一两次都还好，经常这样的话简直灾难，尤其是某些应用的网页端 app 简直是残废。</del>有些沟通交互实在麻烦，而且开发过程中的休息与娱乐也比较困难，使我难以坚持下来。</p><p>WSL 似乎就能完美解决这个问题（当然确实云服务器也可以，但就我能负担的云服务器的硬件配置加网络，可能性能还不如虚拟机），双系统完美交互。确实可以考虑把一些 Python 项目的开发和运行丢到这里。</p><p>说了一堆废话，下面看看安装。机器本身就自带 Python2 和 Python3，不过我现在比较偏向于使用 conda 作包管理和虚拟环境管理，就打算重新下一个 Anoconda。不过完整的 Anoconda 体积庞大，包含了很多不必要的科学计算库，这里选的是 Miniconda。安装也是傻瓜式。</p><ol type="1"><li><p>获取安装脚本。建议开启代理，不然速度感人，又或者你在 WIndows 系统下好再在 WSL 里面执行也可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></li><li><p>赋予执行权限。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 777 Miniconda3-latest-Linux-x86_64.sh <span class="comment"># 直接全给权限了</span></span><br></pre></td></tr></table></figure></li><li><p>执行安装脚本。安装过程中会出现若干的配置提示信息，包括安装路径等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./Miniconda3-latest-Linux-x86_64.sh</span><br></pre></td></tr></table></figure></li><li><p>添加环境变量。将<code>export PATH=/home/YOURNAME/miniconda3/bin/conda:$PATH</code> 放到你的 bash 配置文件中。我放到了 zsh 的配置文件 <code>~/.zshrc</code>中。添加后重新启动，或者激活配置文件即可</p></li></ol><h3 id="待填坑">待填坑</h3><ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Python。<del>Ubuntu18 自带了 Python2 和 Python3。我已经不再使用 Python2 了，而 Python2 把 Python和 pip 的命令默认调用都占用了，考虑移除 Python2，或者搞一个 Anoconda 来做环境管理。</del></li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> C/C++ 环境​。<del>想好好学习一下 C++，之前因为 Windows 环境的原因，不得不装了个巨占空间的 Visual Studio，然后到现在还没写过一行 C++ 代码。有点想把它删了，在这里搞个 LLVM/clang 编译器。</del></li></ul><h2 id="命令与快捷键">命令与快捷键</h2><p>记录一下一些较为常用和实用的命令和快捷键这里</p><h3 id="命令">命令</h3><ul><li><code>x file</code>：解压任意类型文件（需要添加 extract 插件</li><li><code>z dir</code>：根据给出的目录进行跳转<ul><li>不一定是完整的，可能只是最后一级</li><li>效果感觉一般，感觉需要吃历史记录的，很多新目录访问都完成不了</li><li>看了一些分析，说是要经过过往的 cd 跳转来获取经验的</li></ul></li></ul><h3 id="快捷键">快捷键</h3><p>好像是仅适用于 zsh</p><ul><li>ctrl + u：清空当前行命令</li><li>ctrl + a：跳到行首</li><li>ctrl + e：跳到行尾</li><li>ctrl + k：删除光标到行尾内容</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早在大三上系统级程序设计课程的时候，就通过老师的演示了解到 Windows 的新产品—— Windows Subsystem for Linux(WSL), 可以在 Windows 系统下运行 Linux 系统的程序或命令。不过当时我的旧电脑上装了 Ubuntu 的双系统，所以一直没有尝试。现在换了新电脑之后，一直没有装回 Linux 系统，一是怕麻烦不太想折腾，二是不太想划分硬盘空间。于是干脆就装一个 WSL 吧，尽管现在还没实际使用 Linux 系统的需要，不过就暂时当一个玩具吧。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://scottyeung.top/categories/Linux/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Ubuntu" scheme="http://scottyeung.top/tags/Ubuntu/"/>
    
      <category term="Windows" scheme="http://scottyeung.top/tags/Windows/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>突然不想再记录时间的使用</title>
    <link href="http://scottyeung.top/2020/%E7%AA%81%E7%84%B6%E4%B8%8D%E6%83%B3%E5%86%8D%E8%AE%B0%E5%BD%95%E6%97%B6%E9%97%B4%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://scottyeung.top/2020/突然不想再记录时间的使用/</id>
    <published>2020-05-03T03:55:30.000Z</published>
    <updated>2020-07-16T16:28:17.818Z</updated>
    
    <content type="html"><![CDATA[<p>一直以来，都有着记录自己日常时间的使用情况，可能是因为很喜欢回顾这些历史数据，回望过去的事情。通过简单的记录，已经留下了不少珍贵的记录数据。</p><a id="more"></a><p>最早在高三的时候，我就会用一个小本子，在每天晚自习开始之前写上今晚想要完成的任务，开始时写上开始的时间，结束时打上一个勾并写上完成时间，通过这种简单的方式，来记录自己的学习时间分布和任务完成情况。</p><p>上了大学之后，时间变得充足了许多，人也有时会悠闲起来，对于时间的使用就没那么敏感了，所以一度没有记录时间的使用情况，只是通过手机中的便签，来记录需要完成的任务以及它们的完成状况。在大一大二时，尚有着较多课程和活动的约束，很多需要完成的任务和事情，自然而然地就会被它们的 ddl 推动着，只要记下了某个任务，而该任务确实是需要完成的，自然会去完成。</p><p>到了大三下学期，课变少了，空闲的时间更多了，人也懒散了下来，对于时间的把控似乎有点糟糕。主要原因是，当时没有一个具体而迫近的任务来推动自己。当时的打算是提早做好保研夏令营的准备，提前准备材料和复习专业课知识。然而这些任务普遍不够明确和具体，准备什么材料，复习什么内容，复习到什么程度，都很难把握。尤其是复习，有些专业课的内容比较多，时间跨度自然容易长，时间一长效率就低。为了更好地推动自己，我使用了 Forest 来进行时间记录。一方面是为了让自己学习或工作能够持续一定的时间不被中断，另一方面，则是为了记录自己在学习上的时间使用，通过每日学习时间的数据反馈来推动自己。</p><p>在使用了 Forest 进行时间记录之后，就会发现，其实自己并没有多么的努力，看似学习了一天，非常充实，实际的学习时间却只有三四个小时。虽然说上午下午甚至晚上都有在学习，但实际情况却可能是，睡到九点多才起床，吃完早餐后要差不多十点多才能开始学习，学一个多小时就要结束，去吃午饭并午休。下午睡到两点多才醒，三点多才在图书馆找到位置开始学习，学个一个多小时就五点多，要去吃晚饭了。吃完晚饭回宿舍休息，状态好的话或许能够再战一小时，状态不好的话，就直接开始娱乐了。要注意到，这里说的学习一小时，并不是说你去学习，从坐下开始到结束起来离开的时间有一小时，而是真真切切的学习一个小时，中途的任何休息，包括打水去厕所看手机，都会中断而不计时。所以数据很真实：去了一个上午，两个多小时，实际学了可能 100 分钟不到。这样的时间管理确确实实地使我明白到自己其实并没有做多少事情，对于自身的能力有一个更加真实的判断，这样的反馈或多或少地推动了我更加努力地前进。</p><p>除了让时间记录的数据推动自己以外，这样的记录还有的珍贵价值，就是可以让自己回顾过去的努力和付出。尽管有些时候工作的时间并不如自己的预期，但是还是有一些值得回味的记录的。例如在准备保研和实训的六月份，每天基本保持长达 300 分钟以上的高强度工作，还有在准备软工期末考试前夕的学习了 600 分钟的一天，都是珍贵的回忆。</p><p>在 Forest 上面种了差不多一年的树，记录了 50000+ 的专注时间，真实的树苗也在上面种了一棵。说实话，这样的数据是很能给到人触动的，尤其是回过头来重温当时的某段努力的时光，看着图上树木繁多的森林，总能够给人一种自身努力过的痕迹。</p><p>然而，在三月中的时候，可能是因为疫情原因导致时间上更加空闲的缘故，我似乎有更多的时间和精力来记录时间，收集更好看的数据，原有的 Forest 只有一个简单的类别标签，没有办法记录该段时间做了什么具体内容。另外，Forest 无法记录回过去忘记记录的时间，也是让我有点不满。刚好在某个推送上面看到了有时间管理工具的介绍，就转而使用 Toggl 进行时间记录。</p><p>Toggl 的时间记录方式比较自由，也比较专业，毕竟 Forest 始终都是一个帮助人专注的工具，在单纯的时间记录上面，Toggl 远胜于 Forest。Toggl 可以使用计时模式，也可以手动输入时间数据，对于过往的数据，也能够很容易地就修改。另一方面，每一条时间记录，可以添加 Project 和若干个 tag，便于进行聚类统计分析。</p><p>虽然工具很好，但是在用了一个来月之后，我却不想再用了。就在这两天，有一种不再想记录时间使用情况的想法。时间记录得太细，太过频繁，太过复杂，越令我萌生出一种很不耐烦，很功利的感觉。尤其是这几天在做的数据分类的工作，尽管我感觉只是在做无聊而重复的无意义的工作，但是，为了记录下时间的使用，让时间的使用显得更有价值，我还是记录了下来，美其名曰科研数据处理，甚至连几分钟的空闲间隙时间也不放过，一天能够记上差不多十条的记录。我觉得很没意思。</p><p>另外，还有一件很可怕的事情是，这样子记录时间，有点助长自己对于时间利用的功利性，事事都想记录下来，证明自己是有做事情的，是没有浪费时间的。但我们的人生真的可能时时刻刻都被妥善利用在所谓的有意义的事情上面吗？可能有这样的人，但个性闲散的我并不是这样的人。因为发现记录下来的时间并不满足自己的预期，心里受到了落差与打击，时常都会出现自己不过如此的感觉。为了抵消这种错觉，我便变得将日常所做的所有事情的一一记录，甚至夸大了从事某些事情的时间，以营造出我很努力的感觉，来抵消自己的愧疚。事实上，这样只会让自己错误地判断自己的工作和学习状况，对所能完成的任务和事情的预期产生错误的判断，当某些目标完成得不如预期时，又或者某天的记录回归正常时，就会产生出自身能力在现实和设想的落差，进而导致不自信和愧疚。</p><p>尽管如此，我还是忍受不了这种诱人的历史数据的引诱，在写这篇文章的时候，我都还是用回了 Forest 进行时间记录。不过为了进一步减少这样功利感，还是使用回这样的比较简单的工具好一点，起码这样我就不能够修改我的时间记录，而产生虚伪的结果。另外，对于一些小的碎片时间，也不应该太过执着于记录，毕竟<strong>时间的本质是为了我们的使用而服务，而不是为了被我们记录</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直以来，都有着记录自己日常时间的使用情况，可能是因为很喜欢回顾这些历史数据，回望过去的事情。通过简单的记录，已经留下了不少珍贵的记录数据。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="每日千字" scheme="http://scottyeung.top/tags/%E6%AF%8F%E6%97%A5%E5%8D%83%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>shell 脚本入门</title>
    <link href="http://scottyeung.top/2020/shell-%E8%84%9A%E6%9C%AC%E5%85%A5%E9%97%A8/"/>
    <id>http://scottyeung.top/2020/shell-脚本入门/</id>
    <published>2020-04-21T13:17:55.000Z</published>
    <updated>2020-07-16T16:28:17.355Z</updated>
    
    <content type="html"><![CDATA[<p>shell 是一个用C编写的程序，既是一种命令语言，又是一种程序设计语言，常用于运行自动化执行 Unix/Linux 系统命令的脚本。在最近的数据收集等任务当中，发现其实对于脚本的使用其实有着较大的需求，之前我都是直接用 Python 写脚本来完成，效果也不错，但总感觉总有点杀鸡用牛刀的感觉，而且对于系统命令的执行也比较不方便。写过几个自动化提交代码的 shell 脚本，但还是不太熟悉，于是打算找个教程过一遍 shell 脚本编程，算是入门了。</p><a id="more"></a><h1 id="shell">shell</h1><h2 id="执行">执行</h2><p>创建 shell 脚本文件，以后缀 .sh 结尾，就可以</p><ul><li>直接通过执行文件的方式执行脚本 <code>./script.sh</code></li><li>通过 sh 命令的方式 <code>sh script.sh</code> 执行</li></ul><h2 id="变量">变量</h2><ul><li>shell 中的变量只有两种，分别为数字和字符串，数组。<br></li><li>shell 变量命名由字母，数字，下划线组成</li><li>通过反引号 ` 可以执行命令，将结果作为返回值赋予变量</li></ul><h3 id="操作">操作</h3><ul><li>赋值<ul><li>变量直接通过 = 号进行 <code>var=125</code></li><li>通过语句赋值，如 for 循环语句 <code>for file in $(ls /etc)</code></li></ul></li><li>只读：通过设置 <code>readonly var</code></li><li>删除：<code>unset var</code></li><li>使用：通过在变量前使用 $ 则可</li><li>字符串拼接：可以通过 字符串变量字符串 的方式进行拼接</li></ul><h3 id="字符串">字符串</h3><ul><li>单引号：不转义原样输出，变量也无效，可以通过成对出现来拼接</li><li>双引号：可以有变量，可以有转义字符</li><li>可以通过 <code>$#</code> 获取长度</li><li>可以通过 <code>${var:1:3}</code> 的方式进行切片</li></ul><h3 id="数组">数组</h3><ul><li>由括号括住，元素通过空格分隔 <code>arr=(var1 var2 var3)</code></li><li>通过下标 [] 获取元素</li><li>使用 @ 可以获取所有元素</li><li>通过 # 可以获取数组的长度 <code>${#arr[@]}</code></li></ul><h3 id="通用变量">通用变量</h3><ul><li>命令行参数<ul><li><code>$n</code> 表示第n个参数</li><li><code>$#</code> 参数个数</li><li><code>$*</code> 所有参数以单个字符串的方式返回</li><li><code>$$</code> 当前进程ID</li><li><code>$@</code> 所有参数以字符串的方式逐个返回</li></ul></li></ul><h2 id="运算符">运算符</h2><p>bash 原生并不支持数学运算，需要通过其它命令来实现，如 expr</p><ul><li>算术运算符<ul><li>加减乘除取余赋值。乘法需要转义 *</li><li>相等与不相等：比较数字</li></ul></li><li>关系运算符<ul><li><code>-eq -ne -gt -lt -ge -le</code> 等于 不等于 大于 小于 大于等于 小于等于</li></ul></li><li>布尔运算符<ul><li><code>! -o -a</code> 取反 或 与</li></ul></li><li>逻辑运算符<ul><li><code>&amp;&amp; ||</code> 与 或</li></ul></li><li>字符串运算符<ul><li><code>= != -z -n $</code> 等于 不等于 长度为0 长度不为0 是否空字符串</li></ul></li><li>文件测试运算符<ul><li><code>-b -c -d -f -p</code> 是否块设备 字符设备 目录 普通文件 管道</li><li><code>-r -w -x -s -e</code> 文件是否可读 可写 可执行 为空 是否存在</li></ul></li></ul><h2 id="命令">命令</h2><ul><li>echo：字符串输出</li><li>read：从标准输入读取一行</li><li>printf：与C的类似，进行格式化输出<ul><li>转义序列：<code>\b \c \n \t</code> 后退 不换行 换行 制表符</li></ul></li><li>test：检查条件是否成立<ul><li><code>test bool-expr</code> = <code>[bool-expr]</code></li></ul></li><li>$[a+b]：执行基本的算数运算，符合两边不能有空格</li></ul><h2 id="控制逻辑">控制逻辑</h2><h3 id="if">if</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">elif</span> condition</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="for">for</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> item1 item2 item3</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    commands</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>in后除了可以跟元素序列，还可以接一个返回多个元素的命令</p><h3 id="while">while</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> condition</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">command</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># infinite loop</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> / <span class="keyword">while</span> :</span><br></pre></td></tr></table></figure><h3 id="case">case</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> var <span class="keyword">in</span></span><br><span class="line">    1)</span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line">    2)</span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line">    *) <span class="comment">#其余情况</span></span><br><span class="line">        <span class="built_in">command</span></span><br><span class="line">        ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><h3 id="breakcontine">break/contine</h3><p>跳出循环与跳到下次循环</p><h2 id="函数">函数</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义</span></span><br><span class="line"><span class="function"><span class="title">func</span></span>()&#123;</span><br><span class="line">    commands</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"使用参数时通过 <span class="variable">$1</span> 调用"</span></span><br><span class="line">    <span class="built_in">return</span> <span class="string">'也可以没有返回'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用（不需要括号</span></span><br><span class="line">func</span><br></pre></td></tr></table></figure><h2 id="重定向">重定向</h2><ul><li>command &gt; file 输出重定向</li><li>command &gt;&gt; file 追加方式输出重定向</li></ul><h2 id="导入-shell-脚本">导入 shell 脚本</h2><p>通过 <code>. filename</code> 或 <code>source filename</code> 的方式导入脚本中的变量或函数</p><h1 id="unixlinux-命令">Unix/Linux 命令</h1><p>shell 脚本最强大的功能，还是在于能在脚本中自动化地使用对于系统命令的调用，而其中主要是 Linux 的命令使用，这些就需要额外的学习了，不在此处展开。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;shell 是一个用C编写的程序，既是一种命令语言，又是一种程序设计语言，常用于运行自动化执行 Unix/Linux 系统命令的脚本。在最近的数据收集等任务当中，发现其实对于脚本的使用其实有着较大的需求，之前我都是直接用 Python 写脚本来完成，效果也不错，但总感觉总有点杀鸡用牛刀的感觉，而且对于系统命令的执行也比较不方便。写过几个自动化提交代码的 shell 脚本，但还是不太熟悉，于是打算找个教程过一遍 shell 脚本编程，算是入门了。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="shell" scheme="http://scottyeung.top/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>知不可而为 与 为而不有</title>
    <link href="http://scottyeung.top/2020/%E7%9F%A5%E4%B8%8D%E5%8F%AF%E8%80%8C%E4%B8%BA-%E4%B8%8E-%E4%B8%BA%E8%80%8C%E4%B8%8D%E6%9C%89/"/>
    <id>http://scottyeung.top/2020/知不可而为-与-为而不有/</id>
    <published>2020-04-18T03:47:07.000Z</published>
    <updated>2020-07-16T16:28:17.800Z</updated>
    
    <content type="html"><![CDATA[<p>昨晚因为看了实习职位，沉浸于幻想当中太久，导致千字任务最终未能完成。不但如此，上床了之后脑海中仍然不断地想着去实习的事，面试能不能过，能不能被录取，有没有机会去，导师会不会不批准，众多问题萦绕于脑海，挥之不去，睡也睡不着。想得最多的，还是组里会不会不给，或者实习之后老师仍然不时安排科研任务。想了很多，也只能是空想，没有实质的结果。Anyway，有机会还是要试一试，简历也是要投一投的。过去的我错失了很多的机会，就是因为所谓的“自知不可为”，而根本不去尝试一下，所谓的未免浪费时间精力，很多时候也只是害怕面对失败结果的借口而已。</p><a id="more"></a><p>之前看梁启超的散文，其中有一篇说到其处世观，知不可而为，与为而不有。知不可而为，就是即使知道所做的事情可能很难，会没有结果，没有收获，仍然去做，不考虑成败。为而不有，就是做事情不带有目的，并不是为了某些回报才去做某些事情。以上两种做事观念，我都非常欣赏，且非常向往。做事情，就应该不用也不必考虑这么多，难易，成败，得失，只要是我想做的事情，我就去做，不论结果。</p><p>这样的观念境界很是理想，很是美好，同时也很难实现，很难保持。为而不有，前几天就谈到过，如此功利主义的我，对于任何时间的规划，事情的安排，总是按照所谓的重要程度来进行排序。就如学习的优先级，对我来说，就比运动锻炼要高，所以在一早起床后大块的可利用时间内，我会选择坐在桌子前学习工作，而从来不会先运动一下。为有而为，因有而为，就导致了很经常会因不有而不为，从而损失了很多的机会与乐趣。正是这样，让我在大学期间基本没怎么参加一些课外的活动，因为其“无用”，实在可惜。</p><p>而知不可而为，就更加难了。每个人都有畏难的情绪，害怕挫折，害怕失败，所以会选择止步于舒适区当中，选择放弃不可为之事。明知不可为而行动，怕不是浪费时间，所以我们选择了不为，选择了其它事情了来做。现在的我也是这样想的，尤其是功利的我，凡事追求最高效率，最大收益，不可为，完成不了，就等于没有收益，零效率，根本不能接受。</p><p>不能知不可而为，更为可怕的，是这样会经常地自认为自己不可为，不能为，从而束缚了自己。我在大一下学期时，无意中进入了学校的ACM集训群，并激发了我对于搞ACM算法竞赛的兴趣，然而这份热情很快就被自己的“理智分析”打散了：别人都有基础，比不过人家；需要投入大量的时间，可能会影响正常的学习与活动；比赛还要组队，而我一个人都不认识。我找了众多的理由，来告诉自己这是不可行的，我是做不来的。现在回想起来，如果当时没考虑这么多，选择了参与其中，尝试一下，那我如今的生活状态可能就大不一样了，也不是说我参与了可能就可以得到多好的成绩，而是在做这件事的过程中，我会受到许多的影响，从而被推动或改变。</p><p>但这也只是个人的选择，又能怎样呢，毕竟当时选择了知不可而不为的时候，也享受到了闲散带来的悠闲与轻松。不过仍然希望将来能够更好地践行这两个观念，作出改变。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;昨晚因为看了实习职位，沉浸于幻想当中太久，导致千字任务最终未能完成。不但如此，上床了之后脑海中仍然不断地想着去实习的事，面试能不能过，能不能被录取，有没有机会去，导师会不会不批准，众多问题萦绕于脑海，挥之不去，睡也睡不着。想得最多的，还是组里会不会不给，或者实习之后老师仍然不时安排科研任务。想了很多，也只能是空想，没有实质的结果。Anyway，有机会还是要试一试，简历也是要投一投的。过去的我错失了很多的机会，就是因为所谓的“自知不可为”，而根本不去尝试一下，所谓的未免浪费时间精力，很多时候也只是害怕面对失败结果的借口而已。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="每日千字" scheme="http://scottyeung.top/tags/%E6%AF%8F%E6%97%A5%E5%8D%83%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>博客域名迁移</title>
    <link href="http://scottyeung.top/2020/%E5%8D%9A%E5%AE%A2%E5%9F%9F%E5%90%8D%E8%BF%81%E7%A7%BB/"/>
    <id>http://scottyeung.top/2020/博客域名迁移/</id>
    <published>2020-03-25T03:56:16.000Z</published>
    <updated>2020-07-23T03:54:46.740Z</updated>
    
    <content type="html"><![CDATA[<p>一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年 72 元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些 cn 后缀的都贵，有点离谱。于是果断选择转换回去最早使用的 top 域名，续费也才25一年，加上首年优惠三年才花了 60 不到。</p><p>另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的 SEO 和 RSS 订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。</p><p>本站现已迁移到域名 <strong><a href="http://scottyeung.top/" class="uri">http://scottyeung.top/</a></strong></p><a id="more"></a><h2 id="相关工作">相关工作</h2><p>以下是迁移域名做的一些工作：</p><ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Github Pages 切换解析到新域名<ul><li>域名添加DNS解析，两个 A 记录指向 GitHhub 的 ip 地址，一个 cname 绑在二级域名 www 上指向博客的源地址</li><li>Github Repo 修改 Github Pages 的 Custom domain</li><li>修改 public 文件夹当中的 CNAME 文件的内容为新域名（我已经忘了这个的作用了2333</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Coding.net 添加解析（现在已经感觉完全归属到腾讯了）。原本是当作国内百度搜索引擎的专用解析，但因为下面的 Google Search 需要旧网址跳转，遂暂时使用它来提供 Pages 服务。</li><li><p><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> LeanCloud 修改安全域名，添加对新域名的支持。发现可以直接使用过往的阅读量数据和评论数据</p></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Google Analytics： 修改监测网址即可。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> Google Adsense： 添加新网址即可，需要重新进行审核，等待通过中。<ul><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 因为疫情的原因，拒了我两次，原因居然是因为疫情而无法审核</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 两次都说我的网站已经下线或无法访问，上网搜了一下，发现一些人也有这个问题，可能是DNS对于域名国外访问的解析出了问题，建议添加额外的国外线路解析。当时我是使用 coding.net 提供的 pages 服务，好像这个是国内的服务（存疑），全部的解析到转到了那里。</li><li><span class="github-emoji" data-alias="zzz" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/1f4a4.png?v8">💤</span> 第五次审核中。添加了额外的海外线路解析到 Github Pages。海外线路走 Github，国内访问走 coding.net.</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 因为多次审核不通过而被禁止申请一段时间，卒</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 过了禁止时间几天之后，一申请第二天就申上了，然后感觉广告量少了很多，点击就更加了</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> Google Search<ul><li>添加新域名并进行所有权验证</li><li>新域名添加站点地图抓取</li><li>尝试将旧网站的索引的 SEO 资源继承到新域名中，Google Search Console 中的确有网站转移的功能，要求旧网址发 301 响应重定向到新网站。可选的方法有：旧域名 DNS 解析中添加显式 URL 跳转，跳转到新域名，但是目标跳转域名需要备案。选择支持绑定多个域名的Pages服务提供商，如coding.net，可以绑定多个域名，然后选择一个首选域名，其它域名跳转到该域名，浏览器调试验证确实可行，但 Google Search Console 不知道为啥通不过，暂时放弃。过了一个多小时又可以了，不过需要一段时间来处理，不知道要多久，然而提示最好保留重定向 180 天，旧域名只剩下一个月，如果不能在一个月之内迁移成功旧白干了。</li><li>最终基本成功迁移，但是搜索的展示量和点击量都有一点下降，不过好像现在已经回归到跟之前差不多水平了</li></ul></li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 百度站长工具：类似于 Google Search，添加新的网址进行所有权认证即可。依然采用主动推送和 sitemap 的方式来提交链接。</li><li><p><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 360站长工具：同上，操作简单，不过连同上周其实没有期望多大的效果。</p></li></ul><h2 id="数据损失">数据损失</h2><p>因为转换域名而无法继承的数据造成的损失：</p><ul><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 卜算子站点统计。因为它的统计似乎是以站点网址作为键值来进行统计的，更换后直接重新进行统计。（服务开启得太过简单的后果就是维护性/扩展性的牺牲</li><li><span class="github-emoji" data-alias="x" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/274c.png?v8">❌</span> 部分 rss 订阅的损失（虽然本来也没有多少</li></ul><h2 id="信息修改">信息修改</h2><p>此处是一些记录下我网址的需要改过来的地方</p><ul><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> GitHub 上博客的 repo 简介和个人简介</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> 中文独立博客 repo 中的博客列表需要修改网址，发PR来改</li><li><span class="github-emoji" data-alias="white_check_mark" style data-fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/2705.png?v8">✅</span> twitter 上面写的个人网址</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一早起来，发现使用两年的域名还有一个月就要到期了，提醒续费。在处理完一些事情后去续费，发现续费需要每年 72 元，震惊，当时开通的时候也就几块钱，第一年续费也就二三十块，变动也未免太大了，而且对于我这种个人小站来说确实贵。上去查了一下现在域名的价格，发现club后缀的价格确实是独一档的贵，甚至比一些 cn 后缀的都贵，有点离谱。于是果断选择转换回去最早使用的 top 域名，续费也才25一年，加上首年优惠三年才花了 60 不到。&lt;/p&gt;
&lt;p&gt;另一方面，转域名也是有着不少的成本，而且是越用的久，沉没成本就越高。积累的 SEO 和 RSS 订阅都难以跟随域名转换而跟着转化过来，又可能要重新积累，各种的统计分析也可能需要废弃。但还是需要去做，毕竟互联网的特点就应该是开放而自由，不应该受到过多的枷锁。&lt;/p&gt;
&lt;p&gt;本站现已迁移到域名 &lt;strong&gt;&lt;a href=&quot;http://scottyeung.top/&quot; class=&quot;uri&quot;&gt;http://scottyeung.top/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="博客" scheme="http://scottyeung.top/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Python中的并发编程</title>
    <link href="http://scottyeung.top/2020/Python%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://scottyeung.top/2020/Python中的并发编程/</id>
    <published>2020-03-09T12:51:07.000Z</published>
    <updated>2020-07-16T16:28:17.352Z</updated>
    
    <content type="html"><![CDATA[<p>尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。</p><a id="more"></a><p>以下只考虑Python3的状况。</p><h2 id="threading-multiprocessing">Threading / Multiprocessing</h2><p>最简单的并发编程形式，莫过于直接开启新的线程或者进程来执行代码。</p><ul><li><code>threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code> 通过调用该方法可以直接创建线程对象，其中target为需要执行的目标函数，args和kwargs为该目标函数的参数，创建后，通过<ul><li>调用start方法以开启线程，进行调度执行target函数</li><li>线程开启调度后，调用<code>join(timeout=None)</code>方法可以阻塞调用线程，等待线程结束或者超时</li><li>使用threading进行多线程编程实现并发的话，仍然受到GIL的限制，但仍可以避免因等待IO完成的阻塞</li></ul></li><li><code>multiprocessing.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None)</code> 类似于线程的创建，创建进程实现多线程可以避免GIL的限制从而利用到CPU的多个核心，在CPU密集的代码中非常有用。<ul><li>类似于线程的使用，通过start方法开启进程任务调度，调用join方法等待完成</li><li>除此以外，可以调用进程池Pool进行多个任务的调度处理，通过map或者apply方法，开启多个进程处理多个任务</li></ul></li></ul><p>直接创建线程/进程这种方式简单、直接、粗暴，不过大多时候需要自己进行任务的调度，需要自己安排怎样创建进程，怎样完成任务。在之前尝试<a href="http://scottyeung.club/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/" target="_blank" rel="noopener">批量下载漫画</a>的过程中，使用的就是threading方法，就需要自己进行任务的安排，进而安排线程的创建和执行。当时还不知道怎么合理地分配调度任务，就只能将任务分为若干子集，每个子集开启独立的线程来完成下载任务，但是仍然无法避免下载过程中网络访问和文件保存的IO阻塞。另外，线程创建之后就是独立运行的线程，除了等待结束返回之后，无法传输数据进行额外的控制。</p><h2 id="concurrent.futures">concurrent.futures</h2><p>它在Python3.2中被引入，提供了高层次的异步可调用对象执行的接口。我们可以通过ThreadPoolExecutor在线程级别上进行异步执行，或者通过ProcessPoolExecutor在不同的进程中实现。两者实现相同的抽象接口类Excutor，因而具有一样的调用方法，便于进行转换。</p><h3 id="executor">Executor</h3><ul><li><code>submit(fn, *args, **kwargs)</code> 提交任务进行调度，返回Future对象</li><li><code>map(func, *iterables, timeout=None, chunksize=1)</code> 类似于map方法，对于iter里面的每一个对象都会异步地调用func，当任务结束时返回各个函数返回结果的迭代器</li></ul><h3 id="future">Future</h3><p>在futures里面具体的任务类，由submit方法创建。</p><ul><li>result 获取任务的返回结果，若未结束则阻塞至结束或超时</li><li>cancel 关闭任务</li><li>canceled 是否关闭</li><li>done 是否结束</li></ul><h3 id="使用方式">使用方式</h3><ol type="1"><li><p>通过submit提交任务创建获取任务的future对象，再通过as_completed等待future对象结束，获取结果。as_completed接收future对象的迭代器。 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    <span class="comment"># Start the load operations and mark each future with its URL</span></span><br><span class="line">    future_to_url = &#123;executor.submit(load_url, url, <span class="number">60</span>): url <span class="keyword">for</span> url <span class="keyword">in</span> URLS&#125;</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(future_to_url):</span><br><span class="line">        url = future_to_url[future]</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = future.result()</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">            print(<span class="string">'%r generated an exception: %s'</span> % (url, exc))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%r page is %d bytes'</span> % (url, len(data)))</span><br></pre></td></tr></table></figure></p></li><li><p>通过map方法批量执行任务，再获取结果。但是map方法返回结果的顺序与调用顺序即传入的迭代对象的顺序一样，若前面的任务耗时过长会阻塞后面执行快的任务返回。</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> concurrent.futures.ProcessPoolExecutor() <span class="keyword">as</span> executor:</span><br><span class="line">        <span class="keyword">for</span> number, prime <span class="keyword">in</span> zip(PRIMES, executor.map(is_prime, PRIMES)):</span><br><span class="line">            print(<span class="string">'%d is prime: %s'</span> % (number, prime))</span><br></pre></td></tr></table></figure><h2 id="asyncio">asyncio</h2><p>asyncio采用event loop的事件驱动型的异步调度执行。</p><h3 id="coroutine">coroutine</h3><p>coroutine（协程）从定义上来说，指的是包含yield/yield from语句的函数（在Python3.5引入async和await之前）。在此之前，我们可以通过生成器的形式来实现，样例如下。首先可以调用函数获得生成器对象，然后调用next方法或send(None)的方法开启coroutine，开启后，函数执行到yield位置，返回yield右侧的表达式后则挂起自己，将控制流交回给主线程。当再次调用send方法时，可以传输数据并激活协程，继续执行至结束或者下一个yield语句处。该样例则是一个计算累计输入的平均值协程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"># BEGIN CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg = averager()  # &lt;1&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; next(coro_avg)  # &lt;2&gt;</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(10)  # &lt;3&gt;</span></span><br><span class="line"><span class="string">    10.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(30)</span></span><br><span class="line"><span class="string">    20.0</span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; coro_avg.send(5)</span></span><br><span class="line"><span class="string">    15.0</span></span><br><span class="line"><span class="string"># END CORO_AVERAGER_TEST</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0.0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># &lt;1&gt;</span></span><br><span class="line">        term = <span class="keyword">yield</span> average  <span class="comment"># &lt;2&gt;</span></span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br></pre></td></tr></table></figure><p>当coroutine运行结束时，会抛出一个StopIteration的异常，告知协程结束。若协程函数有返回值，也会被存在StopIteration.value中随着异常返回。如果我们要获得返回值，必须要捕获异常。另外，在使用coroutine的过程中，我们还需要手动调用next方法来开启coroutine。这些不方便之处，使我们通常会使用一个delegating generator来进行中间的调用操作。在delegation generator当中，通过yield from来调用subgenerator，并可以直接获取返回值，且delegating generator可以处理subgenerator抛出的异常。</p><h3 id="使用方式-1">使用方式</h3><p>asyncio库则是通过协程的方式，引入事件循环（event loop）的方式，通过事件轮询与回调的方式进行异步编程。具体的使用方式通过书中一个具体的例子来说明。这个例子是批量从网上下载不同国家国旗的图片，通过将每一个国家国旗的下载任务封装为一个协程，进行并发编程。在协程中，对于每一个可能会发生阻塞，需要等待的操作，均使用yield from进行调用。当运行到此处时，程序会交出当前的控制权，异步调用并执行coroutine，当运行完返回之后才会将控制权交回给之前的线程。</p><p>当编写完协程函数之后，通过list comprehension批量生成协程对象，通过wait方法开启新的协程，来调用开启所有的任务协程对象。在通过loop.run_until_complete等待所有协程完成。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@asyncio.coroutine  # &lt;3&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_flag</span><span class="params">(cc)</span>:</span></span><br><span class="line">    url = <span class="string">'&#123;&#125;/&#123;cc&#125;/&#123;cc&#125;.gif'</span>.format(BASE_URL, cc=cc.lower())</span><br><span class="line">    resp = <span class="keyword">yield</span> <span class="keyword">from</span> aiohttp.request(<span class="string">'GET'</span>, url)  <span class="comment"># &lt;4&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> resp.read()  <span class="comment"># &lt;5&gt;</span></span><br><span class="line">    <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@asyncio.coroutine</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span><span class="params">(cc)</span>:</span>  <span class="comment"># &lt;6&gt;</span></span><br><span class="line">    image = <span class="keyword">yield</span> <span class="keyword">from</span> get_flag(cc)  <span class="comment"># &lt;7&gt;</span></span><br><span class="line">    show(cc)</span><br><span class="line">    save_flag(image, cc.lower() + <span class="string">'.gif'</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_many</span><span class="params">(cc_list)</span>:</span></span><br><span class="line">    loop = asyncio.get_event_loop()  <span class="comment"># &lt;8&gt;</span></span><br><span class="line">    to_do = [download_one(cc) <span class="keyword">for</span> cc <span class="keyword">in</span> sorted(cc_list)]  <span class="comment"># &lt;9&gt;</span></span><br><span class="line">    wait_coro = asyncio.wait(to_do)  <span class="comment"># &lt;10&gt;</span></span><br><span class="line">    res, _ = loop.run_until_complete(wait_coro)  <span class="comment"># &lt;11&gt;</span></span><br><span class="line">    loop.close() <span class="comment"># &lt;12&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> len(res)</span><br></pre></td></tr></table></figure><p>PS： 1. 可能会出现的阻塞应该全部使用异步调用。因为这里采用的是event loop，其实还是在同一个线程，如果使用了线程阻塞的操作，依然会阻塞其余所有的操作。因而应该使用异步调用的方式，如aiohttp进行http请求，或者asyncio.sleep进行休眠操作，当会发生阻塞的时候，抛出控制权给回event loop 2. 此处调用wait后再调用run_until_complete，需要等到全部协程完成时才会一并返回结果，不利于判断完成情况。可以利用asyncio.as_completed进行代替，可以马上返回以及完成的任务 3. 只有通过loop或async中相关的run方法，任务才会被执行</p><h3 id="update">update</h3><p>在Python3.5中，引入了关键字async和await，以及coroutine类型。可以更加清晰地使用asyncio进行并发编程。其中async等价于装饰器<code>@asyncio.coroutine</code>，可以将函数声明为coroutine对象。await关键字则可以取代yield from关键字，进行异步函数的调用。看了看变化还挺大的，尽管核心的思想没变，还是需要重新看看。具体的文档<a href="https://docs.python.org/3/library/asyncio.html" target="_blank" rel="noopener">见此</a></p><h2 id="后记">后记</h2><p>在学习了Fluent Python中的并发编程之后，突发兴趣打算使用asyncio和concurreny.futures来重写之前的漫画下载任务，来看看实际的效果提升。尽管在看书的过程中，感觉自己掌握得好像还行，对于样例代码也能一看就可以理解，而且目标任务也比较简单，应该可以比较快就实现目标任务。然而实际操作编写代码就发现并不是这么简单。首先，书中的代码有些已经落后（如async和await关键字没有引入），越看文档就越能发现新的features，有些还与书中的样例代码有所出入。其次，现实中代码的实际运行状况远比书中的理想状况复杂。就错误处理而言，一开始并没有做错误处理，导致出错后就静静地挂起，没有提示，也不会结束。后面做了简单的错误处理后发现，异常类型真可谓各式各样。最后，就是书中不能对全部状况状况作出全面的介绍，存在着许多未知的状况。发现很多错误也还好，最怕的是发现不了错误，或者知道有问题但是找不出来，还没有信息。</p><p>coding还是需要多动手实践，从具体的代码编写入手，这样才能真正提高所谓的coding 能力，否则只看书的话，很容易就会陷入一种我都会了的感觉，但这其实只是我都知道的状态，并不代表我都会用，我都能用，我都可以用好。看书更多的是留下一种对某方面知识或技能的印象，当需要的时候能够根据这些印象进行快速的索引和学习，重新获取知识。两者都很重要，缺一不可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;尽管Python当中有着GIL（Global Interpreter Lock）的限制，在同一时间当中一个进程只能由GIL解释单个线程的代码，但是合理地进行并发编程，仍然可以解决不少的性能瓶颈问题，大大提高效率。尤其是在看完Fluent Python之后，对于Python的并发编程有了更加深厚的了解。 以下介绍几种可用的并发编程方式，以及它们相关的概念和使用的基本方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 学习" scheme="http://scottyeung.top/categories/Coding-%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>记一次漫画批量的爬取/下载</title>
    <link href="http://scottyeung.top/2020/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%BC%AB%E7%94%BB%E6%89%B9%E9%87%8F%E7%9A%84%E7%88%AC%E5%8F%96-%E4%B8%8B%E8%BD%BD/"/>
    <id>http://scottyeung.top/2020/记一次漫画批量的爬取-下载/</id>
    <published>2020-02-28T14:01:33.000Z</published>
    <updated>2020-07-16T16:28:17.890Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景">背景</h1><p>想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。</p><a id="more"></a><h1 id="实现思路">实现思路</h1><p>漫画下载无非就是图片的抓取下载，也算是一种比较简单的爬虫。分析选为抓取来源的网页的URL，发现其URL规律为<code>host/type/漫画的ID+漫画章节号+第几页</code>，可以按照该规律生成所有漫画每一页的URL，则可以根据每一个URL获取里面的漫画图片下载。进一步分析这些页面上漫画图片的URL，发现是跳转到一个ASP页面进行提供，链接为三级ID组成，包括漫画ID，章节号，页码组成。在浏览器直接访问图片的URL，发现会跳转到404页面。根据开发者调试工具的Network栏中拦截的请求，发现图片实则来自另一个URL，并且图片URL的规律十分明显。于是问题就转变成根据规律批量生成图片的URL并下载。</p><h1 id="具体实现python">具体实现：Python</h1><p>为了简单，就没有使用任何的轮子。直接使用requests库访问这些URL获取图片资源，并写入到本地文件中保存。</p><h2 id="v1">v1</h2><p>具体的实现思路大概如下。对于漫画的每一话，先创建目录，然后根据该话的序号和页面生成目标资源URL，发送GET请求获取资源，通过文件写入保存到本地，直到访问的URL不存在漫画图片，跳转到404页面，此处我们通过判断响应首部的内容长度是否等于404图片的大小来判断该话是否结束爬取。根据漫画的总数，对每一话进行下载。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">baseUrl = <span class="string">'https://www.xxxxxx.com/1234/1234/&#123;0:0&gt;3d&#125;/&#123;1:0&gt;3d&#125;.jpg'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getChapter</span><span class="params">(no)</span>:</span></span><br><span class="line">    <span class="string">'''获取并保存第no话的漫画'''</span></span><br><span class="line">    cnt = <span class="number">1</span></span><br><span class="line">    os.mkdir(saveDir + str(no))</span><br><span class="line">    req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    print(req.status_code, req.headers)</span><br><span class="line">    <span class="keyword">while</span> req.status_code == <span class="number">200</span> <span class="keyword">and</span> req.headers[<span class="string">'Content-Length'</span>] != size404:</span><br><span class="line">        <span class="keyword">with</span> open(saveDir + str(no) + <span class="string">'/'</span> + str(cnt)+<span class="string">'.jpg'</span>,<span class="string">'wb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(req.content)           </span><br><span class="line">        cnt += <span class="number">1</span></span><br><span class="line">        req = requests.get(baseUrl.format(no,cnt))</span><br><span class="line">    <span class="keyword">return</span> cnt - <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="效果">效果</h3><p>实在是太慢了！</p><p>尝试着下了一话大概花费半到一分多钟左右，这里总共有一百多话，两个多小时肯定是走不掉了，而且还没考虑网络不稳定的因素。考虑了一下其中效率的制约因素，最主要为： - 网络请求。发请求获取资源需要传输时间。 - IO。图片保存到本地需要写入时间。</p><h2 id="v2">v2</h2><p>考虑使用多线程进行并行下载，进而提高速度。虽说Python提供的多线程只是伪多线程，实际上还是只能有一个线程被核心处理，但应该还是可以减少其中的等待时间。采用threading.Thread对象，将下载任务分成若干个patch交由不同的线程完成，每个线程完成20话的下载任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPatch</span><span class="params">(start,size,max_chapter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start,min(size,max_chapter)+<span class="number">1</span>):</span><br><span class="line">        print(<span class="string">'save chapter &#123;:0&gt;3d&#125; page &#123;:0&gt;3d&#125;'</span>.format(i,getChapter(i)))</span><br><span class="line"></span><br><span class="line">patch = <span class="number">20</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    t = threading.Thread(target=getPatch,kwargs=&#123;<span class="string">'start'</span>:i*patch+<span class="number">1</span>,<span class="string">'size'</span>:patch,<span class="string">'max_chapter'</span>:<span class="number">136</span>&#125;)</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><h3 id="效果-1">效果</h3><p>并没有提升多少速度。感觉这个多线程并没提高多少并行程度，我开了7个线程，但是最开始只创建了4文件夹进行下载，在这4话中进行调度交替下载。也不知道花了多少时间，下完这4话之后，我就强制关掉了，弃掉该方案。</p><h1 id="具体实现goland">具体实现：Goland</h1><p>说到多线程，最方便的肯定就是Go语言了，直接的关键字支持多线程。于是拾起很久没碰过的Goland，甚至新电脑上还没安装环境，还需要重新安装Go语言，配置环境和开发工具，就下Vscode的插件都花了点功夫。</p><p>实现思路还是同Python版本一样，为了简单不使用任何额外的轮子，直接使用net/http包进行http访问，获取图片，并写入到本地文件。</p><h2 id="v3">v3</h2><p>具体的单话下载代码如下。方法跟Python版本的几乎一样，不过Go语言做了额外的错误处理，显得有点冗余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downChapter</span><span class="params">(no <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">page := <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> ;; page++ &#123;</span><br><span class="line">_, err := os.Stat(fmt.Sprintf(saveDir, no))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(fmt.Sprintf(saveDir, no))</span><br><span class="line">os.Mkdir(fmt.Sprintf(saveDir, no), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line">res, err := http.Get(fmt.Sprintf(baseUrl, no, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> res.Header.Get(<span class="string">"Content-Length"</span>) == size404&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">file, err := os.Create(fmt.Sprintf(saveDir, no) + fmt.Sprintf(postfix, page))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">io.Copy(file, res.Body)</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down chapter %3d with %3d pages\n"</span>,no,page)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Go语言最主要就是要用它的多线程特性。在Go中只需要在调用函数前加上关键字Go就可以开启新的多线程调用函数。将下载任务分成20个为一批的多个patch，开启了7个线程进行下载。此处使用WaitGroup进行多线程的等待，避免主线程提前结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">downPatch</span><span class="params">(start, patch, maxChapter <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">cnt:=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> no:=start;no&lt;=start+patch &amp;&amp; no&lt;=maxChapter;no++&#123;</span><br><span class="line">downChapter(no)</span><br><span class="line">cnt++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"down patch from %3d to %3d total %d"</span>,start,start+cnt<span class="number">-1</span>,cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;maxChapter/patch;i++&#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> downPatch(i * patch,patch,maxChapter)</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">"finish!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="效果-2">效果</h3><p>速度确实提升了，但是感觉没有到很快的程度。。。</p><p>直到写文章的此刻，跑了两个半小时，下了大概86话。打开任务管理器看了看情况，CPU占用率一直很低，磁盘读写占用也很低，感觉瓶颈就在网络传输上面。另外，觉得7个线程也开得有点少了，应该多开一点，榨干电脑的性能，而且开多了也不会有很大的浪费。不过似乎制约速率的瓶颈就这网络传输上面，确实没办法。</p><h1 id="思考">思考</h1><ul><li>对于网络爬虫/下载，最为制约效率的因素始终是网络因素，这个也是我们最不能把握的。可能是服务器端的接入速率因素，可能是服务器端的处理计算速度因素，可能是链路的传输速度因素，还可能是墙的因素，有很多的可能性。</li><li>在程序刚运行的时候，我想到过多的http请求会不会把那个站点搞崩。一百多话，每画平均25页，接近三千多张图片，需要发三千多个http请求，会不会over了，不过在当前这个速度下显然是想多了。不过这在以后的爬虫获取数据或者资源的时候确实需要考虑，为他人想想，可以考虑加点间隔时间。</li><li>东西不用了就会忘记，技能确实需要是不是拾起来使使。</li><li>有时候问题并不是在选择的方法或工具上面，可能只是简单的自己做错了/做得不够，或者当时的环境不行。</li></ul><h1 id="后记">后记</h1><p>最终因为电脑在休眠的时候自动更新，强行重启了，最终还是没下完，大概下了120话，花了4个半小时，远远超出我的预期。大概原因为</p><ul><li>线程设置有误。原本想设置7个线程，但没考虑到Go里面除法取整，少了一个线程，最后一个patch的任务没有执行，实际是六线程运行。</li><li>代码存在一些不合理的地方，造成了操作上的重复。如判断在每一话当中判断文件夹是否存在，我把他放到了循环当中，每下载一页的图片前都会判断；还有设置patch的时候没有考虑开闭区间，且下载的时候没有判断文件是否已经下载，导致首尾的漫画重复下载。</li><li>后期漫画的图片质量上去了，由前面的一百几十kb提升到后面的四五百kb，所以负责后面漫画下载的线程速度较慢，速度没有达到预期。</li><li>网络问题。可能昨天晚上的网确实不行，也可能是频繁访问被制约了网速。</li></ul><p>今天早上用Python把剩下的十几话下载下来，发现其实昨天的多线程代码有问题，修改了一下，顺利下载，而且速度还不错，我开了6个线程，下18话用了不到20分钟。看来还是网络的问题，难顶。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;想找回一部很久之前看的漫画，网上的资源较少，大多都已被封禁，少数能看的网页加载还超级慢，有些图片显示还非常奇怪，影响正常阅读，遂萌生了下载下来在本地看的想法。后来找到一个网页，显示正常，能看，但是速度有点不稳定，于是就选择爬取该网页，将漫画全部下载到电脑上。&lt;/p&gt;
    
    </summary>
    
      <category term="Coding 记录" scheme="http://scottyeung.top/categories/Coding-%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="经历回顾" scheme="http://scottyeung.top/tags/%E7%BB%8F%E5%8E%86%E5%9B%9E%E9%A1%BE/"/>
    
      <category term="并发编程" scheme="http://scottyeung.top/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
      <category term="Golang" scheme="http://scottyeung.top/tags/Golang/"/>
    
      <category term="爬虫" scheme="http://scottyeung.top/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>太极拳中的劲</title>
    <link href="http://scottyeung.top/2020/%E5%A4%AA%E6%9E%81%E6%8B%B3%E4%B8%AD%E7%9A%84%E5%8A%B2/"/>
    <id>http://scottyeung.top/2020/太极拳中的劲/</id>
    <published>2020-02-16T14:59:05.000Z</published>
    <updated>2020-07-16T16:28:17.629Z</updated>
    
    <content type="html"><![CDATA[<p>相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。</p><a id="more"></a><p>最近，又开始寻找锻炼方式，最好是一种万能的方法，能够对全身有着极大的帮助，于是又开始转回太极，在YouTube上面学了几个动作，回家后又再次搁置下来。在书柜乱翻时，心血来潮将高中时买的一本书《内家拳的瑰宝——懂劲》再次拿出来看看。这本书主要是描述内家拳当中最重要的核心——劲。所谓的劲，比较玄乎，大致的理解为肌肉收缩产生力，筋的收缩则产生劲。从太极拳等内家拳当中领悟到劲的感觉，且带着劲来打拳架，才是真的入门，用书中的话来说，才能到达“阶及神明”的地步。主要的好处有：</p><ul><li>劲能够刺激锻炼到全身，对身体当中的筋有很好的锻炼效果</li><li>通过劲在打拳当中能够更好的效果，尤其是在推手或技击中</li><li>只有领会到真正的劲，才能体会到太极当中的松，在生活当中有更好的状态</li><li>不伤身，可长久练习，不像一些刚猛的技击方法，对身体有所损耗</li></ul><p>怎样练习而找到这种劲呢？当时第一次看这本书，就是因为书中写得太过玄乎，而练习方式的叙述又太简单，被当时因学业紧张而对时间使用非常功利的我放弃掉。如今在家里比较闲，生活没有那么紧张，而且对有无所成感到没什么要求，又重新找了一下。劲怎么来？主要是从地来，力从地起，通过脚对地面的各种接触方式，产生根劲。再通过筋脉，由脚到腿，由腿到腰，由腰到全身。怎么练习呢？个人感觉关键有两点，一是怎么由脚产生劲，二是怎么在全身传导劲。前者，书中讲到一个脚掌落地与落地的方式，以左脚为例，从右上方根据顺时针分成四块，落地顺序为一四二三，离地则反过来。后者则需要注重旋转，变换重心等方式来转移劲。当然纸上谈兵非常简单，真的练习找到感觉非常困难，且是需要那种讲究顿悟的学习。具体的练习可以站桩，或者走拳架。书中给出了作者简化的二十二式太极拳，每天走十遍左右，可以试试感悟，不过书中的每一式就附上一张静态图片和一段文字解释（甚至不是动作描述），学会还是有难度的，不过太极拳的招式大致相同，且并不需要走套路，单独的招式也有效果（可能），网上找找估计能找到。</p><p>附上书中的二十二式太极拳：</p><blockquote><p>起势，左掤，右掤，捋，挤，按，单鞭，采，挒，肘，靠（左右二式），提手上式，搬拦捶，右斜飞式，搂膝拗步（三式），上步十字手，半步崩拳，抱虎归山，如封似闭，倒撵猴（三步），半单鞭（三式），左每人照镜，收势。</p></blockquote><p>常说传武式微，但就当前这种环境以及流传下来的资料，确实难以传承，就这本书来讲，一味地讲理论，讲劲的好处，而练习方式，拳架教学，只有短短不到三十页，还不到全书五分之一，仅凭这些就能够学会的确实是天赋非凡。因为没有资料，只能靠师傅人工传承，但终有各种的不方便，最主要的，还是好师傅难寻，寻到也不一定愿意教，这样的环境，技艺失传又有何奇怪。不过我也没想着练出啥绝世的武功，无非是希望能锻炼下身体，以及能够以太极的松柔状态来过生活，仅此而已，所以随缘就好。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;相信每个男生一直以来都有练习武术的想法，一是想强身健体，二是可保护自己，幻想着如同武侠小说中主角般生活。我也不例外，自小就比较好动，加上一直都比较胖，就有着搞点运动的想法，武术就是当中一个很好的选择。最开始在贴吧上面接触到的就是太极拳与站桩，感觉很玄乎，也好像很厉害。后来叶问兴起，人人都在谈咏春，我也跟我堂哥学习了一下，在网上学了小念头。上了高中之后，追求先进，又开始向拳击，散打等靠拢。最终一无所获，不过也不觉得有什么可惜。&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://scottyeung.top/categories/%E6%9D%82%E8%B0%88/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="运动" scheme="http://scottyeung.top/tags/%E8%BF%90%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>就医当中的医疗选择——《最好的抉择》读书总结</title>
    <link href="http://scottyeung.top/2020/%E5%B0%B1%E5%8C%BB%E5%BD%93%E4%B8%AD%E7%9A%84%E5%8C%BB%E7%96%97%E9%80%89%E6%8B%A9%E2%80%94%E2%80%94%E3%80%8A%E6%9C%80%E5%A5%BD%E7%9A%84%E6%8A%89%E6%8B%A9%E3%80%8B%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    <id>http://scottyeung.top/2020/就医当中的医疗选择——《最好的抉择》读书总结/</id>
    <published>2020-02-01T09:20:32.000Z</published>
    <updated>2020-07-16T16:28:17.681Z</updated>
    
    <content type="html"><![CDATA[<p>在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。</p><a id="more"></a><h2 id="理想状况">理想状况</h2><p>最理想的就医情况，莫过于在就医时，医生可以根据个人的具体情况，进行具体的分析，对于病症，给出可供选择的治疗方案。每个方案，都给患者进行完备的解释，包括具体流程，治疗效果，方案成功率，副作用的几率及程度，并且可以提供一定的数据，对效果和概率进行形象化的说明。患者可以根据医生提供的方案和说明，清楚自己的选择可以带来的效果和副作用，并向医生提出自己的疑问和担忧以获得解答。最终两者达成一致，进行治疗。</p><p>但事实上，这样的理想情况，很难出现，尤其是在国内的就医环境当中。医生往往因为无法根据患者的具体情况进行判断，一是会诊时间不多无法对患者进行详细的询问以获取更多信息，二是病患有些时候也不知道如何表达自身情况，应该告诉医生什么信息。所以医生有些时候只能流水线般地给出一些固定的方案。另外，因为患者有些时候对于医生的权威有着畏惧，不敢提出自己的疑问，甚至反对意见。病人怕于见医生，怕于反对医生，最后可能糊里糊涂地就接受了医生的某个方案，最终只能对着不好的效果后悔。</p><p>所以，就医过程中，需要考虑若干因素，从医生的角度，从病人自己的角度，做出最佳选择。</p><h2 id="医生的建议">医生的建议</h2><p>当医生给出若干的选项，然后建议你其中一个最好时，甚至医生只给你提供了一个医疗选项，说其它的不够好时，你是否应该听从呢？</p><p>书中讲到了一个治疗甲亢的例子，主人公因为甲亢而去看内科医生，医生给出的方案是让其服用放射性碘丸，利用放射性烧掉甲状腺，日后通过口服甲状腺激素进行补充替代，需要终生服药。破坏掉人体中的一个器官，并且终身都离不开某种药物，相信很多人都不太能接受，真的只有这种方法吗？患者经过查询向其他医生求助时发现，其实还有两个方法，一是手术切除甲状腺，后续终身服药，另一种是通过服用一些抑制药物来抑制症状。在得知这些信息后，患者重新去询问该内科医生，医生只是简单地回答这个方法效果最好，好在哪里，也说不出个所以然。但是根据数据统计，其实三种方法的效果都差不多，而放射性碘丸还可能有辐射到其它器官的风险。说是最好，也未必是。</p><!-- 医生的偏见。 --><p>医生会有这样不同的观点，很显然医生也有着自己的偏好，当可供选择的方案相差不大时，医生可能会因为自己的主观因素而对其中的某种选择有着更高的偏好，或者对某种方案有着偏见。如同上面提到的三种方案，根据调查，经历过地震导致核泄露的日本医生就会更偏向于不使用放射性碘丸，而传统的极端的医生则倾向于通过手术切除甲状腺，一步到位。带有偏好的选项，真的适合我们吗？我们做出的选择恐怕会受其影响。为了避免这种情况的出现，不妨对医生深入地询问备选方案，问清其利弊，偏好或是建议的原因。若在该医生处得到的信息不够完备，不妨多问几个不同的医生，上网查询相关的方案信息和病例数据。</p><h2 id="选择的影响因素">选择的影响因素</h2><p>除了医生的影响之外，影响病人做出医疗方案选择的，还有许多因素。在选择时，我们需要考虑这些因素，排除噪声影响。</p><h3 id="易得性因素">易得性因素</h3><p>对于听到的具体的传言或故事，我们的印象总是要比冰冷的数据更为深刻。尽管医生推荐你可以用方案B，告诉你方案B相较于方案A的成功率要高，副作用相对可能较少，但若果你知道身边的某个人通过方案A成功治愈，且效果良好，没有副作用，你也会被这个真实的例子吸引住，进而选择方案A而不是方案B，因为你不知道这个成功率高，可能较少，是一种什么情况。同理，像治疗高血脂的药，如果不服用降低血脂，会有一定的概率出现心血管疾病，但是服用药物有一定的概率出现不良反应。一般来说，医生应该给出不服用的心血管患病概率，以及不良反应的症状和概率，由患者进行权衡（不过在国内好像很少会考虑药物的不良反应，都是有症状就直接开，出现不良反应就再治不良反应或换药）。尽管可能不良反应概率可能很低，或者可以通过停药而消失，但如果你的身边有人服用这些药物出现不良反应，而且消失不了，相信你的心里对服用这些药物也会有着一定的介怀。</p><h3 id="自然主义与极端主义">自然主义与极端主义</h3><p>有一部分人，对于服用药物，进行手术等通过外力改变身体状况的方式比较排斥，这些人可以成为自然主义者，这些人信奉可以通过自己调整生活方式或生活状态，使身体自然恢复。当身体出现某些症状后，他们第一时间通过调整生活方式，试图消灭这些症状，当没有效果时，他们才会去寻求医生和药物的帮助，即使如此，他们仍然希望接受最少的治疗，他们的内心对于医学有着一定的怀疑。与之相对的，还有极端主义者。他们一旦身体出现了某些症状，甚至只是某些身体指标的升高，他们就会第一时间寻求医生的帮助，试图通过药物或手术让身体指标回复正常，不能容忍身体存在一丝异常。</p><p>此处并不能指出两者谁更好，两者都有正面与反面的例子。当然这两者都比较极端，我们在生活中也很少极度偏向一端，而且我们的观点也很可能会随着某些事情的出现而改变。既然有着某一边的偏向，就要向医生表达出来，达成妥协，不然在治疗过程中，内心可能会心生不满，甚至事后埋怨治疗结果。</p><h3 id="病人的交流">病人的交流</h3><!-- 向病人寻求咨询和交流，获取信息以帮助交流 --><p>上面提到的易得性原则，大多数具体信息的获得来自于其它病人。当我们患病需要寻求其它信息帮助我们做出选择时，我们可以通过求助于此前使用这些治疗方法的病人。通过他们，我们可以获取详细而真实的信息，病人往往无所顾忌，对于疗效和后续的不良反应能够直接表达。当然，有些时候，病人也可能会因为某些原因而隐瞒一些状况。这就需要自己思考过滤信息了。</p><h3 id="承受程度">承受程度</h3><!-- 低估对生活状况的忍受程度。觉得接受不了，其实未必 --><p>在我们健康的时候，我们总会对生活质量的下降而感到不能忍受，就如若让你去除双眼以保住性命，很多人可能宁可不活了，也不能忍受失明后的生活。我们很多人其实都低估了自身对于生活质量下降的承受程度，觉得不能承受这些改变。不过当我们真的不得不做出如此改变，生活质量下降之后，我们其实也能够迅速适应，并且觉得不以为然。</p><blockquote><p>许多心理学研究发现，人们往往低估了自己适应新环境和新情况的能力。很多健康的人会把遭遇某种医疗问题后生活的“效用”或者“价值”低估，但是真正有这些问题的人却远没有那么悲观。比方说，健全的人会认为失明是非常糟糕的事情，但是失明几年之后的盲人却认为情况没有健全的人想的那么坏。这对那些在肠道造口术后无法控制排便的人也一样。许多健全人觉得这些结果非常可怕，所以给它们的“效用”或者“价值”打了非常低的分数，但是那些需要承受这些结果的人却觉得生活比前者所想的好多了。<strong>人们的适应能力其实是很强的，我们总能够在生活中发现“价值”，总有未爆发的抗挫潜力</strong>。</p></blockquote><h2 id="代理人的选择">代理人的选择</h2><!-- 代理人为在病人无法做出选择时，替代其做出医疗方案选择的人。三个原则：自决性，行善性，不伤害性。 --><p>除了需要病人自己做出选择以外，在有些特殊情况，还需要选择代理人，通过代理人来替自己做出选择。所谓的代理人，为在病人意识不清楚而不能做出决定时，代替病人做出选择的人。代理人做出的选择，也是需要通过非常艰难的抉择，一方面要符合病人的意愿，选择不能让其反对，必须要他接受，另一方面又要最为适合病人，效果最好。当病人的意愿与最佳疗法冲突时，当病人的想法与代理人的想法有出入时，当病人没有或无法表达选择意愿时，代理人应该怎样做出选择。</p><p>书中给出了三个原则以帮助代理人做出抉择，三种的优先级从高到低。首先是自决性原则，无论如何，承受治疗的主体都是病人本书，好与不好都由他本人承受，因而所有的选择都必须符合其意愿，至少在他做出选择的一刻是符合他当时的意愿的。其次，则是行善性，所做出的选择必须是对病人有利的，是不是最优的先不谈，但必须是有帮助的，有帮助的可以先上。最后，是不伤害性，治疗方案应该尽可能对人体无害，当然这个在有些时候也不能百分百保证，尤其是当情况紧急，状况不佳时，不得不采取一定的权衡。</p><hr><h2 id="后记">后记</h2><p>书中称医学为一门精确而不确定的科学。说其精确，是因为现代医学将一切都数据化，精确化。对于某些症状，其数据指标符合特定的数据指标，则判定为某疾病，采用某治疗方式。然而这种全通过数据，机械化的诊断流程，真的可以适应任何人，满足任何人吗？在这样的灰色地带，想要做决定往往并不容易，选择也往往不是那么明显。因此，医学涉及医生和病人微妙并且私人的决定。</p><blockquote><p>通过研究和数据，我们可以知道在100位像苏珊·鲍威尔那样的妇女中，会有一两位患有高胆固醇，但究竟是哪一两位呢？同样，我们也无法判断在300位妇女中，有哪一位或者两位妇女服用他汀类药物会产生疗效。甚至通过检测带有遗传信息的BRCA基因，我们也只能得到一个癌症发病率的估计值。没有人能够确切地知道，哪位妇女会在哪个确定时间患上乳腺癌；也没有人能够清楚地指出心房颤动、前列腺癌或者其他的疾病会给个体的生活带来怎样的影响，某种治疗方案在某个人身上又会出现怎样的副作用。我们每个人都是由不同的基因组合以及各自的环境造就出来的独一无二的个体。怎样保持健康或者从疾病中康复，并没有一个统一的方法。 然而这一本质性的问题往往被一些专家忽视，他们试图将治疗标准化，而不考虑病人的个体需求。虽然有人把这些公式当作科学来看，但是其实这种方法的实质是要把患病的经验转变成数字，这种努力的方向其实就是错误的，是徒劳的。然而保险公司和政府官员却总是在给医生和医院施加压力，要求他们通过各种公式把医疗服务标准化。保单设计人员，甚至是某些医生自己都宣称，把医学当作一门艺术的想法已经过时了。现在，医疗服务应当按照工业生产的方式来提供，医生和护士只要按照操作手册亦步亦趋就可以了。这些人甚至认为，医生和病人没有资格决定什么治疗方案最好。所以，当他们大谈医疗改革的目标是“以病人为中心”的时候，他们其实追求的是“以体制为中心”。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在就医过程，存在着很多的选择，如何选择医生/医院，选择治疗方式/药物，以及治疗后如何选择恢复方式，都存在着许多的学问。在国内，大多数人就医时面对医生有着天然的敬畏，将医生的话视作权威，但是某个医生能够一直保持最正确的判断吗？难以保证。另外，当某些需要做出选择而承担责任的时候，当医生抛出治疗方式的选项时，我们又如何做出最合理，最适合病人情况，且又能满足病人的心里意愿的选项。本书通过若干的例子，对该问题进行深入的探讨。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Sum Circular Subarray</title>
    <link href="http://scottyeung.top/2020/Maximum-Sum-Circular-Subarray/"/>
    <id>http://scottyeung.top/2020/Maximum-Sum-Circular-Subarray/</id>
    <published>2020-01-21T11:59:53.000Z</published>
    <updated>2020-07-16T16:28:17.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="problem">Problem</h1><ul><li>source: <a href="https://leetcode-cn.com/problems/maximum-sum-circular-subarray/" target="_blank" rel="noopener">Maximum Sum Circular Subarray</a></li><li>difficulty: Medium</li></ul><p>Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.</p><p>Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, <code>C[i] = A[i] when 0 &lt;= i &lt; A.length</code>, and <code>C[i+A.length] = C[i] when i &gt;= 0</code>.)</p><p>Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray <span class="math inline">\(C[i], C[i+1], ..., C[j]\)</span>, there does not exist <span class="math inline">\(i &lt;= k_1, k_2 &lt;= j\)</span> with$k_1 mod A.length = k_2 mod A.length $.)</p><a id="more"></a><h2 id="examples">Examples</h2><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,-2,3,-2]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] has maximum sum 3</span><br></pre></td></tr></table></figure><p>Example 2: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [5,-3,5]</span><br><span class="line">Output: 10</span><br><span class="line">Explanation: Subarray [5,5] has maximum sum 5 + 5 &#x3D; 10</span><br></pre></td></tr></table></figure> Example 3: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-1,2,-1]</span><br><span class="line">Output: 4</span><br><span class="line">Explanation: Subarray [2,-1,3] has maximum sum 2 + (-1) + 3 &#x3D; 4</span><br></pre></td></tr></table></figure> Example 4: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,-2,2,-3]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: Subarray [3] and [3,-2,2] both have maximum sum 3</span><br></pre></td></tr></table></figure> Example 5: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [-2,-3,-1]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Subarray [-1] has maximum sum -1</span><br></pre></td></tr></table></figure></p><h2 id="notes">Notes</h2><ol type="1"><li><span class="math inline">\(-30000 &lt;= A[i] &lt;= 30000\)</span></li><li><span class="math inline">\(1 &lt;= A.length &lt;= 30000\)</span></li></ol><h1 id="solution">Solution</h1><h2 id="暴力法">暴力法</h2><p>因为太久没有做过题了，对题目都没什么感觉了，感觉有点熟悉，好像可以用 DP（发现是暑假的时候在紫书中看过），但是一下不知道怎么用。于是先用暴力法试试水。</p><p>题目当中要求的是最大子段和，所以考虑枚举所有的子段，每个子段包含一个普通的区间和一个首尾相接的连续区间。 枚举的情况有 <span class="math inline">\(2 * C_n^2\)</span> 种，每种情况计算子段和可以通过累计前缀和来计算，总复杂度为 <span class="math inline">\(O(n^2\)</span>)。</p><p>最后结果为超时，大概能过 91 / 109 个样例。</p><h2 id="最大子序列和算法">最大子序列和算法</h2><p>暴力法超时后思考无果，上网看看别人的思路。发现求解最大子序列的和有一个很好的算法，就是 <a href="https://zh.wikipedia.org/wiki/%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E5%88%97%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">Kadane 算法</a>。很好理解，直接在下面提出代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    ans = cur = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr[<span class="number">1</span>:]:</span><br><span class="line">        cur = arr[i] + max(cur, <span class="number">0</span>)</span><br><span class="line">        ans = max(ans, cur)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>源方法来自于DP的化简，设 <span class="math inline">\(dp[i]\)</span> 为数组以元素 <code>arr[i]</code> 结尾的最大子序列和，则有下列的转移方程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i+<span class="number">1</span>] = dp[i] + arr[i+<span class="number">1</span>] <span class="keyword">if</span> dp[i] &gt; <span class="number">0</span> <span class="keyword">else</span> arr[i+<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>实际使用过程中无需存储dp数组，为了降低空间复杂度，使用数值变量记录数值即可。</p><h2 id="问题进一步分析">问题进一步分析</h2><p>于是问题就变成了在求解数组的最大子序列和的基础上，进一步考虑双向区间的和。原本的子序列，只考虑数组的单向区间，这一块可以通过kadane算法求解，所以所需考虑的问题为怎么求双向区间（一头一尾组成）的子数组和。大致有下面三种方法。</p><h3 id="相邻数组法">相邻数组法</h3><p>单区间子序列的最大值可以通过Kadane算法直接求出。 环形序列的双区间子序列则可分成左右两部分来找出，我们定义 <code>maxright[i]</code> 为下标为i的元素右侧的最大子序列和，这个可以通过一次倒序扫描求出。所以双区间最大子序列和为 <code>max(leftsums[i] + maxright(i+1) for i in range(N-2))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun1</span><span class="params">(A)</span>:</span></span><br><span class="line">    ans = cur = A[<span class="number">0</span>]</span><br><span class="line">    N = len(A)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N):</span><br><span class="line">        cur = A[i] + max(<span class="number">0</span>,cur)</span><br><span class="line">        ans = max(ans,cur)</span><br><span class="line"></span><br><span class="line">    leftsums = [A[<span class="number">0</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N): leftsums[i] = leftsums[i<span class="number">-1</span>] + A[i]</span><br><span class="line"></span><br><span class="line">    rightsums = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    maxright = [A[<span class="number">-1</span>] <span class="keyword">for</span> _ <span class="keyword">in</span> range(N)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(N<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>):</span><br><span class="line">        rightsums[i] = rightsums[i+<span class="number">1</span>] + A[i]</span><br><span class="line">        maxright[i] = max(maxright[i+<span class="number">1</span>],rightsums[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,N<span class="number">-1</span>):</span><br><span class="line">        ans = max(ans, leftsums[i<span class="number">-1</span>]+maxright[i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h3 id="变号法">变号法</h3><p>本方法将双区间的序列和转化为整个数组的总和减去单区间子段和，其值为<span class="math inline">\(S - \sum_{k=i}^jA_k\)</span>，该值的最大值为后者取最小值时的值，问题变成求解数组元素i到j的最小值，将数组元素全体乘以-1，则变成求解最大值，可套用 kadane 算法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun2</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kadane</span><span class="params">(gen)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(gen) == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        ans = cur = gen[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> gen[<span class="number">1</span>:]:</span><br><span class="line">            cur = i + max(cur,<span class="number">0</span>)</span><br><span class="line">            ans = max(ans,cur)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br><span class="line">    alls = sum(A)</span><br><span class="line">    ans1 = kadane(A)</span><br><span class="line">    ans2 = alls + kadane([-A[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(A)<span class="number">-1</span>)])</span><br><span class="line">    <span class="keyword">return</span> max(ans1,ans2)</span><br></pre></td></tr></table></figure><h3 id="前缀和优先队列">前缀和+优先队列</h3><p>因为数组A的循环子段必然是数组B=A+A的子段，所以可将数组拼接一次在求单区间的最大子序列和，只需满足子序列长度不超过原数组长度。 对于子序列 <code>B[i+1:j+1]</code>，其和为 <code>P[j]-P[i]</code>，这里我们固定j，找出使 P[i] 最小的 i 值，可通过优先队列实现，这里通过在插入元素时比较当前元素与队列末元素的大小进行插入处理，手动实现优先队列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">(A)</span>:</span></span><br><span class="line">    P = A * <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        P[i] = P[i] + P[i<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    queue = deque([<span class="number">0</span>])</span><br><span class="line">    ans = A[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,len(P)):</span><br><span class="line">        i = queue[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">while</span> j - i &gt; len(A):</span><br><span class="line">            queue.popleft()</span><br><span class="line">            i = queue[<span class="number">0</span>]</span><br><span class="line">        ans = max(ans, P[j] - P[i])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> queue <span class="keyword">and</span> P[queue[<span class="number">-1</span>]] &gt; P[j]:</span><br><span class="line">            queue.pop()</span><br><span class="line"></span><br><span class="line">        queue.append(j)</span><br><span class="line">    <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;problem&quot;&gt;Problem&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;source: &lt;a href=&quot;https://leetcode-cn.com/problems/maximum-sum-circular-subarray/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Maximum Sum Circular Subarray&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;difficulty: Medium&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Given a circular array C of integers represented by A, find the maximum possible sum of a non-empty subarray of C.&lt;/p&gt;
&lt;p&gt;Here, a circular array means the end of the array connects to the beginning of the array.  (Formally, &lt;code&gt;C[i] = A[i] when 0 &amp;lt;= i &amp;lt; A.length&lt;/code&gt;, and &lt;code&gt;C[i+A.length] = C[i] when i &amp;gt;= 0&lt;/code&gt;.)&lt;/p&gt;
&lt;p&gt;Also, a subarray may only include each element of the fixed buffer A at most once.  (Formally, for a subarray &lt;span class=&quot;math inline&quot;&gt;\(C[i], C[i+1], ..., C[j]\)&lt;/span&gt;, there does not exist &lt;span class=&quot;math inline&quot;&gt;\(i &amp;lt;= k_1, k_2 &amp;lt;= j\)&lt;/span&gt; with$k_1 mod A.length = k_2 mod A.length $.)&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://scottyeung.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="LeetCode" scheme="http://scottyeung.top/tags/LeetCode/"/>
    
      <category term="DP" scheme="http://scottyeung.top/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>谈谈牙齿</title>
    <link href="http://scottyeung.top/2020/%E8%B0%88%E8%B0%88%E7%89%99%E9%BD%BF/"/>
    <id>http://scottyeung.top/2020/谈谈牙齿/</id>
    <published>2020-01-03T11:43:59.000Z</published>
    <updated>2020-07-16T16:28:17.904Z</updated>
    
    <content type="html"><![CDATA[<p>周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。</p><a id="more"></a><p>因为来得比较早，加上只是挂了个普通号，比较快就看上了。拍了个牙片，给医生看了看，病情和治疗方式基本如之前设想的一样，需要做根管治疗。所谓的根管治疗，是将牙齿内部的根管/神经清理干净，彻底清理消毒后，填入消毒材料进行填充。根管治疗后牙齿因为失去神经/根管的营养，会比较脆弱，需要加个牙冠。在医生再三向我强调根管治疗的注意事项以及协商了时间之后，我签署了同意意向书，开始治疗。给我看牙的是一个很温柔的女医生。暂时的治疗只是在病牙上打了一个洞，对牙齿内部进行了药物冲洗，让其暴露几天，流出之前的发炎的分泌物。治疗后就不怎么痛了，不过仍然要进行后续的治疗。</p><p>一直以来，我的牙齿都不是特别的好，这也已经不是第一次牙齿出问题了。在小的时候，对于牙齿不是很重视，在没换牙之前，牙齿就出过问题，换了牙之后，也出过不少的问题。在中考结束后，第一次补了牙，当时是因为大牙出现冷热酸痛。后面陆续补过几个牙，之后才开始重视牙齿问题。但已经感到有点为时已晚。个人感觉小地方的牙医诊所有些不足的地方：一是治疗追求治标，蛀牙了便补，牙痛了便打开杀神经再补，再痛就再来一次。二是没有一个很好的教育预防理念，牙痛/蛀牙去看牙，都是帮你补了就算，也没有告诉你成因，提醒了你应该怎么做，更不会顺便检查你的其它牙齿，最有趣的是我箍牙的时候的医生，经常跟我说我没有好好刷牙，但事实是我刷的认真且勤快，他也不给出具体的解释或者补充。</p><p>大一的时候也有出现过牙痛的状况，寒假的时候以为是普通的小事就忍了忍，开学就发作，也是跑去了武大口腔，两个连着的牙齿蛀了，其中一个还疑似深髓，可能要根管，当时对于金钱还比较敏感（也可以说是没这么多钱），听到要可能2000+之后就放弃了在那里治疗，忍了一个学期回去小城市治，方法就是普通的去除蛀牙部分，补牙，痛了就下杀神经的药，下周再来，陆续也治了三周，最后不痛了，也不知道是不是就算是治好了。</p><p>在当时回去治疗之前，上网看牙齿相关的资料，发现了一本很有趣的书 <em>Cure Tooth Decay: Heal &amp; Prevent Cavities with Nutrition</em> 是说用营养学来治疗牙齿疾病的，中心内容就是多吃富含脂溶性维他命的东西，鱼肝油，无机盐钙和镁，少吃升血糖指数高的和植酸食物。书中其实没给出什么比较科学的解释，基本都是通过一些资料/实际情况做的实证研究/统计，试了下，也就那样，该疼还是疼。</p><p>在这次痛的过程中，我又重新翻了翻这本书，又上网搜了搜这本书，结果在豆瓣找到了一个对于这本书的读者&amp;实证者，此处贴出他的一篇<a href="http://blog.sina.com.cn/s/blog_6e979bb90100mnf0.html" target="_blank" rel="noopener">文章</a> 基本上就是在上面的营养防治的理论的完善补充。为什么会蛀牙，出现牙病，原因无非是细菌繁殖在我们的牙齿上，造成了酸性的环境，腐蚀我们的牙齿。一直以来的理论，都是让我们通过刷牙来消灭这些细菌，但对于有些人，例如我，效果就属实一般，即使是使用电动牙刷+牙线+漱口水，该蛀还是得蛀。采用营养学的方法是另一种思路，通过加固/恢复我们的牙齿，进行防治。一方面，还是需要使用牙线+冲牙器清洁牙齿，去除细菌，但另一方面，还需要补充一些营养来恢复牙齿，加固牙齿。 书中给出的主要方法是：</p><ul><li>使用牙线 + <strong>冲牙器</strong> 来保持牙齿的清洁</li><li>补充维生素<span class="math inline">\(K_2\)</span>和<span class="math inline">\(D_3\)</span>帮助牙齿吸收钙质元素</li><li>补充钙和镁等矿物质</li><li>尽量避免摄入酸性物质，对牙齿有腐蚀作用的食物</li></ul><p>感觉还是挺有道理的，可以尝试一下。不过这些方法感觉都只能用在预防上面，当牙齿真的出了问题，还是建议去大医院好好地看看！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周一的时候突发急性牙痛，可能是周六的时候吃了烤羊肉，还喝了点啤酒。在知乎看了看，估计是牙髓炎或者是牙根尖周炎，大概就是细菌进入牙齿根部/牙髓引起发炎，炎症分泌物导致牙髓内压力增大，巨痛，基本不拔牙的话都要进行根管治疗，当然小地方的话可能就打开消毒，不痛后又重新不上。在痛了一个晚上后，根本睡不着觉的我第二天一早就跑去武大口腔治疗。&lt;/p&gt;
    
    </summary>
    
      <category term="个人随笔" scheme="http://scottyeung.top/categories/%E4%B8%AA%E4%BA%BA%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
      <category term="随笔" scheme="http://scottyeung.top/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>&lt;唤醒大脑：神经可塑性如何帮助大脑自我疗愈&gt; 读书笔记</title>
    <link href="http://scottyeung.top/2019/%E5%94%A4%E9%86%92%E5%A4%A7%E8%84%91%EF%BC%9A%E7%A5%9E%E7%BB%8F%E5%8F%AF%E5%A1%91%E6%80%A7%E5%A6%82%E4%BD%95%E5%B8%AE%E5%8A%A9%E5%A4%A7%E8%84%91%E8%87%AA%E6%88%91%E7%96%97%E6%84%88-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://scottyeung.top/2019/唤醒大脑：神经可塑性如何帮助大脑自我疗愈-读书笔记/</id>
    <published>2019-12-30T09:53:48.000Z</published>
    <updated>2020-07-16T16:28:17.596Z</updated>
    
    <content type="html"><![CDATA[<p>本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。</p><a id="more"></a><p>一直以来，大脑都是被认为是一个精密的仪器，一旦某处出现问题，身体就会出现相关的问题，且难以治疗。作者提出，可以利用神经可塑性的方法，使用一些自然的刺激手段，帮助大脑进行自我修复，进而治疗因大脑的问题而出现的疾病，如中风，帕金逊。</p><p>具体的疾病及其治疗如下：</p><h2 id="慢性疼痛">慢性疼痛</h2><p>疼痛其实并不是疼痛源引发疼痛而被大脑感觉到，而是大脑为了警告危险的出现，而发出疼痛的表现来提醒自身。每次疼痛，相应的神经元会进行放电，长期某个位置疼痛，会形成一个习惯，即使身体痊愈，疼痛系统仍然会放电，引发疼痛。</p><p>神经可塑性的一条核心规律是，同时启动放电的神经元是连接在一起的，也就是说，反复的精神体验使大脑处理该体验的神经元产生结构性变化，令神经元之间的突触连接更为强健。反过来也是一样。如果一个人长期放弃执行某一活动，这些连接就弱化了，随着时间的推移，很多连接甚至消失了。这说明了神经可塑性的一条更普遍的原理：用进废退现象。</p><p>疼痛需要大脑的神经元进行处理，因而我们可以通过分散大脑区域的资源，减少处理疼痛的大脑区域。具体可以通过可视化想象的方法来压倒疼痛。处理视觉信息和疼痛的有两个脑区，后扣带回（帮我们从视觉上想象东西所处的空间位置）和后顶叶（也用于处理视觉输入）。</p><blockquote><p>每当疼痛袭来，他就立刻开始可视化想象。但想什么内容呢？他想象的就是自己绘制的脑图，他提醒自己，大脑真的可以改变，好让自己保持动力。他先栩栩如生地想象大脑处于慢性疼痛中的画面，然后观察慢性疼痛过程中脑图有多少地方的神经可塑性在扩展。接着，他会想象启动放电的区域渐渐缩小，看起来就像是大脑没有感到疼痛时的样子。“我必须无情，比疼痛信号本身更无情。”他说。他用大脑疼痛区域缩小的画面迎接每一波疼痛，他知道，必须强迫自己的大脑后扣带回和后顶叶处理视觉图像。</p></blockquote><p>因为神经可塑性用进废退的特点，当每次慢性疼痛出现的过程，通过可视化的方式，分散/避开/减少大脑对疼痛的处理来减轻疼痛，弱化疼痛的感受，久而久之，疼痛的回路弱化，慢性疼痛的现象消失。</p><h2 id="走路疗愈帕金逊综合征的症状">走路疗愈帕金逊综合征的症状</h2><p>帕金逊综合征为大脑黑质出现问题，影响了关于身体活动所需的多巴胺，会导致身体的活动能力丧失，但通过每天坚持锻炼，尤其是走路，可以使身体保持活动的能力，当然这并不是治好帕金逊综合征，药物也不能轻易地减少，但通过保持每天的走路，保持每天的运动量，可以通过另一种方式来保持自身的活动能力。</p><hr><p>其它的章节感觉比较玄乎，篇幅也比较常，待填坑。包括：</p><ul><li>光帮助大脑连接</li><li>帮助自闭患者重新获得会话能力</li><li>一位盲人学会了看</li><li>重新习得发声的能力</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本书主要介绍如何通过一些物理方式（非药物），利用神经可塑性，帮助大脑进行自我疗愈。本书主要通过介绍作者遇到的病例，或者当前进行过的相关实验，来说明什么是神经可塑性，怎么利用神经可塑性帮助大脑疗愈，有什么具体的方式帮助了特定的什么疾病的恢复。整本书下来，其实作者并没有明确地输出什么理论/观点，同时通过摆出例子，使用春秋笔法来告诉大家，什么对什么有帮助，这样一来，可以避免放出研究的数据/实验支撑的需要，当然可信程度也随之下降，另一方面，这种讲故事的书对于我这种功利的阅读者也不太友好，都找不出重点进行阅读记录。最后只能翻了翻目录，大概记录下讲了些什么。&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="健康" scheme="http://scottyeung.top/tags/%E5%81%A5%E5%BA%B7/"/>
    
  </entry>
  
  <entry>
    <title>&lt;被讨厌的勇气&gt;读书体会与摘要</title>
    <link href="http://scottyeung.top/2019/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94-%E8%AF%BB%E4%B9%A6%E4%BD%93%E4%BC%9A%E4%B8%8E%E6%91%98%E8%A6%81/"/>
    <id>http://scottyeung.top/2019/被讨厌的勇气-读书体会与摘要/</id>
    <published>2019-12-19T04:08:40.000Z</published>
    <updated>2020-08-08T16:22:51.033Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://book.douban.com/subject/26369699/" target="_blank" rel="noopener">《被讨厌的勇气》</a>通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。</p><p>这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃</p><a id="more"></a><h2 id="正文">正文</h2><ul><li>世界是简单的，人也是简单的。复杂是因为人把世界看得复杂，这就涉及到有无勇气，正视世界的问题</li></ul><h3 id="另一种心理学">另一种心理学</h3><ul><li>另一种心理学：阿德勒心理学，属于目的论，对比于传统心理学流派的原因论，区别相当于想法影响情绪还是情绪影响想法。对于原因论，有几个问题：对于当前遇到的心里问题，一味分析其成因，对于解决问题没有太多实际的意义，如同感冒去看医生，医生只告诉你感冒是因为之前着凉了一样了；给予同样的经历，即原因相同，但是不同人会有不同的结果。目的论讲究目的，认为主要是取决于个人的看待态度与方式。重要的不是经验本身，而是对待经验的方式。换而言之，情绪是可以控制的，情绪只是某些时候特定行为的一个借口。同样，人的性格与本性也是可以改变的，受到自身的观念所影响，很多时候不是不想改变，而是自身不想改变，缺乏面对改变时可能会遇到的陌生与不安的勇气。另外，也担心改变之后失去了对当前不满的状况的解释借口。不去改变，借口没有这个条件才不能实现这件事情，这样就能掩饰自己实现不了这件事的状况。</li><li>自卑感与自卑情结。自卑感是一个很正常的感受，每个人都会有，健康的自卑感应该来自当前的自己与理想中自己的落差，而不应该来自与他人的对比。通过健康的自卑感，我们可以找到自己努力成为更好的自己的方向 。至于自卑情结，则是一种不健康的状态，由不健康的，过度的自卑感来形成。带有自卑情结的人，往往会将生活遇到的问题，对当前状况的不满，归结于当前所拥有的自卑感。因为在某些条件上处于落后，感到自卑，所以在某些事情上面失败就有理由了，要不是那样，我就怎么样了。因为有着可以逃避的借口，带有自卑情结的人会一直处于这种自卑的状态来保护自己。另外，自卑情结还会带来：权势张越，因为自身的不自信，所以需要通过一些外在的事物/功绩来夸耀自己；弱者保护，我弱我有理，因为我弱，所以我做出了某些成绩我就是了不起，做不出来的话则是我本应如此。</li></ul><h3 id="关于竞争">关于竞争</h3><ul><li>竞争应该是在一张平面上各人沿着自己的方向按照自己的速度前进，竞争的对象应该是自己，而不是其他人。每个人的速度不一样，必然有人走在前面，有人走在后面。走在前面的未见得能够一直保持走在前面，如果选择了不当的对比对象，只能造成自身长久的失败感。另外，将他人放在竞争对手的位置上面，很难够成为真正的伙伴。竞争必然存在输赢，有时候我们不能发自内心地为他人的成功高兴，就是因为将其放在竞争对手的位置上面，因而会有他人的成功等同于自身的失败这种想法。</li><li>基于上面的原因，也没有必要与人争执，尤其是争执的程度发展到企图通过发怒来解决。发怒不只是情绪，其实也是你的一种表达方式，一种不太好的表达方式，遇到争执时，可以通过发怒来表达，但效果没有通过言语沟通交流来得好。所以遇到争执无法解决时，不妨承认错误，以免事情的讨论上升到人身的讨论，变成你对我错的二元选择。当你坚信是对的话，别人持什么样的态度都无法改变你的观点。</li></ul><h3 id="关于人生">关于人生</h3><ul><li>人生行为的两大目标：自立和与社会和谐相处。而支持这些想法的也有两个心理目标：我有能力的意识和人人都是我的伙伴的意识。这些目标可以通过直面人生课题来解决，包括工作，交友，爱。</li><li>人生的谎言。我们常常为逃避生活中遇到的事情而寻找开脱的谎言和借口。一个很典型的例子，不是因为某人的缺点而讨厌某人，而是因为讨厌某人而自然就会去发现其缺点，归根到底，实在逃避糟糕的人际关系。我讨厌某人，不愿与某人相处，我发现到他有什么缺点，因为他有这些问题，我就可以离他远点，不用相处。</li><li>否定寻求他人认同的行为和想法，我们没有必要总是想着需要满足他人的期待。每个人都只是为了自己活着，而非为了其他人活着。但在实际生活中，好多人都无法做到这一点，甚至可能会事事都想着得到他人的认同，从而被他人影响自身的行为，不得不做许多并不情愿的行为。</li><li>工作课题的分离。所谓的工作课题，为每个人各自应该要做的事情，不同人，具有不同的身份，处于不同的位置都具有不同的工作课题，我们不应该干涉他人的工作课题，也不应该被他人干涉。如何判断工作课题属于谁？谁将承担后果就由谁来处理。当我们在日常生活中陷入困境或对现状不满时，我们不妨想一想有没有进入到他人的课题中，如果有，果断抛开，进行分离。正如上面说到的让他人满意，他人接受，这不应该是你的课题，你做完了自己的工作就已经足够，他人是否接受，如何评价，会否反对，都是他人的课题，你不应该操心，操心也没有用。而如果你操心了他人的课题，选择采取额外的工作或者改变来迎合他人，则只会增加自己的不满。另外，因为工作课题的分离，我们的责任也可以随着不干涉他人的课题一并减轻。</li><li>但是，有些人却对着这种所谓的责任存有留恋，并认为这种操心他人课题的责任能够有利于他人的成长。就像家长操心孩子的成长，干涉孩子的成长的课题，以是为了孩子好的理由，为其铺排好一切道路。是选择带着不满接受父母为其铺排好的可能较大几率有着较好前程的道路，还是自由地选择自己想要的道路，这取决于个人的选择，没法给出一个确定的答案。但前者的所谓较好前程，难道不是在满足他人的认可和期待吗？尽管如此，很多人可能还是会倾向于前者，因为不需要自己做出选择，可能是因为确实迷茫不知道如何选择，更有可能是因为前者不需要自己亲自做出选择，选择都不是我做的，如果结果不好的话，我能够有埋怨的对象，“都说了不这样”。</li></ul><h3 id="关于勇气">关于勇气</h3><ul><li>被讨厌的勇气。我们不可能做到不被所有人讨厌，自由就是被别人讨厌。每个人都有寻求认可的倾向性，而从中寻求解脱就是获取自由。当否定了寻求他人的认可之后，必然会存在有人不认可你，进而产生讨厌的念头。我们对此无能为力，也无须担心。他人是否讨厌我，这是他人的课题，我操心不来，而如果为其改变了自己，则违背了工作课题分离的原则，徒增自身的麻烦。</li><li>人的一切烦恼皆来自于人际关系。即便如此，在我们的人生课题中，我们还是无法避免人际关系，尤其是我们在社会中其实均处于一个共同体当中。所谓的共同体，可以大至一个国家，也可以小至一个两人的家庭。我们应该主动参与到共同体当中，这也课题分离并不矛盾，共同体并不唯一，也不存在非加入不可的共同体。基于此，当我们在某一共同体中出现不满或者矛盾，我们可以及时离开这一个共同体，将目光转向更大的，别处的共同体。</li><li>不应该批判，也不应该表扬。因为批判和表扬很容易将自身和他人放入一种纵向的关系当中，我对你进行批判或表扬，暗含着我有这个能力，暗示着我比你高一等的感觉，我可以批判你，也可以表扬你，带有一种操纵干涉的味道在此。值得提倡的，是鼓励。鼓励，是站在横向关系的角度。大多数人并不是缺乏解决问题的能力，而是缺乏面对问题的勇气，而鼓励，正是帮助对方意识到问题的本质，帮助他人寻找面对的勇气。</li><li>每个人都会受到自我意识羁绊，不能无拘无束的活动。正如在他人的面前，我们会很小心自己的言行，生怕影响了在他人面前的印象，但是只有自己一个人独处的时候，就会将其压抑完全暴露。本质上，我们是缺乏暴露本真的自己在他人面前的勇气。为此，我们需建立共同体感觉，所谓共同体感觉，就是对自我的执着，转化为对他人的关心。建立共同体感觉，需要从下面三点做起：自我接纳，他者信赖，他者奉献。</li><li>所谓的自我接纳，正如其本身的意思，就是接纳真实的自我，意识到自己能做什么，做不到什么。这是一种肯定性的达观，对于无法改变的，淡然接受，可以改变的，勇敢地取面对它。所谓的他者信赖，即是在人际关系中需要建立无条件的信赖关系，信任遭到了背叛怎么办，还是需要保持这种无条件的信赖关系，是否背叛这个属于他人的课题，我们不应该操心，但是若果多次背叛你，使你不愿与其继续相处，可以及时断绝关系，进行分离。他者奉献，则是在向作为伙伴的他人奉献的过程中找到自己的价值，区别于寻求他人的认同，我们所做的事情是否有价值，不是由他人来评价的，而是由自己的内心来决定。这里要将贡献和作用区分开来，你做出的贡献，判断其是否具有作用，这是他人的课题，我们只需将目光集中在自己的贡献即可。我做了某些事，我觉得自己对他人，对共同体都是有奉献的就可以了。</li><li>犹太教教义中有这么一段话：“假如有10个人，其中势必会有1个人无论遇到什么事都会批判你。他讨厌你，你也不喜欢他。而且，10个人中也会有2个人能够成为与你互相接纳一切的好朋友。剩下的7个人则两者都不是。”如果我们总是将目光只集中在事物的部分来决定其总体，我们则无法获得人生的和谐。另外，只将目光集中在人生的特定侧面，也是如此，例如工作狂。</li></ul><h3 id="关于幸福">关于幸福</h3><ul><li>相比于设定一个远大目标，然后当下一直为其进行铺排和准备，我们更应该活在当下，活在此时此刻。人生不应该是一条线，并不是设定一个个的目标点，就能将自身和人生中的一个个阶段，一个个目标点连接起来的。如果只为了所谓的远大目标，我们在目标达成前所做的一切都只是在忍受获得成功的痛苦，这样是不理智的，万一失败了，到达不了终点呢？当前的忍受皆是白费？我们应该将人生看成是一个个不连续的点，每一个不连续的点都是当下，只有集中于当下，专注于此时此刻所做的事情，不考虑过去与将来，我们才能够获得长久的幸福感。正如登山，从踏出的第一步就开始了个人的旅途，如果我们只是一心想着登到山顶，那么途中的一切乐趣就会丢失，还不如直接坐缆车到山顶。</li><li>专注于此时此刻，不考虑过去与将来，我们能够很自由地活在当下，享受当下，但是，我们可能会感到迷茫，如何选择人生的方向呢，也就是下一个此时此刻怎么选择？答案是他者奉献。无论你过着怎样的刹那，即使有人讨厌你，只要没有迷失“他者贡献”这颗引导之星，那么你就不会迷失，而且做什么都可以。即使被讨厌自己的人讨厌着也可以自由地生活。而且，我们要像跳舞一样认真过好作为刹那的“此时此刻”，既不看过去也不看未来，只需要过好每一个完结的刹那。没必要与谁竞争，也不需要目的地，只要跳着，就一定会到达某一个地方。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/26369699/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《被讨厌的勇气》&lt;/a&gt;通过哲人与青年的对话，探讨人如何获得幸福，并且通过阿德勒心理学对人生的诸多问题进行剖析。&lt;/p&gt;
&lt;p&gt;这本书最在是在知乎看到有人强推，遂在微信读书里找到此书并读完。在读的过程中，感到其所谈到的一些现象真实地切中了我的想法，感觉到描述的例子就正正是我本人。其中的一些观念我觉得很好，或者说是很适合我，于是在看的时候进行了若干地记录，摘录了一些语句，并写了点个人的体会。但因为始终不是在上课做笔记，摘录得也有些随意，有些摘录也是根据我的体会二次加工出来的，所以就这样看吧（逃&lt;/p&gt;
    
    </summary>
    
      <category term="读书总结" scheme="http://scottyeung.top/categories/%E8%AF%BB%E4%B9%A6%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
      <category term="心态" scheme="http://scottyeung.top/tags/%E5%BF%83%E6%80%81/"/>
    
      <category term="人生" scheme="http://scottyeung.top/tags/%E4%BA%BA%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>Some Notes About SQLAlchemy</title>
    <link href="http://scottyeung.top/2019/Some-Notes-About-SQLAlchemy/"/>
    <id>http://scottyeung.top/2019/Some-Notes-About-SQLAlchemy/</id>
    <published>2019-12-07T02:24:35.000Z</published>
    <updated>2020-07-16T16:28:17.364Z</updated>
    
    <content type="html"><![CDATA[<p>近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。</p><p>SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求： - 提供对数据库的常用操作：增删改查 - 提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据</p><a id="more"></a><h2 id="数据库连接">数据库连接</h2><p>SQLalchemy不能支持操作数据库，因而需要安装额外的数据库驱动，对于不同的数据库与驱动，有着不一样的配置URI，总体格式为<code>dbms://user:pwd@host/dbname</code>。这里用的Mysql+mysqlconnector，具体的连接代码如下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sqlalchemy import create_engine</span><br><span class="line">from sqlalchemy.orm import sessionmaker</span><br><span class="line"></span><br><span class="line">sql_connection &#x3D; &#39;mysql+mysqlconnector:&#x2F;&#x2F;root:pwd@localhost:3306&#x2F;database&#39;</span><br><span class="line">engine &#x3D; create_engine(sql_connection)</span><br><span class="line"></span><br><span class="line"># 执行sql事务需要使用会话</span><br><span class="line">DBsession &#x3D; sessionmaker(bind&#x3D;engine)</span><br><span class="line">session &#x3D; DBsession()</span><br><span class="line"></span><br><span class="line"># 结束前需要关闭session</span><br><span class="line">session.close()</span><br></pre></td></tr></table></figure></p><h2 id="结构定义">结构定义</h2><p>在SQLalchemy中，ORM通过定义对象进行数据库model的绑定。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.declarative import declarative_base</span><br><span class="line">from sqlalchemy.orm import relation, sessionmaker</span><br><span class="line"></span><br><span class="line">Base &#x3D; declarative_base()</span><br><span class="line"> </span><br><span class="line">class Movie(Base):</span><br><span class="line">    __tablename__ &#x3D; &#39;movies&#39;</span><br><span class="line"> </span><br><span class="line">    id &#x3D; Column(Integer, primary_key&#x3D;True)</span><br><span class="line">    title &#x3D; Column(String(255), nullable&#x3D;False)</span><br><span class="line">    year &#x3D; Column(Integer)</span><br><span class="line">    directed_by &#x3D; Column(Integer)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">    def __init__(self, title&#x3D;None, year&#x3D;None):</span><br><span class="line">        self.title &#x3D; title</span><br><span class="line">        self.year &#x3D; year</span><br></pre></td></tr></table></figure></p><ul><li>ORM的model类通过继承declarative_base进行定义，通过<code>__tablename__</code>绑定到对应的table</li><li>每一个Column属性为表中的一列，需要设置类型，类型必须要与数据库中列的类型对应，常用类型有Integer，Float， String（对应varchar），Text</li><li>必须设置一个属性/列为<code>primary_key</code></li><li>可以通过<code>Base.metadata.create_all(engine)</code>创建table</li></ul><h2 id="数据操作">数据操作</h2><p>数据使用ORM进行操作，操作的基本单位为对象（也可以直接使用sql语句，但对于常用操作来说没有必要）。除查询外，对数据库有修改的操作都需要commit事务</p><h3 id="插入">插入</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m1 &#x3D; Movie(&quot;Star Trek&quot;, 2009)</span><br><span class="line">session.add(m1)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><ol type="1"><li>创建待插入的对象，添加相应的数据属性</li><li>添加进session中</li><li>提交session，提交事务</li></ol><h3 id="查询">查询</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movies &#x3D; session.query(Movie).all() # 获取所有数据</span><br><span class="line">movie &#x3D; session.query(Movie).get(movie_id) # 获取单个记录</span><br><span class="line">filter_movie &#x3D; session.query(Movie).filter(Movie.id &#x3D;&#x3D; 1).one()</span><br></pre></td></tr></table></figure><ul><li>查询中query的参数为查询的table/返回的对象</li><li>filter等于where语句，可以对查询结果进行进一步筛选，one返回唯一行，all则返回所有行</li></ul><h3 id="更新">更新</h3><p>查询出来的数据，修改属性后重新提交事务即可。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie &#x3D; session.query(Movie).get(id)</span><br><span class="line">movie.year &#x3D; 1999</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></p><h3 id="删除">删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movie &#x3D; session.query(Movie).get(id)</span><br><span class="line">session.delete()</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure><h2 id="some-problems">some problems</h2><h3 id="大批量数据插入">大批量数据插入</h3><p>在使用的过程中，遇到一次需要插入三十多万条数据到数据库的情况。在此之前，我一直都是插完数据再一起commit的（几千/几百条），因为每次commit需要写入数据库，会比较慢（磁盘IO制约）。 但这次数量过多的话，提交的时候出现错误，提示mysql的连接丢失。估计是写入的时间太多，时间太长超出了其限制，进而断开了连接。于是我选择批量commit，在添加一定数量数据后提交一次（5000/1000/500/100/10），但是没有成功，插入一定量的记录后，提示某一条插入的记录的某一列过长（尽管我那一列是不限长度的Text），显然有问题。 上网搜索批量数据插入的方法，但内容基本都是千篇一律，全部都是转载/翻译StackOverflow上的一篇<a href="https://stackoverflow.com/questions/3659142/bulk-insert-with-sqlalchemy-orm" target="_blank" rel="noopener">回答</a>。给出了两种方法 - bulk_save_objects(objects) - add_all()</p><p>都没有效果，最终还是采取了逐条添加并提交的方法，虽然慢了点，但是能work。</p><p>写这件事只是为了吐槽一下现在用Google搜索一些具体的技术问题是，内容严重同质化的现象，大家都抄来抄去，转来转去。像这一次的搜索，最开始的source是在StackOverflow上的提问，然后有网站翻译成了中文并发布（甚至初创，然后就流传于各个中文网站了，一搜，全是这些内容相同的网页，属实恶心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;近期在收集处理大量的数据，通常是把XML/文本格式的数据转为关系型，结构化的的数据，能够方便导出直接进行分析，尤其是导出能直接被pandas分析的格式（csv/json）。因此需要使用一个在Python下的mysql处理库，既然找了处理库，也干脆一步到位，直接选一个支持ORM的库。于是，就选择了SQLAlchemy。用了一段时间后，写个记录来记下这段时间用到的常用的东西。&lt;/p&gt;
&lt;p&gt;SQLAlchemy是Python编程语言下的一款开源软件。提供了SQL工具包及对象关系映射（ORM）工具，主要能满足一下的需求： - 提供对数据库的常用操作：增删改查 - 提供ORM功能，可以让操作的单元变为对象，而不用写sql语句进行硬编码/解码解析数据&lt;/p&gt;
    
    </summary>
    
      <category term="数据库" scheme="http://scottyeung.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="notes" scheme="http://scottyeung.top/tags/notes/"/>
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Summary of Automate the Boring Stuff with Python</title>
    <link href="http://scottyeung.top/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/"/>
    <id>http://scottyeung.top/2019/Summary-of-Automate-the-Boring-Stuff-with-Python/</id>
    <published>2019-11-04T08:15:25.000Z</published>
    <updated>2020-07-16T16:28:17.381Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://automatetheboringstuff.com/#toc" target="_blank" rel="noopener">本书</a>是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。</p><p>作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。</p><a id="more"></a><p>本书结构分为三部分： 1. 开头首先解释了为什么可以用编程提高效率以及为什么选择Python 2. Python的学习 3. Python在日常生活/工作的具体使用</p><p>鉴于笔者已经学习过Python，故直接跳过前两部分，进行阅读记录。</p><h2 id="读写文件">读写文件</h2><h3 id="文件">文件</h3><ul><li>程序运行时，数据可以存储变量中，但若想持久地存储数据，则需存储在文件中</li><li>文件的表示由路径+文件名组成</li><li>Windows系统路径使用而Linux/Mac使用/，为确保代码能统一运行，可使用<code>os.path.join</code>进行连接路径</li><li><code>os.path.getsize</code>获取文件大小</li><li><code>os.listdir</code>获取文件夹内容</li><li>文件按内容可分为文本文件和二进制文件</li></ul><h3 id="读写">读写</h3><ul><li>过程<ol type="1"><li><code>open(path, mode='r')</code>打开文件返回<code>File</code>对象</li><li>通过<code>read</code>或<code>write</code>对文件对象进行读写</li><li><code>close</code>关闭文件对象</li></ol></li><li>文件打开分为读(r)，写(w)，追加(a)</li><li>read以字符串形式返回整个文件内容，readline逐行返回</li><li>可通过<code>shelve</code>模块进行变量的读取和保存</li></ul><h3 id="实例">实例</h3><h4 id="随机生成测试文件">随机生成测试文件</h4><p>地理老师打算给35个学生出一份关于美国50个州对应的城市的选择题，目标形式为35个测试题文件，35个对应的答案文件，要求是35份选择题不一样，其中题目顺序不一样，选择题选项不一样。</p><ol type="1"><li>将测试数据以<code>dict</code>的形式存储在文件中/输入代码中</li><li>创建测试文件和答案文件，并写入首部信息</li><li>随机函数打乱数据给出的州的顺序，选出对应的城市，在给出的城市数据中删去正确答案，随机选出3个作为错误答案</li><li>将3中得到的州以及选项城市写入测试文件和答案文件</li></ol><h4 id="多重剪贴板">多重剪贴板</h4><p>当需要多次进行复制粘贴时，下次的复制内容会把上一次的内容给覆盖，这样当需要重复使用复制内容时就很不方便。因此，实现多重剪贴板的功能，可以记录过往的复制内容，便于重复使用。</p><ol type="1"><li>每次运行程序时通过<code>shelve</code>读取本地的变量数据</li><li>根据输入的参数判断执行的功能</li><li>当需要记录剪贴板时，调用<code>pyperclip.paste</code>获取当前剪贴板内容，并存至变量</li><li>当需要展示历史剪贴板内容时，将存储的变量列表或单个变量转化为字符串通过<code>pyperclip.copy</code>复制进剪贴板</li></ol><h2 id="整理文件">整理文件</h2><p>批量处理文件，包括遍历，复制，重命名，移动或压缩。主要使用<code>shutil</code>模块</p><ul><li>复制：<ul><li>shutil.copy</li><li>shutil.copytree</li></ul></li><li>移动：<ul><li>shutil.move</li></ul></li><li>删除<ul><li>os.unlink</li><li>os.rmdir 空目录</li><li>os.retree 目录所有</li></ul></li><li>遍历 os.walk 返回迭代器关于 current_folder,sub_folders,files</li><li>压缩 zipfile模块</li></ul><h3 id="实例-1">实例</h3><h4 id="文件名字转换">文件名字转换</h4><p>将数千个文件的名字中的美式时间 (MM-DD-YYYY)改为欧式时间  (DD-MM-YYYY)</p><ol type="1"><li>构造正则表达式用于识别时间</li><li>遍历目录的名字 <code>os.listdir</code>，并通过正则表达式进行识别，并将其分割</li><li>若满足正则表达式，则通过shutil.move改名</li></ol><p>相关任务 - 批量文件名字添加前缀</p><h4 id="文件夹压缩">文件夹压缩</h4><p>将指定文件夹及其下所有文件和文件夹压缩</p><ol type="1"><li>寻找一可用不重复的压缩路径+文件名</li><li>创建压缩文件</li><li>遍历目录，将所有文件和文件夹写入压缩文件</li><li>关闭压缩文件</li></ol><h2 id="web爬取">WEB爬取</h2><p>设计模块 - webbrowser - open 打开网页 - request - get 获取资源 - raise_for_status 判断是否就绪 - iter_content 获取内容的迭代器 - Beautiful Soup 解析HTML文档 - select - Selenium</p><h3 id="实例-2">实例</h3><h4 id="批量打开网页">批量打开网页</h4><p>根据给出的地址批量打开Google Map的网页</p><ol type="1"><li>根据给出的地址生成URL地址</li><li>使用<code>webbrowser.open</code>打开URL地址的网页</li></ol><h4 id="搜索关键词">搜索关键词</h4><p>根据关键词进行google搜索，并将搜索结果的每一个页面打开</p><ol type="1"><li>根据关键词使用<code>request.get</code> 请求搜索结果页面</li><li>使用Beautiful Soup解析页面，找出所有搜索结果的超链接</li><li>使用<code>webbrowser.open</code>打开获取的超链接</li></ol><p>类似用途： - 打开购物页面所有商品的页面 - 打开商品的所有评价页面 - 获取搜索图片的所有结果</p><h4 id="下载网页漫画">下载网页漫画</h4><p>下载XKCD的漫画，下载完后下载上一页，直至下载完第一页后结束</p><ol type="1"><li>获取XKCD的网页，抽取漫画部分写入文件</li><li>找到上一页按钮的超链接，并获取上一页的漫画网页</li><li>重复1-2直至找不到上一页按钮</li></ol><h2 id="操作excel">操作Excel</h2><p>利用第三方模块<code>openpyxl</code>，进行excel文件的读写</p><ul><li>load_workbook</li><li>get_sheet_by_name</li><li>cell(row=1, column=2)</li><li>save</li></ul><h3 id="实例-3">实例</h3><h4 id="读取excel并统计数据">读取Excel并统计数据</h4><p>根据Excel文件的数据，进行聚类分析，分别进行聚类计数以及聚类求和。 事实上，Excel本身功能即可完成并且更加简单，故跳过。</p><h4 id="更新excel文件中指定列">更新Excel文件中指定列</h4><p>读取Excel文件，遍历每一行，如果该行为指定商品，则修改其价格</p><h2 id="操作pdf">操作PDF</h2><ul><li>打开PDF文件并提取文本</li><li>PDF文档解密——输入密码</li><li>文档加密</li><li>创建pdf文件，添加页面</li><li>pdf页面合并——添加水印</li></ul><h3 id="实例-4">实例</h3><h4 id="多个pdf文档指定页面合并">多个PDF文档指定页面合并</h4><p>选择目录下所有PDF文档的非首页按照字典序合并到一个新的PDF文档中</p><ol type="1"><li>获取当前目录所有文件名，并取出以.pdf结尾的文件名添加至数组</li><li>数组根据文件名排序</li><li>按顺序打开每一个PDF文档，每一个文档读取从第二页开始读取，添加至新文档</li><li>保存新文档</li></ol><h2 id="操作csv和json">操作CSV和JSON</h2><h3 id="csv">CSV</h3><p>通过csv模块，可以进行csv的读写。读取类似于一个二维数组，写可以通过write_row写入行。</p><h4 id="实例-5">实例</h4><p>读取目录下所有csv文件的数据，去除首部信息</p><ol type="1"><li>获取目录所有文件名，并进行遍历，非csv文件跳过</li><li>打开csv文件，读取csv数据，跳过第一行，其余的行添加进数组</li><li>将数组中的行以csv方式写入新文件</li></ol><h3 id="json">JSON</h3><p>Json为常用的一个数据格式，多用于API之间进行交互，但日常生活中用得比较少。通过json模块，可以将json格式的字符串转成dict。</p><h4 id="获取实时天气数据">获取实时天气数据</h4><p>通过网上提过的天气服务接口，获取指定地点的实时天气情况</p><ol type="1"><li>通过命令行获取地点输入</li><li>将地点作为参数向指定天气服务API发送HTTP请求</li><li>解析返回的json数据，进行输出</li></ol><h2 id="操作email">操作Email</h2><h3 id="实例-6">实例</h3><p>根据Excel表格中的会员数据情况，给其中尚未支付本月会籍费用的会员发送邮件进行提醒</p><ol type="1"><li>打开Excel文件读取会员数据，判断最后一列是否为paid，若是，则记录会员名与邮箱地址</li><li>通过模块smtplib登录邮箱，跟根据上一步记录的信息一一发送邮件</li></ol><h2 id="自动化操作鼠标和键盘">自动化操作鼠标和键盘</h2><p>通过第三方模块pyautogui实现，可进行图形界面的相关操作：</p><ul><li>控制鼠标以指定速度移动</li><li>获取鼠标位置</li><li>鼠标进行交互操作<ul><li>点击</li><li>拖动</li><li>滚动</li></ul></li><li>截屏</li><li>图像识别</li><li>键盘按下/松开 指定键/组合键</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://automatetheboringstuff.com/#toc&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本书&lt;/a&gt;是为如何用Python进行自动化处理工作以及可以用在哪些方面，面向的人群为想要提高生产力，减少重复劳动的非程序员。&lt;/p&gt;
&lt;p&gt;作为一个未来的程序员，我为什么推荐这本面向非程序员的书呢？在我看来，code是一个工具，既然是一种工具，就应该用于帮助解决问题和满足需求。但实际上，在我们许多的coding相关的学习中，我们并没有考虑why，而是简单粗暴地去学习what，这样学习效率不高，而且最关键的是会有一种不知道有什么用/有没有用的迷茫感，从而丧失继续学习的动力。因此，我推荐这本书，从需求出发，以需求作为目标驱动，告诉你能干什么，而且具体的使用部分也不必按部就班的学习，掌握一定的基础语法后即可根据需求跳转到相关部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://scottyeung.top/tags/Python/"/>
    
      <category term="自动化" scheme="http://scottyeung.top/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="summary" scheme="http://scottyeung.top/tags/summary/"/>
    
  </entry>
  
</feed>
